# üéØ Problem 16: Clone Graph

**Difficulty:** üü° Medium  
**Pattern:** Graph Traversal (DFS/BFS) + Hash Map  
**LeetCode Link:** [#133 Clone Graph](https://leetcode.com/problems/clone-graph/)

---

## üìã Problem Statement

Given a reference of a node in a **connected undirected graph**, return a **deep copy (clone)** of the graph.

Each node in the graph contains:
- A value (`val`)
- A list of its neighbors (`neighbors`)

```python
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
```

### Examples:

```
Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]
Explanation: 4-node graph where:
1 -- 2
|    |
4 -- 3

Input: adjList = [[]]
Output: [[]]
Explanation: Single node with no neighbors

Input: adjList = []
Output: []
Explanation: Empty graph
```

---

## üéì Understanding

### What is a Deep Copy?

**Shallow Copy:** Copy references to original nodes ‚ùå  
**Deep Copy:** Create entirely new nodes with same structure ‚úÖ

```python
# WRONG: This is shallow copy
def cloneGraph(node):
    return node  # Same reference!

# RIGHT: Create new nodes
def cloneGraph(node):
    return Node(node.val, [...])  # New object
```

---

## üîç Key Insights

### Challenge 1: Avoiding Infinite Loops

Graphs can have cycles:
```
1 -- 2
|    |
4 -- 3
```

If we don't track visited nodes, we'll loop forever!

### Challenge 2: Maintaining Connections

When cloning node 1, its neighbors might not exist yet. We need to:
1. Clone each node exactly once
2. Maintain neighbor relationships
3. Handle cycles properly

### Solution: Hash Map for Visited Nodes

```python
visited = {}  # original_node -> cloned_node
```

---

## ‚úÖ Solution 1: DFS (Recursive)

```python
def cloneGraph(node: 'Node') -> 'Node':
    """
    Deep clone using DFS with hash map.
    
    Time: O(N + E) where N = nodes, E = edges
    Space: O(N) for hash map + recursion stack
    """
    if not node:
        return None
    
    # Hash map: original -> clone
    visited = {}
    
    def dfs(node):
        # Already cloned? Return the clone
        if node in visited:
            return visited[node]
        
        # Clone the node (without neighbors first)
        clone = Node(node.val)
        visited[node] = clone
        
        # Clone all neighbors recursively
        for neighbor in node.neighbors:
            clone.neighbors.append(dfs(neighbor))
        
        return clone
    
    return dfs(node)
```

### üìä Step-by-Step Example

Graph: `1 -- 2 -- 3`

```
1. dfs(1):
   - Create clone1
   - visited = {1: clone1}
   - Process neighbor 2
   
2. dfs(2):
   - Create clone2
   - visited = {1: clone1, 2: clone2}
   - Process neighbor 1 ‚Üí Already in visited! Return clone1
   - Process neighbor 3
   
3. dfs(3):
   - Create clone3
   - visited = {1: clone1, 2: clone2, 3: clone3}
   - Process neighbor 2 ‚Üí Already in visited! Return clone2
   
Result: Fully connected clone!
```

---

## ‚úÖ Solution 2: BFS (Iterative)

```python
from collections import deque

def cloneGraph(node: 'Node') -> 'Node':
    """
    Deep clone using BFS with queue.
    
    Time: O(N + E)
    Space: O(N)
    """
    if not node:
        return None
    
    # Hash map: original -> clone
    visited = {node: Node(node.val)}
    queue = deque([node])
    
    while queue:
        current = queue.popleft()
        
        # Process all neighbors
        for neighbor in current.neighbors:
            if neighbor not in visited:
                # Clone neighbor
                visited[neighbor] = Node(neighbor.val)
                queue.append(neighbor)
            
            # Add cloned neighbor to cloned current
            visited[current].neighbors.append(visited[neighbor])
    
    return visited[node]
```

---

## üîÑ Solution 3: Two-Pass Approach

```python
def cloneGraph(node: 'Node') -> 'Node':
    """
    Two passes: First create all nodes, then connect them.
    
    Time: O(N + E)
    Space: O(N)
    """
    if not node:
        return None
    
    visited = {}
    
    # Pass 1: Clone all nodes (without neighbors)
    def clone_nodes(node):
        if not node or node in visited:
            return
        visited[node] = Node(node.val)
        for neighbor in node.neighbors:
            clone_nodes(neighbor)
    
    # Pass 2: Connect all neighbors
    def connect_neighbors(node):
        if not node:
            return
        for neighbor in node.neighbors:
            visited[node].neighbors.append(visited[neighbor])
            if len(visited[neighbor].neighbors) == 0:
                connect_neighbors(neighbor)
    
    clone_nodes(node)
    connect_neighbors(node)
    
    return visited[node]
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| DFS Recursive | O(N + E) | O(N) | Recursion stack + hash map |
| BFS Iterative | O(N + E) | O(N) | Queue + hash map |
| Two-Pass | O(N + E) | O(N) | Cleaner separation |

**N** = number of nodes  
**E** = number of edges

---

## üéØ Key Patterns

### Pattern 1: Graph Traversal with Visited Set
```python
visited = {}  # Track cloned nodes
if node in visited:
    return visited[node]
```

### Pattern 2: Clone Then Connect
```python
# 1. Create clone
clone = Node(node.val)
visited[node] = clone

# 2. Connect neighbors
for neighbor in node.neighbors:
    clone.neighbors.append(dfs(neighbor))
```

### Pattern 3: Handle Empty/Single Node
```python
if not node:
    return None
```

---

## üêõ Common Mistakes

### ‚ùå Mistake 1: Infinite Loop
```python
def cloneGraph(node):
    clone = Node(node.val)
    for neighbor in node.neighbors:
        clone.neighbors.append(cloneGraph(neighbor))  # Loops forever!
    return clone
```

**Fix:** Use visited hash map!

### ‚ùå Mistake 2: Shallow Copy
```python
def cloneGraph(node):
    return node  # Not a clone!
```

### ‚ùå Mistake 3: Cloning Neighbors Before Node
```python
# WRONG ORDER
for neighbor in node.neighbors:
    clone.neighbors.append(dfs(neighbor))
clone = Node(node.val)  # Too late!
```

---

## üéØ Practice Problems

1. **[LeetCode 138] Copy List with Random Pointer** (Medium)
2. **[LeetCode 323] Number of Connected Components** (Medium)
3. **[LeetCode 261] Graph Valid Tree** (Medium)
4. **[LeetCode 1485] Clone Binary Tree with Random Pointer** (Medium)

---

## üèÜ Key Takeaways

1. **Use hash map** to track original ‚Üí clone mapping
2. **DFS or BFS** both work - choose based on preference
3. **Clone node first**, then process neighbors
4. **Check visited** before cloning to avoid infinite loops
5. **Deep copy** means new objects, not references

---

## üí° Interview Tips

**When asked about cloning:**
- Clarify: Deep or shallow copy?
- Discuss: Cycle handling strategy
- Mention: Hash map for O(1) lookup
- Consider: Stack overflow with deep recursion (prefer BFS for very large graphs)

---

**Ready to test?** üöÄ Move to **`16.Clone-Graph-Mock-Interview-Mode.md`**

*Happy Coding! üíª‚ú®*
