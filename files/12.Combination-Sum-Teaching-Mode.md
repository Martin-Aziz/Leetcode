# 🎯 Problem 12: Combination Sum

**Difficulty:** 🟡 Medium  
**Pattern:** Backtracking / Recursion  
**Time Limit:** 25 minutes  
**LeetCode Link:** [#39 Combination Sum](https://leetcode.com/problems/combination-sum/)

---

## 📋 Problem Statement

Given an array of **distinct** integers `candidates` and a target integer `target`, return *a list of all **unique combinations** of* `candidates` *where the chosen numbers sum to* `target`. You may return the combinations in **any order**.

The **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

### Examples:

**Example 1:**
```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
```

**Example 2:**
```
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
```

**Example 3:**
```
Input: candidates = [2], target = 1
Output: []
```

### Constraints:
- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- All elements of `candidates` are **distinct**
- `1 <= target <= 40`

---

## 🎓 Understanding the Problem

### What are we finding?

All **unique combinations** that sum to target, where:
- Can reuse same number unlimited times
- Order doesn't matter: [2,3] and [3,2] are same
- Want all valid combinations, not just one

### Visual Example:

```
candidates = [2,3,6,7], target = 7

Decision tree:
                    []
          /    /    |     \
        2     3     6      7
       /|\   /|\    |
      2 3 6 2 3 6   X (>7)
     /|\          
    2 3 6
   / 
  2 (sum=8, too big)

Valid paths:
- 2→2→3 = [2,2,3] ✓
- 7 = [7] ✓
```

---

## 🔍 Pattern Recognition: Backtracking

This is a **Backtracking** problem!

### Why Backtracking?

1. **Generate all combinations** - need to explore all possibilities
2. **Prune invalid paths** - stop when sum > target
3. **Make choices** - include number or move to next

### Backtracking Template:

```python
def backtrack(path, start, remaining):
    # Base case: found valid combination
    if remaining == 0:
        result.append(path.copy())
        return
    
    # Pruning: remaining negative
    if remaining < 0:
        return
    
    # Try each candidate
    for i in range(start, len(candidates)):
        # Make choice
        path.append(candidates[i])
        
        # Recurse (same index allows reuse)
        backtrack(path, i, remaining - candidates[i])
        
        # Undo choice
        path.pop()
```

---

## 💡 Progressive Hints

<details>
<summary><b>💡 Hint 1: How to avoid duplicates?</b></summary>

Start from current index, not from beginning:

```python
for i in range(start, len(candidates)):
    backtrack(path, i, remaining - candidates[i])
                    ↑
                 same i allows reuse!
```

This ensures [2,3] is found but [3,2] is not (would be duplicate).

</details>

<details>
<summary><b>💡 Hint 2: When to stop exploring?</b></summary>

Two stopping conditions:
1. **Success:** `remaining == 0` → found valid combination
2. **Failure:** `remaining < 0` → exceeded target, backtrack

</details>

<details>
<summary><b>💡 Hint 3: Why pass `start` parameter?</b></summary>

Prevents duplicates by ensuring we only pick numbers at or after current index:

```
candidates = [2,3], target = 5

With start:
  2 → 2 (allowed, i=0)
  2 → 3 (allowed, i=1)
  3 → 2 (NOT allowed, would create duplicate [3,2])
  3 → 3 (allowed, i=1)

Result: [[2,3]] only, no [3,2]
```

</details>

---

## ✅ Complete Solution

```python
def combinationSum(candidates: list[int], target: int) -> list[list[int]]:
    """
    Find all unique combinations that sum to target using backtracking.
    
    Approach:
    - Recursively try each candidate
    - Allow reusing same candidate (start from same index)
    - Prune when sum exceeds target
    - Collect valid combinations
    
    Time: O(N^(T/M)) where N=candidates, T=target, M=min candidate
    Space: O(T/M) for recursion depth
    """
    result = []
    
    def backtrack(path: list[int], start: int, remaining: int) -> None:
        """
        Explore combinations starting from index 'start'.
        
        Args:
            path: Current combination being built
            start: Index to start exploring from
            remaining: Remaining sum needed
        """
        # Base case: found valid combination
        if remaining == 0:
            result.append(path.copy())
            return
        
        # Pruning: exceeded target
        if remaining < 0:
            return
        
        # Try each candidate from start index
        for i in range(start, len(candidates)):
            # Make choice: add candidate[i]
            path.append(candidates[i])
            
            # Recurse: same index allows reuse
            backtrack(path, i, remaining - candidates[i])
            
            # Undo choice: backtrack
            path.pop()
    
    backtrack([], 0, target)
    return result


# Test cases
def test_solution():
    assert sorted(combinationSum([2,3,6,7], 7)) == sorted([[2,2,3],[7]])
    assert sorted(combinationSum([2,3,5], 8)) == sorted([[2,2,2,2],[2,3,3],[3,5]])
    assert combinationSum([2], 1) == []
    
    print("✅ All tests passed!")

test_solution()
```

---

## 🔬 Step-by-Step Walkthrough

**Input:** `candidates = [2,3,6,7], target = 7`

```
Call backtrack([], 0, 7):
│
├─ Try candidate[0]=2:
│   path=[2], remaining=5
│   backtrack([2], 0, 5):
│   │
│   ├─ Try candidate[0]=2:
│   │   path=[2,2], remaining=3
│   │   backtrack([2,2], 0, 3):
│   │   │
│   │   ├─ Try candidate[0]=2:
│   │   │   path=[2,2,2], remaining=1
│   │   │   backtrack([2,2,2], 0, 1):
│   │   │   │
│   │   │   ├─ Try candidate[0]=2: remaining=-1 ❌ prune
│   │   │   ├─ Try candidate[1]=3: remaining=-2 ❌ prune
│   │   │   └─ No more candidates
│   │   │   
│   │   ├─ Try candidate[1]=3:
│   │   │   path=[2,2,3], remaining=0 ✓
│   │   │   → Add [2,2,3] to result!
│   │   │
│   │   └─ Other candidates too large
│   │
│   └─ Try candidate[1]=3:
│       path=[2,3], remaining=2
│       All subsequent tries fail (remaining<0)
│
├─ Try candidate[1]=3:
│   path=[3], remaining=4
│   No valid combinations found
│
├─ Try candidate[2]=6:
│   path=[6], remaining=1
│   All tries fail
│
└─ Try candidate[3]=7:
    path=[7], remaining=0 ✓
    → Add [7] to result!

Result: [[2,2,3], [7]]
```

---

## ⚡ Complexity Analysis

### Time Complexity: **O(N^(T/M))**
- N = number of candidates
- T = target value
- M = minimum candidate value
- In worst case, we explore a tree of depth T/M with N branches
- **Very difficult to analyze precisely for backtracking!**

### Space Complexity: **O(T/M)**
- Recursion stack depth = T/M (maximum depth)
- Path array at most T/M elements
- Result array not counted as output

---

## 🎨 Variations

### Variation: Combination Sum II (Each number used once)

```python
def combinationSum2(candidates: list[int], target: int) -> list[list[int]]:
    """
    Each number can be used only once.
    candidates may contain duplicates.
    """
    candidates.sort()  # Sort to handle duplicates
    result = []
    
    def backtrack(path, start, remaining):
        if remaining == 0:
            result.append(path.copy())
            return
        if remaining < 0:
            return
        
        for i in range(start, len(candidates)):
            # Skip duplicates at same level
            if i > start and candidates[i] == candidates[i-1]:
                continue
            
            path.append(candidates[i])
            backtrack(path, i + 1, remaining - candidates[i])  # i+1, not i
            path.pop()
    
    backtrack([], 0, target)
    return result
```

---

## 🎯 Practice Problems

1. **[LeetCode 40] Combination Sum II** (Medium)
2. **[LeetCode 216] Combination Sum III** (Medium)
3. **[LeetCode 377] Combination Sum IV** (Medium) - DP approach
4. **[LeetCode 46] Permutations** (Medium) - Similar backtracking

---

## 💡 Interview Tips

✅ **Draw the decision tree** during interview  
✅ **Explain backtracking clearly:** make choice → recurse → undo choice  
✅ **Discuss why start parameter** prevents duplicates  
✅ **Mention pruning** for efficiency

❌ **Don't forget** `path.copy()` when adding to result  
❌ **Don't start from 0** in recursion (causes duplicates)

---

## 🏆 Key Takeaways

1. **Backtracking = DFS with undo**
2. **Start parameter prevents duplicates**
3. **Prune early** when exceeding target
4. **Copy path** before adding to result

---

**Ready to test yourself?** 🚀  
Move on to **`12.Combination-Sum-Mock-Interview-Mode.md`**

*Happy Coding! 💻✨*
