# â±ï¸ MOCK INTERVIEW: Binary Tree Level Order Traversal

**Difficulty:** ğŸŸ¡ Medium  
**Pattern:** BFS / Queue  
**Time Limit:** â° **20 minutes**  
**Points:** 100

---

## ğŸ“‹ Problem Statement

Given the `root` of a binary tree, return the **level order traversal** of its nodes' values (from left to right, level by level).

```
Input:    3
        /   \
       9    20
           /  \
          15   7

Output: [[3], [9,20], [15,7]]
```

---

## ğŸ’¡ Clarifying Questions

1. What if the tree is empty? **Return []**
2. Can node values be negative? **Yes**
3. Can there be duplicate values? **Yes**
4. Should each level be a separate list? **Yes**

---

## ğŸ’¡ Optional Hints

<details>
<summary>ğŸ†˜ Hint 1 (âˆ’5 points)</summary>

Use **BFS with a queue**. Process nodes level by level, left to right.

</details>

<details>
<summary>ğŸ†˜ Hint 2 (âˆ’10 points)</summary>

**Key trick:** Snapshot the queue size at the start of each level!

```python
while queue:
    level_size = len(queue)  # Current level size
    current_level = []
    for _ in range(level_size):
        # Process this level...
```

</details>

<details>
<summary>ğŸ†˜ Hint 3 (âˆ’15 points)</summary>

```python
from collections import deque

queue = deque([root])
while queue:
    level_size = len(queue)
    current_level = []
    for _ in range(level_size):
        node = queue.popleft()
        current_level.append(node.val)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    result.append(current_level)
```

</details>

---

## ğŸ§‘â€ğŸ’» Your Solution

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrder(root: TreeNode) -> list[list[int]]:
    """
    Return level order traversal.
    """
    # Your code here
    pass
```

---

## âœ… Test Cases

```python
# Test 1: Empty tree
assert levelOrder(None) == []

# Test 2: Single node
root = TreeNode(1)
assert levelOrder(root) == [[1]]

# Test 3: Standard tree
#     3
#    / \
#   9  20
#     /  \
#    15   7
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)
assert levelOrder(root) == [[3], [9,20], [15,7]]

# Test 4: Unbalanced tree
#     1
#    /
#   2
#  /
# 3
root = TreeNode(1)
root.left = TreeNode(2)
root.left.left = TreeNode(3)
assert levelOrder(root) == [[1], [2], [3]]
```

---

## ğŸ“Š Grading Rubric (100 points)

### Correctness (50 points)
- âœ… Handles empty tree (5 pts)
- âœ… Single node works (5 pts)
- âœ… Correct level separation (20 pts)
- âœ… Left-to-right order (10 pts)
- âœ… All edge cases pass (10 pts)

### Time Complexity (20 points)
- âœ… O(n) solution (20 pts)
- âš ï¸ O(nÂ²) or worse (5 pts)

### Space Complexity (15 points)
- âœ… O(w) where w = max width (15 pts)
- âš ï¸ Excessive space (5 pts)

### Code Quality (10 points)
- âœ… Clean BFS implementation (5 pts)
- âœ… Proper null checks (3 pts)
- âœ… Clear variable names (2 pts)

### Communication (5 points)
- âœ… Explained BFS approach (3 pts)
- âœ… Discussed level separation (2 pts)

---

## âœ… Optimal Solution

<details>
<summary>ğŸ” BFS Solution</summary>

```python
from collections import deque

def levelOrder(root):
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result
```

**Time:** O(n) - visit each node once  
**Space:** O(w) - max width of tree in queue

</details>

<details>
<summary>ğŸ” DFS Solution (Alternative)</summary>

```python
def levelOrder(root):
    if not root:
        return []
    
    result = []
    
    def dfs(node, level):
        if not node:
            return
        
        if level == len(result):
            result.append([])
        
        result[level].append(node.val)
        dfs(node.left, level + 1)
        dfs(node.right, level + 1)
    
    dfs(root, 0)
    return result
```

**Time:** O(n)  
**Space:** O(h) - recursion stack height

</details>

---

## ğŸ¯ Performance Summary

| Metric | Target | Your Score |
|--------|--------|------------|
| Correctness | 50 pts | ___/50 |
| Time Complexity | 20 pts | ___/20 |
| Space Complexity | 15 pts | ___/15 |
| Code Quality | 10 pts | ___/10 |
| Communication | 5 pts | ___/5 |
| **Hints Used** | 0 pts | âˆ’___ |
| **Total** | **100 pts** | **___/100** |

---

## ğŸ’­ Self-Reflection

1. Did you use BFS or DFS? Why?
2. How did you separate levels?
3. Did you handle empty tree?
4. Can you solve zigzag level order now?

---

*"Snapshot the queue size!"* ğŸŒ³âœ¨
