# ⏱️ MOCK INTERVIEW: Number of Islands

**Difficulty:** 🟡 Medium  
**Pattern:** Graph Traversal (DFS/BFS)  
**Time Limit:** ⏰ **30 minutes**  
**Points:** 100

---

## 🎯 Interview Simulation

**Start your timer NOW!** ⏰

---

## 📋 Problem Statement

Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.

An **island** is surrounded by water and is formed by connecting adjacent lands **horizontally or vertically**. You may assume all four edges of the grid are surrounded by water.

### Examples:

```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1

Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

### Constraints:
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` is `'0'` or `'1'`

---

## ❓ Clarifying Questions

1. **"Are diagonal connections considered adjacent?"** → No, only horizontal/vertical
2. **"Can I modify the input grid?"** → Yes
3. **"What if the grid is empty?"** → Return 0
4. **"What counts as one island?"** → All connected '1's form one island

---

## 💭 Think Out Loud

"This is a graph traversal problem. Each cell is a node, and edges connect adjacent cells. I need to count connected components of land cells. I'll use DFS to explore each island when found..."

---

## 💡 Optional Hints

<details>
<summary>🆘 Hint 1: What algorithm? (−5 points)</summary>

Use **DFS or BFS** to explore connected land cells. When you find an unvisited '1', increment counter and mark the entire connected island as visited.

</details>

<details>
<summary>🆘 Hint 2: How to mark visited? (−10 points)</summary>

Modify the grid in-place: change '1' to '0' when visited. This prevents revisiting cells and acts as your visited tracker.

</details>

<details>
<summary>🆘 Hint 3: DFS structure? (−15 points)</summary>

```python
def dfs(r, c):
    if out_of_bounds or grid[r][c] == '0':
        return
    grid[r][c] = '0'  # mark visited
    dfs(r+1, c)  # explore 4 directions
    dfs(r-1, c)
    dfs(r, c+1)
    dfs(r, c-1)
```

</details>

---

## 🧑‍💻 Your Solution Space

```python
def numIslands(grid: list[list[str]]) -> int:
    """
    Count the number of islands in the grid.
    
    Args:
        grid: 2D list with '1' (land) and '0' (water)
        
    Returns:
        Number of islands
    """
    # Your code here
    pass


# Test your solution
if __name__ == "__main__":
    grid1 = [
        ["1","1","1","1","0"],
        ["1","1","0","1","0"],
        ["1","1","0","0","0"],
        ["0","0","0","0","0"]
    ]
    assert numIslands(grid1) == 1
    
    grid2 = [
        ["1","1","0","0","0"],
        ["1","1","0","0","0"],
        ["0","0","1","0","0"],
        ["0","0","0","1","1"]
    ]
    assert numIslands(grid2) == 3
    
    print("✅ All tests passed!")
```

---

## ⏰ Time Check!

- ⏱️ **10 min:** Should have approach and started coding
- ⏱️ **20 min:** Should have working solution
- ⏱️ **25 min:** Should be testing
- ⏱️ **30 min:** TIME'S UP!

---

## ✅ Optimal Solution

<details>
<summary><b>🔍 Click to Reveal</b></summary>

```python
def numIslands(grid: list[list[str]]) -> int:
    """
    DFS solution for counting islands.
    
    Time: O(m * n) - visit each cell once
    Space: O(m * n) - recursion stack worst case
    """
    if not grid or not grid[0]:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    islands = 0
    
    def dfs(r: int, c: int) -> None:
        # Boundary and water checks
        if (r < 0 or r >= rows or 
            c < 0 or c >= cols or 
            grid[r][c] == '0'):
            return
        
        # Mark as visited
        grid[r][c] = '0'
        
        # Explore 4 directions
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1':
                islands += 1
                dfs(i, j)
    
    return islands
```

</details>

---

## 🎯 Grading Rubric (100 Points)

### 1️⃣ Correctness (40 points)
- All basic tests pass: 20 pts
- Edge cases (empty, all water, all land): 10 pts
- Returns correct type (integer): 5 pts
- No infinite loops: 5 pts

### 2️⃣ Time Complexity (20 points)
- Achieves O(m×n): 15 pts
- Correctly explains why: 5 pts

### 3️⃣ Space Complexity (15 points)
- Recognizes recursion/queue space: 10 pts
- Explains space usage: 5 pts

### 4️⃣ Code Quality (15 points)
- Clean structure: 5 pts
- Proper boundary checks: 5 pts
- Clear variable names: 5 pts

### 5️⃣ Communication (10 points)
- Explained approach: 4 pts
- Asked clarifying questions: 3 pts
- Tested solution: 3 pts

### Penalties:
- Used hints: -5, -10, -15
- Doesn't compile: -20
- Wrong answer: -30
- Overtime: -10

---

## 📈 Your Performance Summary

| Metric | Your Result |
|--------|-------------|
| **Total Score** | ___/100 |
| **Time Taken** | ___ min |
| **Hints Used** | ___ |
| **Interview Ready?** | Yes / No |

---

## 🚀 Next Challenge

**Continue to:** `9.Product-of-Array-Except-Self-Teaching-Mode.md`

---

*"DFS/BFS: The Swiss Army knife of graph problems!"* 🎯✨
