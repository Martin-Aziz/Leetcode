# 🎯 Problem 11: Coin Change

**Difficulty:** 🟡 Medium  
**Pattern:** Dynamic Programming (Bottom-Up)  
**Time Limit:** 30 minutes  
**LeetCode Link:** [#322 Coin Change](https://leetcode.com/problems/coin-change/)

---

## 📋 Problem Statement

You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.

Return *the fewest number of coins that you need to make up that amount*. If that amount of money cannot be made up by any combination of the coins, return `-1`.

You may assume that you have an **infinite number of each kind of coin**.

### Examples:

**Example 1:**
```
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
```

**Example 2:**
```
Input: coins = [2], amount = 3
Output: -1
Explanation: Cannot make amount 3 with only coin 2
```

**Example 3:**
```
Input: coins = [1], amount = 0
Output: 0
```

### Constraints:
- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

---

## 🎓 Understanding the Problem

### What are we solving?

Find the **minimum** number of coins needed to make exact change for a given amount.

**Key Points:**
1. **Unlimited coins:** Can use same coin multiple times
2. **Minimum count:** Not just any combination, the shortest one
3. **May be impossible:** Return -1 if no solution exists

### Visual Example:

```
coins = [1, 2, 5], amount = 11

Possible combinations:
1. 11 ones:        1+1+1+1+1+1+1+1+1+1+1 = 11 coins ❌ (not minimum)
2. 5+5+1:          5+5+1 = 3 coins ✓ (minimum!)
3. 5+2+2+2:        5+2+2+2 = 4 coins ❌
4. 2+2+2+2+2+1:    6 coins ❌

Answer: 3
```

---

## 🔍 Pattern Recognition: Dynamic Programming

This is a **classic DP problem** - specifically the **Unbounded Knapsack** variant!

### Why Dynamic Programming?

1. **Optimal Substructure:** Solution for amount n uses solutions for smaller amounts
2. **Overlapping Subproblems:** Same amounts computed repeatedly
3. **Choice at each step:** Which coin to use?

### The DP Thinking Process:

**Question:** What's the minimum coins for amount 11?

**Answer:** It depends on the last coin we use:
- If last coin is 1: `1 + minCoins(10)`
- If last coin is 2: `1 + minCoins(9)`
- If last coin is 5: `1 + minCoins(6)`

Take the **minimum** of these options!

### DP Formula:

```
dp[i] = minimum number of coins to make amount i

dp[i] = min(dp[i - coin] + 1) for all coins where coin <= i

Base case: dp[0] = 0 (0 coins needed for amount 0)
```

---

## 📝 High-Level Plan

### Approach: Bottom-Up Dynamic Programming

**Core Idea:**
1. Create DP array where `dp[i]` = min coins for amount `i`
2. Initialize `dp[0] = 0` (base case)
3. For each amount from 1 to target:
   - Try using each coin
   - Take minimum coins needed
4. Return `dp[amount]`

**Pseudocode:**
```
Initialize dp array of size (amount + 1) with infinity
dp[0] = 0

For each amount from 1 to target:
    For each coin in coins:
        If coin <= amount:
            dp[amount] = min(dp[amount], dp[amount - coin] + 1)

Return dp[amount] if dp[amount] != infinity else -1
```

---

## 💡 Progressive Hints

<details>
<summary><b>💡 Hint 1: How to build the solution bottom-up?</b></summary>

Start with amount 0 (need 0 coins), then build up to target amount:

```
Amount 0: 0 coins (base case)
Amount 1: try coin 1 → dp[1] = dp[0] + 1 = 1
Amount 2: try coin 1 → dp[2] = dp[1] + 1 = 2
          try coin 2 → dp[2] = dp[0] + 1 = 1 (better!)
Amount 3: try coin 1 → dp[3] = dp[2] + 1 = 2
          try coin 2 → dp[3] = dp[1] + 1 = 2
...
```

Each amount uses previously computed values!

</details>

<details>
<summary><b>💡 Hint 2: How to initialize the DP array?</b></summary>

**Initialize with impossible value:**
```python
dp = [float('inf')] * (amount + 1)
dp[0] = 0  # Base case
```

Why infinity?
- Represents "impossible to make this amount"
- When we find a valid combination, we replace with actual count
- At the end, if still infinity → impossible → return -1

</details>

<details>
<summary><b>💡 Hint 3: The complete DP transition?</b></summary>

```python
for i in range(1, amount + 1):
    for coin in coins:
        if coin <= i:
            dp[i] = min(dp[i], dp[i - coin] + 1)
```

**Why `dp[i - coin] + 1`?**
- `dp[i - coin]` = min coins for remaining amount
- `+ 1` = add the current coin we're using
- Take minimum across all coin choices

</details>

---

## ✅ Complete Solution

```python
def coinChange(coins: list[int], amount: int) -> int:
    """
    Find minimum number of coins to make target amount using DP.
    
    Approach: Bottom-up DP
    - Build solution from amount 0 up to target
    - For each amount, try all coins and take minimum
    
    Time: O(amount * len(coins)) - two nested loops
    Space: O(amount) - DP array
    """
    # DP array: dp[i] = min coins to make amount i
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case: 0 coins for amount 0
    
    # Build up from 1 to target amount
    for i in range(1, amount + 1):
        # Try using each coin
        for coin in coins:
            if coin <= i:
                # Can use this coin
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    # Return result (or -1 if impossible)
    return dp[amount] if dp[amount] != float('inf') else -1


# Test cases
def test_solution():
    assert coinChange([1,2,5], 11) == 3
    assert coinChange([2], 3) == -1
    assert coinChange([1], 0) == 0
    assert coinChange([1], 1) == 1
    assert coinChange([1], 2) == 2
    assert coinChange([1,3,4], 6) == 2  # 3+3
    assert coinChange([186,419,83,408], 6249) == 20
    
    print("✅ All tests passed!")

test_solution()
```

---

## 🔬 Step-by-Step Walkthrough

Let's trace **`coins = [1,2,5], amount = 11`**:

```
Initial State:
dp = [0, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞, ∞]
      0  1  2  3  4  5  6  7  8  9 10 11

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

i=1 (making amount 1):
  coin=1: dp[1] = min(∞, dp[0]+1) = min(∞, 1) = 1 ✓
  coin=2: skip (2 > 1)
  coin=5: skip (5 > 1)
  dp[1] = 1

i=2 (making amount 2):
  coin=1: dp[2] = min(∞, dp[1]+1) = min(∞, 2) = 2
  coin=2: dp[2] = min(2, dp[0]+1) = min(2, 1) = 1 ✓
  coin=5: skip (5 > 2)
  dp[2] = 1

i=3 (making amount 3):
  coin=1: dp[3] = min(∞, dp[2]+1) = min(∞, 2) = 2 ✓
  coin=2: dp[3] = min(2, dp[1]+1) = min(2, 2) = 2
  coin=5: skip
  dp[3] = 2

i=4:
  coin=1: dp[4] = min(∞, dp[3]+1) = 3
  coin=2: dp[4] = min(3, dp[2]+1) = min(3, 2) = 2 ✓
  dp[4] = 2

i=5:
  coin=1: dp[5] = min(∞, dp[4]+1) = 3
  coin=2: dp[5] = min(3, dp[3]+1) = min(3, 3) = 3
  coin=5: dp[5] = min(3, dp[0]+1) = min(3, 1) = 1 ✓
  dp[5] = 1

i=6:
  coin=1: dp[6] = min(∞, dp[5]+1) = 2
  coin=2: dp[6] = min(2, dp[4]+1) = min(2, 3) = 2
  coin=5: dp[6] = min(2, dp[1]+1) = min(2, 2) = 2
  dp[6] = 2

...continuing...

i=11:
  coin=1: dp[11] = min(∞, dp[10]+1) = min(∞, 4) = 4
  coin=2: dp[11] = min(4, dp[9]+1) = min(4, 4) = 4
  coin=5: dp[11] = min(4, dp[6]+1) = min(4, 3) = 3 ✓
  dp[11] = 3

Final DP array:
dp = [0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3]

Answer: dp[11] = 3 (which is 5+5+1)
```

---

## ⚡ Complexity Analysis

### Time Complexity: **O(amount × n)**
- n = number of different coins
- Outer loop: amount iterations
- Inner loop: n coins to try
- Each operation is O(1)
- **Total: O(amount × n)**

### Space Complexity: **O(amount)**
- DP array of size (amount + 1)
- No recursion stack (iterative approach)
- **Total: O(amount)**

---

## 🎨 Alternative Approaches

### Approach 2: Top-Down DP (Memoization)

```python
def coinChange_topdown(coins: list[int], amount: int) -> int:
    """
    Recursive approach with memoization.
    
    Time: O(amount * n)
    Space: O(amount) for memo + O(amount) recursion stack
    """
    memo = {}
    
    def dp(remaining):
        # Base cases
        if remaining == 0:
            return 0
        if remaining < 0:
            return float('inf')
        
        # Check memo
        if remaining in memo:
            return memo[remaining]
        
        # Try each coin
        min_coins = float('inf')
        for coin in coins:
            result = dp(remaining - coin)
            if result != float('inf'):
                min_coins = min(min_coins, result + 1)
        
        memo[remaining] = min_coins
        return min_coins
    
    result = dp(amount)
    return result if result != float('inf') else -1
```

### Approach 3: BFS (Level-by-level)

```python
from collections import deque

def coinChange_bfs(coins: list[int], amount: int) -> int:
    """
    BFS approach: find shortest path to target amount.
    
    Think of it as: each amount is a node, coins are edges.
    Find shortest path from 0 to amount.
    
    Time: O(amount * n)
    Space: O(amount)
    """
    if amount == 0:
        return 0
    
    queue = deque([(0, 0)])  # (current_amount, num_coins)
    visited = {0}
    
    while queue:
        curr_amount, num_coins = queue.popleft()
        
        for coin in coins:
            next_amount = curr_amount + coin
            
            if next_amount == amount:
                return num_coins + 1
            
            if next_amount < amount and next_amount not in visited:
                visited.add(next_amount)
                queue.append((next_amount, num_coins + 1))
    
    return -1
```

---

## 🤔 Reflection Questions

1. **Why is this DP and not Greedy?**
   <details>
   <summary>Answer</summary>
   
   Greedy (always taking largest coin) fails!
   
   Example: coins = [1, 3, 4], amount = 6
   - Greedy: 4 + 1 + 1 = 3 coins
   - Optimal: 3 + 3 = 2 coins ✓
   
   Greedy doesn't always give optimal solution, so we need DP.
   
   </details>

2. **What if we want to know which coins to use, not just the count?**
   <details>
   <summary>Answer</summary>
   
   Track the coin used at each step:
   ```python
   parent = [-1] * (amount + 1)
   
   # In the DP loop:
   if dp[i - coin] + 1 < dp[i]:
       dp[i] = dp[i - coin] + 1
       parent[i] = coin  # Track which coin we used
   
   # Reconstruct path:
   result = []
   curr = amount
   while curr > 0:
       result.append(parent[curr])
       curr -= parent[curr]
   ```
   
   </details>

3. **What's the difference between bounded and unbounded knapsack?**
   <details>
   <summary>Answer</summary>
   
   - **Unbounded** (this problem): Can use each item unlimited times
   - **Bounded**: Each item can be used at most once
   
   Code difference: In unbounded, we don't need 2D array (item × amount), just 1D (amount).
   
   </details>

---

## 🎯 Practice Problems

1. **[LeetCode 518] Coin Change 2** (Medium)
   - Count number of ways to make change (not minimum)
   
2. **[LeetCode 139] Word Break** (Medium)
   - Similar DP structure with string segmentation

3. **[LeetCode 279] Perfect Squares** (Medium)
   - Minimum squares that sum to n

4. **[LeetCode 983] Minimum Cost For Tickets** (Medium)
   - DP with multiple choices

---

## 💡 Interview Tips

✅ **Start with examples:**
- Work through small examples by hand
- Show the DP table building process

✅ **Explain DP formula clearly:**
- `dp[i] = min(dp[i], dp[i-coin] + 1)`
- Why we take minimum across all coins

✅ **Discuss alternatives:**
- Mention greedy doesn't work
- Compare top-down vs bottom-up

✅ **Handle edge cases:**
- amount = 0 → return 0
- Impossible combinations → return -1
- Single coin scenarios

❌ **Common Mistakes:**
- Forgetting to initialize dp[0] = 0
- Not handling impossible case (infinity check)
- Using greedy approach
- Off-by-one in array size

---

## 🏆 Key Takeaways

1. **DP for optimization problems** - minimum/maximum/count
2. **Unbounded knapsack pattern** - unlimited use of items
3. **Bottom-up builds subproblems** - from 0 to target
4. **Infinity initialization** - represents impossible states
5. **Greedy fails here** - need exhaustive search with memoization

---

**Ready to test yourself?** 🚀  
Move on to **`11.Coin-Change-Mock-Interview-Mode.md`**

**Pattern Mastery Progress:**  
Session 1: Hash Map ✓ | Linked List ✓ | Stack ✓ | Greedy ✓ | Two Pointers ✓  
Session 2: Sliding Window ✓ | Binary Search ✓ | BFS/DFS ✓ | Array/Prefix ✓ | BST ✓  
**Session 3: Dynamic Programming ← YOU ARE HERE** | Backtracking | Tree Recursion | Heap | Matrix

*Happy Coding! 💻✨*
