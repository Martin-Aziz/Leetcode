# ⏱️ MOCK INTERVIEW: Course Schedule

**Difficulty:** 🟡 Medium  
**Pattern:** Cycle Detection / Topological Sort  
**Time Limit:** ⏰ **30 minutes**  
**Points:** 100

---

## 📋 Problem Statement

Given `numCourses` and `prerequisites` array where `prerequisites[i] = [ai, bi]` means you must take course `bi` before course `ai`.

Return `true` if you can finish all courses, otherwise `false`.

```
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: Circular dependency - impossible!
```

---

## 💡 Clarifying Questions

1. Can there be duplicate prerequisites? **Yes, ignore them**
2. Can a course have multiple prerequisites? **Yes**
3. What if prerequisites is empty? **Return true - all courses can be taken**
4. Can numCourses be 0? **Yes, return true**

---

## 💡 Optional Hints

<details>
<summary>🆘 Hint 1 (−10 points)</summary>

This is a **cycle detection** problem! If there's a cycle in the dependency graph, it's impossible to finish all courses.

Think: DFS with visited states OR BFS with in-degrees.

</details>

<details>
<summary>🆘 Hint 2 (−15 points)</summary>

**DFS Approach:** Use 3 states
- 0 = unvisited
- 1 = visiting (gray - in current path)
- 2 = finished (black)

If you encounter a gray node → cycle exists!

</details>

<details>
<summary>🆘 Hint 3 (−20 points)</summary>

**BFS Approach (Kahn's Algorithm):**
```python
# 1. Calculate in-degrees
in_degree = [0] * numCourses
for course, prereq in prerequisites:
    in_degree[course] += 1

# 2. Start with courses having no prerequisites
queue = [i for i in range(numCourses) if in_degree[i] == 0]

# 3. Process courses, updating in-degrees
# 4. If completed != numCourses → cycle exists
```

</details>

---

## 🧑‍💻 Your Solution

```python
def canFinish(numCourses: int, prerequisites: list[list[int]]) -> bool:
    """
    Return True if all courses can be finished.
    """
    # Your code here
    pass
```

---

## ✅ Test Cases

```python
# Test 1: No prerequisites
assert canFinish(3, []) == True

# Test 2: Valid linear dependency
assert canFinish(2, [[1,0]]) == True

# Test 3: Circular dependency
assert canFinish(2, [[1,0],[0,1]]) == False

# Test 4: Complex valid graph
assert canFinish(4, [[1,0],[2,0],[3,1],[3,2]]) == True

# Test 5: Complex with cycle
assert canFinish(3, [[0,1],[1,2],[2,0]]) == False
```

---

## 📊 Grading Rubric (100 points)

### Correctness (50 points)
- ✅ Handles empty prerequisites (5 pts)
- ✅ Detects simple cycle (15 pts)
- ✅ Handles complex valid graphs (15 pts)
- ✅ Handles multiple components (10 pts)
- ✅ All edge cases pass (5 pts)

### Time Complexity (20 points)
- ✅ O(V + E) solution (20 pts)
- ⚠️ O(V²) or worse (5 pts)

### Space Complexity (15 points)
- ✅ O(V + E) for graph (15 pts)
- ⚠️ Excessive space usage (5 pts)

### Code Quality (10 points)
- ✅ Clean graph construction (3 pts)
- ✅ Proper state management (4 pts)
- ✅ Edge case handling (3 pts)

### Communication (5 points)
- ✅ Explained DFS or BFS choice (3 pts)
- ✅ Discussed cycle detection (2 pts)

---

## ✅ Optimal Solutions

<details>
<summary>🔍 DFS Solution (Cycle Detection)</summary>

```python
def canFinish(numCourses, prerequisites):
    graph = [[] for _ in range(numCourses)]
    for course, prereq in prerequisites:
        graph[course].append(prereq)
    
    # 0=white, 1=gray, 2=black
    state = [0] * numCourses
    
    def has_cycle(course):
        if state[course] == 1:  # Gray - cycle!
            return True
        if state[course] == 2:  # Black - done
            return False
        
        state[course] = 1  # Mark gray
        for prereq in graph[course]:
            if has_cycle(prereq):
                return True
        state[course] = 2  # Mark black
        return False
    
    for course in range(numCourses):
        if has_cycle(course):
            return False
    return True
```

**Time:** O(V + E) | **Space:** O(V + E)

</details>

<details>
<summary>🔍 BFS Solution (Kahn's Algorithm)</summary>

```python
from collections import deque

def canFinish(numCourses, prerequisites):
    graph = [[] for _ in range(numCourses)]
    in_degree = [0] * numCourses
    
    for course, prereq in prerequisites:
        graph[prereq].append(course)
        in_degree[course] += 1
    
    queue = deque([i for i in range(numCourses) if in_degree[i] == 0])
    completed = 0
    
    while queue:
        course = queue.popleft()
        completed += 1
        
        for next_course in graph[course]:
            in_degree[next_course] -= 1
            if in_degree[next_course] == 0:
                queue.append(next_course)
    
    return completed == numCourses
```

**Time:** O(V + E) | **Space:** O(V + E)

</details>

---

## 🎯 Performance Summary

| Metric | Target | Your Score |
|--------|--------|------------|
| Correctness | 50 pts | ___/50 |
| Time Complexity | 20 pts | ___/20 |
| Space Complexity | 15 pts | ___/15 |
| Code Quality | 10 pts | ___/10 |
| Communication | 5 pts | ___/5 |
| **Hints Used** | 0 pts | −___ |
| **Total** | **100 pts** | **___/100** |

---

## 💭 Self-Reflection

1. Did you recognize this as a cycle detection problem?
2. Which approach did you use: DFS or BFS?
3. Did you handle all disconnected components?
4. What's the difference between Course Schedule I and II?

---

*"No cycle = schedulable!"* 📚✨
