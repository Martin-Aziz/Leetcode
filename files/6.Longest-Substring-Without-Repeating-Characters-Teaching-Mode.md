# üéØ Problem 6: Longest Substring Without Repeating Characters

**Difficulty:** üü° Medium  
**Pattern:** Sliding Window  
**Time Limit:** 25 minutes  
**LeetCode Link:** [#3 Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

---

## üìã Problem Statement

Given a string `s`, find the length of the **longest substring** without repeating characters.

### Examples:

**Example 1:**
```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**
```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**
```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Example 4:**
```
Input: s = ""
Output: 0
```

### Constraints:
- `0 <= s.length <= 5 * 10^4`
- `s` consists of English letters, digits, symbols and spaces.

---

## üéì Understanding the Problem

### What are we looking for?
- A **contiguous substring** (not subsequence!) with all unique characters
- We want the **maximum length** of such a substring
- If the string is empty, return 0

### Key Observations:
1. **Substring vs Subsequence:** 
   - Substring: consecutive characters (e.g., "abc" in "abcde")
   - Subsequence: can skip characters (e.g., "ace" in "abcde")
   - We need SUBSTRING!

2. **What breaks a valid substring?**
   - When we encounter a character we've already seen in our current window

3. **What do we track?**
   - Characters in our current window
   - The start of our current window
   - The maximum length found so far

---

## üîç Pattern Recognition: The Sliding Window

This is a **classic Sliding Window problem**! Here's why:

### ü™ü What is the Sliding Window Pattern?

Think of it like looking through a window that can:
- **Expand:** Add elements on the right
- **Shrink:** Remove elements from the left
- **Slide:** Move across the data structure

### When to Use Sliding Window?

‚úÖ **Use when you need to find:**
- Contiguous subarrays/substrings with a specific property
- Maximum/minimum values in windows
- Problems with "consecutive elements" or "substring"

‚úÖ **Common indicators:**
- "Longest substring..."
- "Maximum sum of k consecutive elements..."
- "Minimum window that contains..."
- "Find all anagrams..."

### Visual Example:

```
String: "abcabcbb"

Step 1: [a]bcabcbb          ‚Üí window = {a}, length = 1
Step 2: [ab]cabcbb          ‚Üí window = {a,b}, length = 2
Step 3: [abc]abcbb          ‚Üí window = {a,b,c}, length = 3
Step 4: abc[a]bcbb          ‚Üí 'a' repeats! Shrink from left
        ‚Üë   ‚Üë
      left  right
Step 5: abc[ab]cbb          ‚Üí window = {a,b}, length = 2
Step 6: abc[abc]bb          ‚Üí window = {a,b,c}, length = 3
...and so on
```

---

## üìù High-Level Plan

### Approach: Sliding Window with Hash Set/Map

**Core Idea:**
1. Use two pointers: `left` and `right` (our window boundaries)
2. Keep a hash set/map to track characters in current window
3. Expand `right` pointer to grow window
4. When we find a duplicate, shrink from `left` until duplicate is removed
5. Track maximum window size throughout

**Pseudocode:**
```
Initialize:
    - left = 0
    - max_length = 0
    - seen = empty hash set or map

For right from 0 to end of string:
    While character at right is in seen:
        Remove character at left from seen
        Move left forward
    
    Add character at right to seen
    Update max_length = max(max_length, right - left + 1)

Return max_length
```

---

## üí° Progressive Hints

<details>
<summary><b>üí° Hint 1: What data structure tracks "seen" characters efficiently?</b></summary>

Think about:
- We need to check if a character exists ‚Üí O(1) lookup
- We need to add/remove characters ‚Üí O(1) operations
- **Answer:** Hash Set (for just checking existence) or Hash Map (if we need positions)

For this problem, a **Hash Set** works, but a **Hash Map (character ‚Üí index)** can make shrinking more efficient!

</details>

<details>
<summary><b>üí° Hint 2: How do we handle duplicate characters?</b></summary>

When we encounter a duplicate:

**Option 1 (Gradual Shrink):**
- Remove characters from left one by one until the duplicate is gone
- Example: "abc[a]" ‚Üí remove first 'a'

**Option 2 (Jump):**
- If we store indices, we can jump directly to the position after the duplicate
- Example: If 'a' was at index 0, jump left to index 1

Both work! Option 2 is slightly more efficient.

</details>

<details>
<summary><b>üí° Hint 3: What's the formula for window size?</b></summary>

If we have:
- `left` = start of window
- `right` = end of window

Then:
- **Window size = right - left + 1**

Example:
- Indices: [0,1,2,3,4]
- String:  "a b c d e"
- Window from 1 to 3 ("bcd") ‚Üí 3 - 1 + 1 = 3 characters ‚úì

</details>

---

## ‚úÖ Complete Solution

### Solution 1: Sliding Window with Hash Set (Gradual Shrink)

```python
def lengthOfLongestSubstring(s: str) -> int:
    """
    Find the length of the longest substring without repeating characters.
    
    Approach: Sliding window with hash set
    - Expand window by moving right pointer
    - Shrink window from left when duplicate found
    - Track maximum window size
    
    Time: O(n) - each character visited at most twice (once by right, once by left)
    Space: O(min(n, m)) where m is charset size (at most 26 for lowercase letters)
    """
    # Edge case: empty string
    if not s:
        return 0
    
    # Initialize sliding window components
    seen = set()          # Characters in current window
    left = 0              # Left boundary of window
    max_length = 0        # Maximum length found
    
    # Expand window with right pointer
    for right in range(len(s)):
        current_char = s[right]
        
        # Shrink window until no duplicates
        while current_char in seen:
            seen.remove(s[left])
            left += 1
        
        # Add current character to window
        seen.add(current_char)
        
        # Update maximum length
        window_size = right - left + 1
        max_length = max(max_length, window_size)
    
    return max_length


# Test cases
def test_solution():
    test_cases = [
        ("abcabcbb", 3),      # "abc"
        ("bbbbb", 1),         # "b"
        ("pwwkew", 3),        # "wke"
        ("", 0),              # empty string
        (" ", 1),             # single space
        ("au", 2),            # two unique chars
        ("dvdf", 3),          # "vdf"
        ("abcdefghij", 10),   # all unique
    ]
    
    for i, (s, expected) in enumerate(test_cases, 1):
        result = lengthOfLongestSubstring(s)
        status = "‚úì" if result == expected else "‚úó"
        print(f"Test {i}: {status} Input: '{s}' ‚Üí Output: {result}, Expected: {expected}")

test_solution()
```

### Solution 2: Sliding Window with Hash Map (Optimized Jump)

```python
def lengthOfLongestSubstring(s: str) -> int:
    """
    Optimized version using hash map to store character indices.
    
    Advantage: Can jump directly to the position after duplicate,
    instead of shrinking one character at a time.
    
    Time: O(n) - each character visited exactly once
    Space: O(min(n, m)) where m is charset size
    """
    # Map character to its most recent index
    char_index = {}
    max_length = 0
    left = 0
    
    for right in range(len(s)):
        current_char = s[right]
        
        # If character seen before and is in current window
        if current_char in char_index and char_index[current_char] >= left:
            # Jump left pointer to position after the duplicate
            left = char_index[current_char] + 1
        
        # Update character's index
        char_index[current_char] = right
        
        # Update maximum length
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

---

## üî¨ Step-by-Step Walkthrough

Let's trace through **"abcabcbb"** with Solution 1:

```
Initial State:
seen = {}, left = 0, max_length = 0

Step 1: right = 0, char = 'a'
‚îú‚îÄ 'a' not in seen
‚îú‚îÄ seen = {'a'}
‚îú‚îÄ window size = 0 - 0 + 1 = 1
‚îî‚îÄ max_length = 1
    Window: [a]bcabcbb

Step 2: right = 1, char = 'b'
‚îú‚îÄ 'b' not in seen
‚îú‚îÄ seen = {'a', 'b'}
‚îú‚îÄ window size = 1 - 0 + 1 = 2
‚îî‚îÄ max_length = 2
    Window: [ab]cabcbb

Step 3: right = 2, char = 'c'
‚îú‚îÄ 'c' not in seen
‚îú‚îÄ seen = {'a', 'b', 'c'}
‚îú‚îÄ window size = 2 - 0 + 1 = 3
‚îî‚îÄ max_length = 3
    Window: [abc]abcbb

Step 4: right = 3, char = 'a'
‚îú‚îÄ 'a' IS in seen (duplicate!)
‚îú‚îÄ While loop:
‚îÇ   ‚îú‚îÄ Remove s[0] = 'a', left = 1
‚îÇ   ‚îú‚îÄ seen = {'b', 'c'}
‚îÇ   ‚îî‚îÄ 'a' not in seen anymore, exit while
‚îú‚îÄ Add 'a' back: seen = {'b', 'c', 'a'}
‚îú‚îÄ window size = 3 - 1 + 1 = 3
‚îî‚îÄ max_length = 3 (no change)
    Window: a[bca]bcbb

Step 5: right = 4, char = 'b'
‚îú‚îÄ 'b' IS in seen (duplicate!)
‚îú‚îÄ While loop:
‚îÇ   ‚îú‚îÄ Remove s[1] = 'b', left = 2
‚îÇ   ‚îú‚îÄ seen = {'c', 'a'}
‚îÇ   ‚îî‚îÄ 'b' not in seen anymore, exit while
‚îú‚îÄ Add 'b' back: seen = {'c', 'a', 'b'}
‚îú‚îÄ window size = 4 - 2 + 1 = 3
‚îî‚îÄ max_length = 3
    Window: ab[cab]cbb

... Continue until end ...

Final Answer: 3
```

---

## ‚ö° Complexity Analysis

### Time Complexity: **O(n)**
- The `right` pointer visits each character once: O(n)
- The `left` pointer visits each character at most once: O(n)
- Each character is added and removed from set at most once
- **Total: O(n + n) = O(n)**

### Space Complexity: **O(min(n, m))**
- `n` = length of string
- `m` = size of character set
  - Lowercase English letters: m = 26
  - All ASCII: m = 128
  - Unicode: m = 256
- Hash set/map stores at most min(n, m) characters
- **Worst case: O(n)** when all characters are unique

---

## üé® Variations to Consider

### Variation 1: **Return the actual substring, not just length**
```python
def longestUniqueSubstring(s: str) -> str:
    seen = set()
    left = 0
    max_length = 0
    result_start = 0  # Track where max substring starts
    
    for right in range(len(s)):
        while s[right] in seen:
            seen.remove(s[left])
            left += 1
        
        seen.add(s[right])
        
        if right - left + 1 > max_length:
            max_length = right - left + 1
            result_start = left
    
    return s[result_start:result_start + max_length]
```

### Variation 2: **At most K distinct characters**
```python
def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int:
    """
    Find longest substring with at most k distinct characters.
    Example: s = "eceba", k = 2 ‚Üí answer is 3 ("ece")
    """
    from collections import defaultdict
    
    char_count = defaultdict(int)
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        char_count[s[right]] += 1
        
        # Shrink window if more than k distinct characters
        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1
        
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### Variation 3: **Exactly K distinct characters**
```python
def exactlyKDistinct(s: str, k: int) -> int:
    """
    Find longest substring with exactly k distinct characters.
    Trick: at_most_k(k) - at_most_k(k-1)
    """
    def at_most_k_distinct(k):
        # Similar to variation 2
        pass
    
    return at_most_k_distinct(k) - at_most_k_distinct(k - 1)
```

---

## ü§î Reflection Questions

1. **Why does the sliding window pattern work here?**
   <details>
   <summary>Answer</summary>
   
   Because we're looking for a contiguous substring with a specific property. Once we find a duplicate, all substrings starting before the first occurrence and including the duplicate are invalid. So we can safely "slide" our window forward without missing any valid solutions.
   
   </details>

2. **What if we used a fixed-size window?**
   <details>
   <summary>Answer</summary>
   
   Won't work! We don't know the answer in advance, so we can't fix the window size. We need a variable-size window that expands and shrinks based on the duplicate constraint.
   
   </details>

3. **Could we use two separate loops instead of while loop inside for loop?**
   <details>
   <summary>Answer</summary>
   
   No, because we need to shrink the window immediately when we find a duplicate. The while loop ensures we remove all necessary characters from the left before adding the current character.
   
   </details>

4. **What's the worst case scenario for this algorithm?**
   <details>
   <summary>Answer</summary>
   
   When all characters are unique (e.g., "abcdef"), we never shrink the window. Time is still O(n), but space is O(n) because we store all characters.
   
   </details>

---

## üéØ Practice Problems

Once you've mastered this problem, try these similar sliding window problems:

1. **[LeetCode 76] Minimum Window Substring** (Hard)
   - Pattern: Sliding window with character frequency
   - Find smallest substring containing all characters of another string

2. **[LeetCode 438] Find All Anagrams in a String** (Medium)
   - Pattern: Fixed-size sliding window with hash map
   - Find all anagram starting indices

3. **[LeetCode 567] Permutation in String** (Medium)
   - Pattern: Fixed-size sliding window
   - Check if string contains permutation of another string

4. **[LeetCode 340] Longest Substring with At Most K Distinct Characters** (Medium)
   - Pattern: Variable sliding window with constraint
   - Direct variation of this problem

---

## üí° Interview Tips

### What interviewers look for:

‚úÖ **Pattern Recognition:**
- "This is a sliding window problem because..."
- Explain why brute force O(n¬≤) won't work

‚úÖ **Edge Cases:**
- Empty string
- Single character
- All same characters
- All unique characters

‚úÖ **Optimization Discussion:**
- Compare hash set vs hash map approach
- Explain why O(n) is optimal (can't do better than reading the string once)

‚úÖ **Communication:**
- Walk through example before coding
- Explain your thought process while writing
- Test with edge cases at the end

### Common Mistakes to Avoid:

‚ùå Forgetting to handle empty string  
‚ùå Using wrong window size formula (right - left vs right - left + 1)  
‚ùå Not removing from hash set when shrinking  
‚ùå Checking `left < right` (not needed with proper logic)  
‚ùå Returning `max_length - 1` (off-by-one error)

---

## üèÜ Key Takeaways

1. **Sliding Window is powerful for substring/subarray problems**
2. **Hash Set for existence checks, Hash Map for index tracking**
3. **Two pointers (left/right) create a flexible window**
4. **Time complexity: O(n) despite nested loops (amortized analysis)**
5. **Space complexity bounded by character set size, not input size**

---

**Ready to test yourself?** üöÄ  
Move on to **`6.Longest-Substring-Without-Repeating-Characters-Mock-Interview-Mode.md`** for a timed challenge!

**Pattern Mastery Progress:** üî•  
Session 1: Hash Map ‚úì | Linked List ‚úì | Stack ‚úì | Greedy ‚úì | Two Pointers ‚úì  
**Session 2: Sliding Window ‚Üê YOU ARE HERE** | Binary Search | BFS/DFS | Array/Prefix | BST

---

*Happy Coding! üíª‚ú®*
