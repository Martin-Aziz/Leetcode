# üéØ Problem 10: Lowest Common Ancestor of a Binary Search Tree

**Difficulty:** üü° Medium  
**Pattern:** Binary Search Tree (BST) Traversal  
**Time Limit:** 20 minutes  
**LeetCode Link:** [#235 Lowest Common Ancestor of a BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

---

## üìã Problem Statement

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA: "The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**)."

### Examples:

**Example 1:**
```
        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5

Input: root = [6,2,8,0,4,7,9,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

**Example 2:**
```
Input: root = [6,2,8,0,4,7,9,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself.
```

**Example 3:**
```
Input: root = [2,1], p = 2, q = 1
Output: 2
```

### Constraints:
- The number of nodes in the tree is in the range `[2, 10^5]`
- `-10^9 <= Node.val <= 10^9`
- All `Node.val` are **unique**
- `p != q`
- `p` and `q` will exist in the BST

---

## üéì Understanding the Problem

### What is a Lowest Common Ancestor (LCA)?

The **LCA** of two nodes is the deepest node that is an ancestor of both.

**Key Rules:**
1. A node can be an ancestor of itself
2. We want the LOWEST (deepest) such node
3. Both nodes are guaranteed to exist in the tree

### Visual Understanding:

```
        6 ‚Üê Root
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5

LCA(2, 8) = 6  (6 is ancestor of both)
LCA(2, 4) = 2  (2 is ancestor of itself and 4)
LCA(0, 5) = 2  (2 is lowest common ancestor)
LCA(7, 9) = 8  (8 is lowest common ancestor)
```

---

## üîç Pattern Recognition: BST Properties

This problem leverages **BST properties**!

### üå≥ BST Property Review:

For every node in a BST:
- **Left subtree:** All values < node.val
- **Right subtree:** All values > node.val

### üí° Key Insight:

Given two nodes `p` and `q` in a BST:

**Case 1:** Both in left subtree
```
    current > p.val AND current > q.val
    ‚Üí LCA is in left subtree
```

**Case 2:** Both in right subtree
```
    current < p.val AND current < q.val
    ‚Üí LCA is in right subtree
```

**Case 3:** Split (one left, one right)
```
    current is between p and q
    ‚Üí current IS the LCA!
```

### Decision Tree:

```
         current
        /   |   \
       /    |    \
   p,q‚Üê    p|q   ‚Üíp,q
   left   here   right
     ‚Üì      ‚Üì      ‚Üì
  go left  LCA!  go right
```

---

## üìù High-Level Plan

### Approach: Leveraging BST Properties

**Core Idea:**
1. Start at root
2. Compare current node's value with p and q
3. If both p and q are smaller ‚Üí go left
4. If both p and q are larger ‚Üí go right
5. Otherwise ‚Üí current node is LCA!

**Pseudocode:**
```
current = root

While current exists:
    If both p and q < current:
        current = current.left
    Elif both p and q > current:
        current = current.right
    Else:
        return current  # Found LCA!
```

---

## üí° Progressive Hints

<details>
<summary><b>üí° Hint 1: Why is this easier in a BST than a regular tree?</b></summary>

In a **BST**, we can determine which subtree contains a node just by comparing values!

- Regular tree: Might need to search both subtrees
- BST: Can decide direction immediately based on value comparison

This reduces complexity from O(n) with potentially checking all nodes to O(h) where h is height!

</details>

<details>
<summary><b>üí° Hint 2: When have we found the LCA?</b></summary>

The LCA is found when the path splits:

```python
if (p.val <= current.val <= q.val) or (q.val <= current.val <= p.val):
    # current is between p and q ‚Üí it's the LCA!
    return current
```

Or more simply:
```python
if (p.val < current.val and q.val > current.val) or \
   (p.val > current.val and q.val < current.val) or \
   (current.val == p.val) or (current.val == q.val):
    return current
```

</details>

<details>
<summary><b>üí° Hint 3: Recursive vs Iterative?</b></summary>

**Both work!**

**Iterative (Recommended):**
```python
while root:
    if p.val < root.val and q.val < root.val:
        root = root.left
    elif p.val > root.val and q.val > root.val:
        root = root.right
    else:
        return root
```

**Recursive:**
```python
if p.val < root.val and q.val < root.val:
    return lowestCommonAncestor(root.left, p, q)
elif p.val > root.val and q.val > root.val:
    return lowestCommonAncestor(root.right, p, q)
else:
    return root
```

Iterative is simpler and uses O(1) space!

</details>

---

## ‚úÖ Complete Solution

```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Find LCA in BST using iterative approach.
    
    Approach:
    - Use BST property to navigate
    - If both nodes smaller than current ‚Üí go left
    - If both nodes larger than current ‚Üí go right
    - Otherwise ‚Üí current is LCA (path splits here)
    
    Time: O(h) where h is height (O(log n) balanced, O(n) skewed)
    Space: O(1) - no extra space needed
    """
    current = root
    
    while current:
        # Both p and q in left subtree
        if p.val < current.val and q.val < current.val:
            current = current.left
        
        # Both p and q in right subtree
        elif p.val > current.val and q.val > current.val:
            current = current.right
        
        # Split: p and q are in different subtrees
        # OR current is p or q itself
        else:
            return current
    
    return None  # Should never reach here given constraints


# Recursive solution (also valid)
def lowestCommonAncestor_recursive(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Recursive approach using BST properties.
    
    Time: O(h)
    Space: O(h) - recursion stack
    """
    # Both in left subtree
    if p.val < root.val and q.val < root.val:
        return lowestCommonAncestor_recursive(root.left, p, q)
    
    # Both in right subtree
    elif p.val > root.val and q.val > root.val:
        return lowestCommonAncestor_recursive(root.right, p, q)
    
    # Split or current is one of the nodes
    else:
        return root


# Test helper
def build_tree():
    """Build example tree:
            6
           / \
          2   8
         / \ / \
        0  4 7  9
          / \
         3   5
    """
    root = TreeNode(6)
    root.left = TreeNode(2)
    root.right = TreeNode(8)
    root.left.left = TreeNode(0)
    root.left.right = TreeNode(4)
    root.right.left = TreeNode(7)
    root.right.right = TreeNode(9)
    root.left.right.left = TreeNode(3)
    root.left.right.right = TreeNode(5)
    return root


# Test cases
def test_solution():
    root = build_tree()
    
    # Test 1: LCA(2, 8) = 6
    assert lowestCommonAncestor(root, root.left, root.right).val == 6
    
    # Test 2: LCA(2, 4) = 2
    assert lowestCommonAncestor(root, root.left, root.left.right).val == 2
    
    # Test 3: LCA(0, 5) = 2
    assert lowestCommonAncestor(root, root.left.left, root.left.right.right).val == 2
    
    print("‚úÖ All tests passed!")

test_solution()
```

---

## üî¨ Step-by-Step Walkthrough

Let's find **LCA(0, 5)** in this tree:

```
        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5

p = 0, q = 5
```

**Trace:**

```
Step 1: current = 6
‚îú‚îÄ p.val = 0, q.val = 5
‚îú‚îÄ 0 < 6? YES
‚îú‚îÄ 5 < 6? YES
‚îî‚îÄ Both in left subtree ‚Üí go left

Step 2: current = 2
‚îú‚îÄ p.val = 0, q.val = 5
‚îú‚îÄ 0 < 2? YES
‚îú‚îÄ 5 < 2? NO
‚îî‚îÄ Split! One on left (0), one on right (5)
    ‚Üí current (2) is LCA!

Return: 2 ‚úì
```

**Why is 2 the LCA?**
- 2 is an ancestor of 0 (0 is in left subtree of 2)
- 2 is an ancestor of 5 (5 is in right subtree of 2)
- 2 is the LOWEST such node (can't go deeper)

---

## ‚ö° Complexity Analysis

### Time Complexity: **O(h)**
- h = height of tree
- **Balanced BST:** O(log n)
- **Skewed BST:** O(n)
- We traverse at most one path from root to a node

### Space Complexity:
- **Iterative:** O(1) - only pointers
- **Recursive:** O(h) - recursion stack

---

## ü§î Reflection Questions

1. **What if this was a regular binary tree, not BST?**
   <details>
   <summary>Answer</summary>
   
   Would need to search both subtrees, can't decide direction by value comparison. Complexity becomes O(n) instead of O(h). See LeetCode #236.
   
   </details>

2. **What if p or q doesn't exist in the tree?**
   <details>
   <summary>Answer</summary>
   
   Problem guarantees they exist. But if they might not exist, we'd need to verify by searching the tree first.
   
   </details>

3. **Can the LCA be p or q itself?**
   <details>
   <summary>Answer</summary>
   
   Yes! Example: LCA(2, 4) = 2. A node is an ancestor of itself.
   
   </details>

---

## üéØ Practice Problems

1. **[LeetCode 236] Lowest Common Ancestor of a Binary Tree** (Medium)
   - Same problem but regular tree (not BST)

2. **[LeetCode 1644] LCA of Binary Tree II** (Medium)
   - Nodes might not exist

3. **[LeetCode 1650] LCA of Binary Tree III** (Medium)
   - With parent pointers

4. **[LeetCode 1123] LCA of Deepest Leaves** (Medium)
   - Find LCA of deepest nodes

---

## üí° Interview Tips

‚úÖ **Emphasize BST property:**
- "Since it's a BST, I can use value comparison"
- "This makes it O(h) instead of O(n)"

‚úÖ **Explain the split concept:**
- "When paths diverge, that's our LCA"
- "If both go same direction, keep going"

‚úÖ **Consider edge cases:**
- One node is ancestor of other
- Both nodes in same subtree

‚ùå **Common Mistakes:**
- Forgetting node can be ancestor of itself
- Using O(n) solution when BST property enables O(h)
- Not handling case where current node is p or q

---

## üèÜ Key Takeaways

1. **BST property enables efficient navigation**
2. **LCA is where paths to p and q diverge**
3. **Iterative solution is simpler and more efficient**
4. **O(h) time, O(1) space is optimal**
5. **Node can be ancestor of itself**

---

**Ready to test yourself?** üöÄ  
Move on to **`10.Lowest-Common-Ancestor-of-BST-Mock-Interview-Mode.md`**

**üéä Session 2 Complete!**  
Session 2: Sliding Window ‚úì | Binary Search ‚úì | BFS/DFS ‚úì | Array/Prefix ‚úì | **BST ‚úì**

*Happy Coding! üíª‚ú®*
