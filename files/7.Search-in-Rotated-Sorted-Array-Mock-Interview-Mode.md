# ⏱️ MOCK INTERVIEW: Search in Rotated Sorted Array

**Difficulty:** 🟡 Medium  
**Pattern:** Binary Search (Modified)  
**Time Limit:** ⏰ **25 minutes**  
**Points:** 100

---

## 🎯 Interview Simulation

You are in a real technical interview. The interviewer has just asked you this question. You have **25 minutes** to:
1. Clarify the problem (2-3 minutes)
2. Discuss your approach (3-5 minutes)
3. Write working code (12-15 minutes)
4. Test your solution (3-5 minutes)

**Start your timer NOW!** ⏰

---

## 📋 Problem Statement

There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **rotated** at an unknown pivot index. For example, `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`.

Given the rotated array `nums` and an integer `target`, return the **index** of `target` if it is in `nums`, or `-1` if it is not.

**You must write an algorithm with O(log n) runtime complexity.**

### Examples:

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

Input: nums = [1], target = 0
Output: -1
```

### Constraints:
- `1 <= nums.length <= 5000`
- `-10^4 <= nums[i] <= 10^4`
- All values of `nums` are **unique**
- `nums` is guaranteed to be rotated
- `-10^4 <= target <= 10^4`

---

## ❓ Clarifying Questions (Ask These!)

Before coding, ask:

1. **"When you say O(log n) is required, that rules out linear search, correct?"**
   - Yes, must be logarithmic

2. **"Are all values guaranteed to be unique?"**
   - Yes, no duplicates

3. **"Can the array be rotated at index 0 (i.e., not rotated at all)?"**
   - Yes, that's a valid case

4. **"Should I return the index or the value?"**
   - Return the index, or -1 if not found

5. **"What should I return if the array is empty?"**
   - Array is guaranteed to have at least 1 element

---

## 💭 Think Out Loud (Required!)

During the interview, you MUST verbalize:

### 1. Initial Observations
```
"I see the O(log n) requirement, which immediately suggests binary search.
The challenge is that the array is rotated, so it's not fully sorted.
However, I notice that when rotated, at least one half must still be sorted..."
```

### 2. Approach Discussion
```
"I'll use a modified binary search. At each step, I'll:
1. Find the midpoint
2. Check if it's the target
3. Determine which half is sorted by comparing nums[left] with nums[mid]
4. Check if target is within the sorted half's range
5. Adjust my search boundaries accordingly..."
```

### 3. Complexity Analysis
```
"This will be O(log n) time because we're eliminating half the search space
at each step, just like standard binary search. Space is O(1) since we're
only using pointers..."
```

---

## 💡 Optional Hints (Use Sparingly!)

<details>
<summary>🆘 Hint 1: What does O(log n) tell you? (−5 points)</summary>

**O(log n) = Binary Search!**

But you need to modify it for the rotated array. Key insight: At any midpoint, **at least one half of the array is properly sorted**. Use this to guide your search direction.

</details>

<details>
<summary>🆘 Hint 2: How to determine which half is sorted? (−10 points)</summary>

Compare `nums[left]` with `nums[mid]`:

```python
if nums[left] <= nums[mid]:
    # Left half is sorted
else:
    # Right half is sorted
```

Once you know which half is sorted, check if the target is within that sorted range.

</details>

<details>
<summary>🆘 Hint 3: How to check if target is in the sorted half? (−15 points)</summary>

If left half is sorted:
```python
if nums[left] <= target < nums[mid]:
    # Target is in left half
    right = mid - 1
else:
    # Target is in right half
    left = mid + 1
```

If right half is sorted:
```python
if nums[mid] < target <= nums[right]:
    # Target is in right half
    left = mid + 1
else:
    # Target is in left half
    right = mid - 1
```

</details>

---

## 🧑‍💻 Your Solution Space

Write your solution here:

```python
def search(nums: list[int], target: int) -> int:
    """
    Search for target in a rotated sorted array.
    
    Args:
        nums: Rotated sorted array with unique values
        target: Value to search for
        
    Returns:
        Index of target, or -1 if not found
    """
    # Your code here
    pass


# Test your solution
if __name__ == "__main__":
    # Basic test cases
    assert search([4,5,6,7,0,1,2], 0) == 4
    assert search([4,5,6,7,0,1,2], 3) == -1
    assert search([1], 0) == -1
    assert search([1], 1) == 0
    
    # Edge cases
    assert search([1,3], 3) == 1
    assert search([3,1], 1) == 1
    assert search([5,1,3], 5) == 0
    assert search([4,5,6,7,8,1,2,3], 8) == 4
    
    print("✅ All tests passed!")
```

---

## ⏰ Time Check!

- ⏱️ **5 min:** Should have discussed approach and identified binary search
- ⏱️ **15 min:** Should have working solution
- ⏱️ **20 min:** Should be testing edge cases
- ⏱️ **25 min:** TIME'S UP!

---

## ✅ Optimal Solution (Don't Look Until After!)

<details>
<summary><b>🔍 Click to Reveal Optimal Solution</b></summary>

```python
def search(nums: list[int], target: int) -> int:
    """
    Modified binary search for rotated sorted array.
    
    Key insight: At any midpoint, at least one half is sorted.
    Determine which half is sorted, check if target is in range,
    then adjust search boundaries.
    
    Time: O(log n) - Binary search eliminates half each step
    Space: O(1) - Only using pointers
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Found it!
        if nums[mid] == target:
            return mid
        
        # Determine which half is sorted
        if nums[left] <= nums[mid]:
            # Left half is sorted: [left...mid]
            
            # Is target in left half's range?
            if nums[left] <= target < nums[mid]:
                # Search left half
                right = mid - 1
            else:
                # Search right half
                left = mid + 1
        
        else:
            # Right half is sorted: [mid...right]
            
            # Is target in right half's range?
            if nums[mid] < target <= nums[right]:
                # Search right half
                left = mid + 1
            else:
                # Search left half
                right = mid - 1
    
    # Not found
    return -1


# Comprehensive test cases
def test_solution():
    test_cases = [
        ([4,5,6,7,0,1,2], 0, 4),
        ([4,5,6,7,0,1,2], 3, -1),
        ([1], 0, -1),
        ([1], 1, 0),
        ([1,3], 3, 1),
        ([3,1], 1, 1),
        ([5,1,3], 5, 0),
        ([4,5,6,7,8,1,2,3], 8, 4),
        ([6,7,1,2,3,4,5], 6, 0),
        ([2,3,4,5,6,7,1], 1, 6),
    ]
    
    for nums, target, expected in test_cases:
        result = search(nums, target)
        assert result == expected, f"Failed: nums={nums}, target={target}, got {result}, expected {expected}"
    
    print("✅ All tests passed!")

test_solution()
```

### Alternative: Recursive Approach

```python
def search_recursive(nums: list[int], target: int) -> int:
    """
    Recursive version of binary search in rotated array.
    
    Time: O(log n)
    Space: O(log n) - recursion stack
    """
    def binary_search(left: int, right: int) -> int:
        if left > right:
            return -1
        
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        
        # Left half sorted
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                return binary_search(left, mid - 1)
            else:
                return binary_search(mid + 1, right)
        
        # Right half sorted
        else:
            if nums[mid] < target <= nums[right]:
                return binary_search(mid + 1, right)
            else:
                return binary_search(left, mid - 1)
    
    return binary_search(0, len(nums) - 1)
```

### Why This Is Optimal:

1. **Time: O(log n)** - Can't do better for search without reading entire array
2. **Space: O(1)** - Iterative uses constant space (recursive uses O(log n))
3. **Single pass** - Don't need to find pivot first
4. **No sorting** - Don't modify input

</details>

---

## 🎯 Grading Rubric (100 Points Total)

### 1️⃣ Correctness (40 points)

| Criteria | Points | Your Score |
|----------|--------|------------|
| Handles all basic test cases | 15 | ___ |
| Correctly handles single element | 5 | ___ |
| Finds target at boundaries (first/last) | 5 | ___ |
| Returns -1 when target not found | 5 | ___ |
| Handles non-rotated array (pivot=0) | 5 | ___ |
| Handles target at pivot point | 5 | ___ |

### 2️⃣ Time Complexity (25 points)

| Criteria | Points | Your Score |
|----------|--------|------------|
| Achieves O(log n) solution | 20 | ___ |
| Correctly explains why O(log n) | 5 | ___ |
| **Penalty:** O(n) linear search | -20 | ___ |

### 3️⃣ Space Complexity (10 points)

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses O(1) space (iterative) | 8 | ___ |
| Correctly identifies space usage | 2 | ___ |
| **Penalty:** O(n) extra space | -5 | ___ |

### 4️⃣ Code Quality (15 points)

| Criteria | Points | Your Score |
|----------|--------|------------|
| Clean variable names (left, right, mid) | 4 | ___ |
| Proper loop structure (while left <= right) | 4 | ___ |
| Correct comparison logic (<= vs <) | 4 | ___ |
| Clear comments on key logic | 3 | ___ |

### 5️⃣ Communication & Process (10 points)

| Criteria | Points | Your Score |
|----------|--------|------------|
| Asked clarifying questions | 3 | ___ |
| Explained binary search approach | 3 | ___ |
| Walked through an example | 2 | ___ |
| Tested with edge cases | 2 | ___ |

---

## 📊 Bonus Points & Penalties

### 🌟 Bonus (Up to +15)

- **+10:** Provided both iterative and recursive solutions
- **+5:** Drew diagram explaining rotation concept
- **+5:** Discussed variations (find min, with duplicates)
- **+3:** Explained why one half must be sorted

### ⚠️ Penalties

- **−5:** Used one hint
- **−10:** Used two hints
- **−15:** Used all three hints
- **−20:** Solution doesn't compile/run
- **−30:** Solution gives incorrect results
- **−10:** Overtime (more than 25 minutes)
- **−5:** Used wrong comparison (< instead of <=)
- **−10:** Off-by-one error in indices

---

## 🎭 Detailed Feedback

### ⭐ Excellent Performance (90-100)
Outstanding! You demonstrated mastery of binary search modifications and handled the rotation elegantly. Your solution is optimal, well-communicated, and you covered edge cases. This is **HIRE** level performance!

**Key Strengths:**
- Immediately recognized O(log n) → binary search
- Correctly identified sorted half at each step
- Clean implementation with proper comparisons
- Tested thoroughly

**Next Challenge:**
- Try finding minimum in rotated array
- Attempt with duplicates allowed
- Practice binary search on answer problems

---

### ✅ Strong Performance (75-89)
Great work! You understood the core concept and implemented a working O(log n) solution. Minor issues in code quality or edge cases, but you're on the right track.

**What Went Well:**
- Recognized binary search pattern
- Handled most test cases
- O(log n) time complexity

**Areas to Improve:**
- Be more careful with <= vs < comparisons
- Test more edge cases (single element, boundaries)
- Explain your logic more clearly during coding

**Practice:**
- Redo this problem focusing on comparison operators
- Review standard binary search template
- Try similar problems: LeetCode 153, 81

---

### ⚡ Needs Improvement (60-74)
You're making progress but need more practice with binary search modifications. Maybe you got the concept but struggled with implementation details.

**What to Focus On:**
- Study standard binary search first
- Understand why one half must be sorted
- Practice drawing out examples
- Work on comparison logic (<= vs <)

**Recommended Practice:**
1. Master standard binary search (LeetCode 704)
2. Review this teaching mode file
3. Practice easier binary search variants
4. Redo this problem in 2-3 days

---

### ❌ Significant Issues (<60)
This problem is challenging! If you attempted O(n) linear search or struggled with the logic, that's okay. Binary search modifications take practice.

**Action Plan:**
1. **Study fundamentals:**
   - Review standard binary search
   - Understand loop invariants (left <= right)
   - Practice mid calculation
   
2. **Build intuition:**
   - Draw the rotated array
   - Manually trace through examples
   - Understand the "one half sorted" property
   
3. **Practice progression:**
   - LeetCode 704: Binary Search (Easy)
   - LeetCode 35: Search Insert Position (Easy)
   - LeetCode 153: Find Minimum in Rotated Array (Medium)
   - Return to this problem
   
4. **Return in 1 week** after foundational practice

---

## 🗣️ Example Communication

### Strong Interview Communication:

> **Clarification:** "Just to confirm, the constraint says O(log n), so I can't do a simple linear scan, correct? I need to use binary search."
>
> **Approach:** "Okay, so this is a rotated sorted array. The key insight I'm noticing is that even though the whole array isn't sorted, **at least one half must be sorted** at any point I split it."
>
> "Here's my approach: I'll do a modified binary search. At each step:
> 1. Calculate the midpoint
> 2. Check if it's my target
> 3. Determine which half is sorted by comparing `nums[left]` with `nums[mid]`
> 4. If left is sorted, check if target is in that range
> 5. Otherwise, check the right half
> 6. Adjust my boundaries accordingly"
>
> **Complexity:** "This will be O(log n) time because we're doing binary search - eliminating half the array at each step. Space is O(1) with an iterative approach."
>
> **During Coding:** "Let me make sure I use `<=` here because if `nums[left]` equals `nums[mid]`, the left half is trivially sorted..."
>
> **Testing:** "Let me trace through [4,5,6,7,0,1,2], target=0:
> - First iteration: mid=7, left half [4,5,6,7] is sorted, 0 not in range, go right
> - Second iteration: mid=1, left half [0,1] is sorted, 0 is in range, go left
> - Third iteration: mid=0, found it!"
>
> **Edge Cases:** "I should also test: single element, target not found, target at boundaries..."

---

## 🎯 Key Takeaways

### ✅ What Makes This Solution Strong:

1. **O(log n) complexity** - Required by problem constraints
2. **Modified binary search** - Adapted for rotation
3. **Correct comparisons** - `<=` vs `<` in the right places
4. **Single pass** - Don't need to find pivot first
5. **O(1) space** - No extra data structures

### ❌ Common Mistakes:

1. **Linear search O(n)** - Doesn't meet constraint
2. **Wrong comparison** - Using `<` instead of `<=` in `nums[left] <= nums[mid]`
3. **Range check errors** - Wrong target range comparison
4. **Off-by-one** - Using `mid` instead of `mid ± 1`
5. **Loop condition** - Using `left < right` instead of `left <= right`

### 🔑 Critical Concepts:

1. **O(log n) means binary search**
2. **One half is always sorted in rotated array**
3. **Compare boundaries to identify sorted half**
4. **Check if target is in sorted half's range**
5. **Adjust search space based on where target could be**

---

## 📈 Your Performance Summary

**Fill this out after completing the mock interview:**

| Metric | Your Result |
|--------|-------------|
| **Total Score** | ___/100 |
| **Time Taken** | ___ min |
| **Hints Used** | ___ |
| **Test Cases Passed** | ___/10 |
| **Interview Ready?** | Yes / No |

**Key Strengths:**
- ___________________________
- ___________________________

**Areas to Improve:**
- ___________________________
- ___________________________

**Next Steps:**
- ___________________________

---

## 🎓 Pattern Mastery Tracker

After this problem, you should understand:

- ✅ Binary search fundamentals
- ✅ Modifying binary search for special cases
- ✅ Rotated array properties
- ✅ Identifying sorted vs unsorted sections
- ✅ Range checking in bounded intervals

**Confidence Level (Rate 1-5):**
- Binary Search: ___/5
- Modified Binary Search: ___/5
- Rotated Array Problems: ___/5

---

## 🚀 Next Challenge

Ready for graph traversal?

**Continue to:** `8.Number-of-Islands-Teaching-Mode.md`

**Or strengthen binary search:**
- [LeetCode 153] Find Minimum in Rotated Sorted Array
- [LeetCode 81] Search in Rotated Sorted Array II (with duplicates)
- [LeetCode 162] Find Peak Element

---

**Good luck! Remember: Binary search is about eliminating what you know is impossible!** 🎯✨

---

*"The difference between O(n) and O(log n) is the difference between checking 1,000,000 elements and checking 20."* 🚀
