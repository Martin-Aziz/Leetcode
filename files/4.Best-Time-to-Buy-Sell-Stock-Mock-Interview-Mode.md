# ğŸ¤ Best Time to Buy and Sell Stock - Mock Interview Mode

> **Difficulty:** ğŸŸ¢ Easy  
> **Time Limit:** â±ï¸ 20 minutes  
> **Problem Link:** [LeetCode #121](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)  
> **Mock Interview:** Problem 4 of 5

---

## âš¡ Interview Rules

- â±ï¸ You have **20 minutes** to solve this problem
- ğŸ’¡ You may request **up to 2 hints** (score penalty applies)
- ğŸ¯ Focus on: Correctness, Efficiency, Code Quality, Edge Cases
- ğŸ—£ï¸ Explain your optimization approach
- âœï¸ Avoid brute force O(nÂ²) solution

**Start your timer now!** â°

---

## ğŸ§© Problem Statement

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

Return the **maximum profit** you can achieve from this transaction. If you cannot achieve any profit, return `0`.

---

## ğŸ“ Examples

**Example 1:**
```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

**Example 2:**
```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
```

---

## ğŸ” Constraints

- `1 <= prices.length <= 10âµ`
- `0 <= prices[i] <= 10â´`

---

## ğŸ’­ Your Solution Space

### ğŸ¯ Clarifying Questions to Consider:
- Can prices be negative? (No, all non-negative)
- Must I buy before I sell? (Yes, buy day < sell day)
- What if I can't make profit? (Return 0)

<details>
<summary><b>ğŸ†˜ Hint 1</b> (Click only if needed - Minor score penalty)</summary>

For each price, ask yourself: "What's the best price I could have bought at **so far**?"

Keep track of the **minimum price seen** up to the current position. Then calculate what profit you'd make if you sold today.

Avoid nested loopsâ€”you can solve this in O(n) with a single pass!

</details>

<details>
<summary><b>ğŸ†˜ Hint 2</b> (Click only if needed - Moderate score penalty)</summary>

**Algorithm:**

```python
min_price = float('inf')
max_profit = 0

for price in prices:
    # Update minimum price seen so far
    min_price = min(min_price, price)
    
    # Calculate profit if we sell today
    profit = price - min_price
    
    # Update maximum profit
    max_profit = max(max_profit, profit)

return max_profit
```

The key insight: You only need to track two values as you iterate!

</details>

---

## âœï¸ Write Your Solution Below

```python
def maxProfit(prices):
    """
    Find maximum profit from single buy-sell transaction.
    
    Args:
        prices: List[int] - Array of daily stock prices
    
    Returns:
        int - Maximum profit achievable, 0 if none possible
    """
    # TODO: Implement your solution
    pass


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Test your solution
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if __name__ == "__main__":
    # Test Case 1: Normal case with profit
    print(maxProfit([7, 1, 5, 3, 6, 4]))  # Expected: 5
    
    # Test Case 2: Decreasing prices
    print(maxProfit([7, 6, 4, 3, 1]))     # Expected: 0
    
    # Test Case 3: Increasing prices
    print(maxProfit([1, 2, 3, 4, 5]))     # Expected: 4
    
    # Test Case 4: Single price
    print(maxProfit([5]))                  # Expected: 0
    
    # Test Case 5: Two prices
    print(maxProfit([2, 4]))               # Expected: 2
    
    # Test Case 6: All same
    print(maxProfit([3, 3, 3, 3]))        # Expected: 0
```

---

## â¸ï¸ Time's Up! Submit Your Solution

Once you've completed your solution (or time has expired), scroll down to see the evaluation.

<br><br><br><br><br>

---

# ğŸ“Š Interview Evaluation & Feedback

---

## âœ… Optimal Solution

```python
# Time Complexity: O(n) - Single pass through array
# Space Complexity: O(1) - Only two variables

def maxProfit(prices):
    """
    Find maximum profit from single buy-sell stock transaction.
    
    Strategy: Track the minimum price seen so far (best buy point)
    and calculate profit for each day as if we sell that day.
    
    Args:
        prices: List of daily stock prices
    
    Returns:
        int: Maximum profit achievable, 0 if no profit possible
    """
    # Handle edge case
    if not prices or len(prices) < 2:
        return 0
    
    # Track minimum price seen so far (best buy opportunity)
    min_price = float('inf')
    
    # Track maximum profit achievable
    max_profit = 0
    
    # Single pass through prices
    for price in prices:
        # Update minimum price (could be today's price)
        min_price = min(min_price, price)
        
        # Calculate profit if we sell today
        profit = price - min_price
        
        # Update maximum profit seen
        max_profit = max(max_profit, profit)
    
    return max_profit


# âœ… Alternative Implementation (More Explicit)
def maxProfit_v2(prices):
    """Alternative: Start with first price as minimum."""
    if len(prices) < 2:
        return 0
    
    min_price = prices[0]
    max_profit = 0
    
    for i in range(1, len(prices)):
        # Calculate profit if selling today
        profit = prices[i] - min_price
        max_profit = max(max_profit, profit)
        
        # Update minimum for future calculations
        min_price = min(min_price, prices[i])
    
    return max_profit


# âœ… Comprehensive Test Suite
def test_solution():
    test_cases = [
        ([7, 1, 5, 3, 6, 4], 5, "Buy at 1, sell at 6"),
        ([7, 6, 4, 3, 1], 0, "Decreasing prices - no profit"),
        ([1, 2, 3, 4, 5], 4, "Increasing prices - max profit"),
        ([5], 0, "Single price - can't trade"),
        ([2, 4], 2, "Two prices - simple profit"),
        ([4, 2], 0, "Two prices decreasing"),
        ([3, 3, 3, 3], 0, "All same prices"),
        ([2, 1, 2, 1, 0, 1, 2], 2, "Multiple valleys"),
        ([3, 2, 6, 5, 0, 3], 4, "Buy at 2, sell at 6"),
    ]
    
    for prices, expected, description in test_cases:
        result = maxProfit(prices)
        status = "âœ…" if result == expected else "âŒ"
        print(f"{status} {description}: {prices} â†’ {result} (expected {expected})")

test_solution()
```

---

## ğŸ¯ Grading Rubric (Score: __/100)

### âœ… **Correctness (40 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Returns correct profit for normal cases | 12 | __ |
| Handles decreasing prices (returns 0) | 10 | __ |
| Handles edge cases (single price, empty) | 8 | __ |
| Maintains buy-before-sell constraint | 5 | __ |
| Returns 0 for no profit scenarios | 5 | __ |

**Subtotal:** __/40

**Common Mistakes:**
- âŒ Allowing sell before buy â†’ **-10 points**
- âŒ Not handling decreasing prices â†’ **-10 points**
- âŒ Wrong calculation when minimum is at end â†’ **-8 points**

---

### âš™ï¸ **Time Complexity (20 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Achieves O(n) single-pass solution | 15 | __ |
| Correctly analyzes time complexity | 3 | __ |
| Explained optimization over brute force | 2 | __ |

**Subtotal:** __/20

**Critical Issues:**
- âŒ Using nested loops O(nÂ²) â†’ **-15 points** (Major penalty!)
- âŒ Multiple passes through array â†’ **-8 points**
- âŒ Sorting the array â†’ **-12 points** (loses position info)

---

### ğŸ’¾ **Space Complexity (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses O(1) constant space | 12 | __ |
| No unnecessary arrays/lists | 2 | __ |
| Correctly analyzes space | 1 | __ |

**Subtotal:** __/15

---

### âœï¸ **Code Clarity & Style (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Clear variable names (min_price, max_profit) | 4 | __ |
| Proper comments explaining logic | 3 | __ |
| Clean code structure | 3 | __ |
| Handles edge cases gracefully | 3 | __ |
| Pythonic code style | 2 | __ |

**Subtotal:** __/15

**Best Practices:**
- âœ… Use `min_price` not `mn` or `m`
- âœ… Use `max_profit` not `ans` or `res`
- âœ… Comment the key insight about tracking minimum

---

### ğŸ§ª **Tests & Edge Cases (10 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Tests normal profit case | 2 | __ |
| Tests decreasing prices (no profit) | 3 | __ |
| Tests edge: single price or two prices | 3 | __ |
| Tests multiple valleys and peaks | 2 | __ |

**Subtotal:** __/10

**Critical Edge Cases:**
- âœ… `[7,6,5,4,3,2,1]` â†’ `0`
- âœ… `[1,2,3,4,5]` â†’ `4`
- âœ… `[5]` â†’ `0`
- âœ… `[3,2,6,5,0,3]` â†’ `4` (not fooled by later minimum)

---

## ğŸ“ˆ **Bonus/Penalties**

| Item | Points | Your Score |
|------|--------|------------|
| âœ… Solved within time limit (20 min) | +5 | __ |
| âœ… No hints used | +5 | __ |
| âœ… Explained "track minimum" insight | +3 | __ |
| âœ… Drew visualization/example | +2 | __ |
| âœ… Mentioned brute force first, then optimized | +2 | __ |
| âŒ Used Hint 1 | -3 | __ |
| âŒ Used Hint 2 | -5 | __ |
| âŒ Exceeded time limit | -5 | __ |
| âŒ Used O(nÂ²) brute force | -10 | __ |

**Bonus/Penalties:** __

---

## ğŸ† **Final Score: __/100**

### Score Interpretation

| Range | Performance | Feedback |
|-------|-------------|----------|
| **90-100** | ğŸŒŸ Excellent | Perfect! You nailed the O(n) optimization. |
| **75-89** | ğŸ‘ Good | Solid solution. Minor style or edge case issues. |
| **60-74** | ğŸ¤” Fair | Got the idea but suboptimal or missed edge cases. |
| **Below 60** | ğŸ“š Needs Work | Review greedy algorithms and single-pass patterns. |

---

## ğŸ’¬ Detailed Feedback

### âœ… What You Did Well
- [ ] Recognized single-pass optimization immediately
- [ ] Tracked minimum price correctly
- [ ] Handled all edge cases properly
- [ ] Wrote clean, readable code
- [ ] Explained the optimization strategy clearly

### ğŸ”§ Areas for Improvement
- [ ] **Optimization:** Should aim for O(n), not O(nÂ²)
- [ ] **Edge Cases:** Test with decreasing prices, single element
- [ ] **Explanation:** Should mention tracking minimum price as key insight
- [ ] **Code Style:** Use descriptive variable names
- [ ] **Testing:** Always test edge cases before submitting

---

## ğŸ¯ Actionable Next Steps

Based on your performance:

### 1ï¸âƒ£ **If you used O(nÂ²) brute force:**
   - **Study:** Greedy algorithms and optimization techniques
   - **Practice:** Maximum Subarray (LC #53) - Similar pattern
   - **Focus:** How to eliminate nested loops by tracking state

### 2ï¸âƒ£ **If you missed edge cases:**
   - **Exercise:** Before coding, list 5 edge cases:
     1. Decreasing prices
     2. Single price
     3. All same prices
     4. Two prices
     5. Minimum at end
   - **Practice:** Always test edge cases

### 3ï¸âƒ£ **If code clarity was an issue:**
   - **Review:** Clean Code principles
   - **Practice:** Rewrite with better variable names
   - **Focus:** Self-documenting code

---

## ğŸ”„ Alternative Approaches Discussion

### Approach 1: Brute Force (Naive âŒ)
```python
def maxProfit_bruteforce(prices):
    max_profit = 0
    for i in range(len(prices)):
        for j in range(i + 1, len(prices)):
            profit = prices[j] - prices[i]
            max_profit = max(max_profit, profit)
    return max_profit
```
**Time:** O(nÂ²)  
**Space:** O(1)  
**Pros:** Simple, easy to understand  
**Cons:** Too slow for large inputs (10âµ elements)

### Approach 2: Track Minimum (Optimal âœ…)
```python
def maxProfit(prices):
    min_price = float('inf')
    max_profit = 0
    
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    
    return max_profit
```
**Time:** O(n)  
**Space:** O(1)  
**Pros:** Optimal, single pass, constant space  
**Cons:** Noneâ€”this is the best solution

### Approach 3: Dynamic Programming (Overkill)
```python
def maxProfit_dp(prices):
    if not prices:
        return 0
    
    # dp[i] = max profit ending at day i
    min_so_far = prices[0]
    max_profit = 0
    
    for price in prices[1:]:
        max_profit = max(max_profit, price - min_so_far)
        min_so_far = min(min_so_far, price)
    
    return max_profit
```
**Same complexity but more conceptual overhead**

---

## ğŸ—£ï¸ Interview Communication Examples

### âŒ Poor Communication
> "I'll check every pair... *starts coding nested loops*"

**Issues:**
- Didn't optimize
- No mention of time complexity
- Went straight to brute force

### âœ… Strong Communication
> "I need to find the maximum profit from buying and selling once, where buy must come before sell.
> 
> **Brute force** would be checking every buy-sell pairâ€”that's O(nÂ²). Can we do better?
> 
> **Key insight:** For each price, I only care about the **minimum price seen so far**. If I track that as I go, I can calculate today's profit in O(1).
> 
> Algorithm:
> 1. Track min_price (best buy point so far)
> 2. For each price, calculate: profit = price - min_price
> 3. Track max_profit
> 
> This gives O(n) time with O(1) spaceâ€”optimal!
> 
> Let me code this..."

**Strengths:**
- Stated brute force first
- Identified optimization opportunity
- Explained the key insight clearly
- Stated complexity before coding

---

## ğŸ“š Key Takeaways for Future Interviews

### ğŸ”‘ Greedy Pattern Recognition
- When you need **one** optimal choice from a sequence
- Can make locally optimal decisions
- Track state as you iterate (min, max, sum, etc.)

### ğŸ”‘ Common Greedy Patterns
1. **Track minimum/maximum** (this problem)
2. **Track running sum** (Maximum Subarray)
3. **Track intervals** (Merge Intervals)

### ğŸ”‘ Optimization Checklist
Before implementing:
- [ ] Can I solve it in one pass? (usually yes for arrays)
- [ ] What state do I need to track?
- [ ] Can I avoid nested loops?
- [ ] What's the space trade-off?

---

## ğŸ¯ What's Next?

You've completed **Mock Interview Problem 4 of 5**!

**Your Progress:**
- âœ… Problem 1: Two Sum (Hash Map)
- âœ… Problem 2: Add Two Numbers (Linked List)
- âœ… Problem 3: Valid Parentheses (Stack)
- âœ… Problem 4: Best Time to Buy/Sell Stock (Greedy)
- â¬œ Problem 5: Coming next...

**Your Options:**
1. ğŸ“˜ **Review Teaching Mode** - Deep dive into greedy patterns
2. ğŸ”„ **Continue to Problem 5** - Complete Session 1
3. ğŸ“Š **Compare all 4 problems** - See pattern connections
4. ğŸ¤ **Request Detailed Feedback** - Analyze your solution

---

<div align="center">

## ğŸ… Self-Assessment

**Rate yourself honestly (1-5):**

| Skill | Rating | Notes |
|-------|--------|-------|
| Optimization (O(n) vs O(nÂ²)) | __ | Did I avoid nested loops? |
| Tracking State | __ | Did I identify min_price as key? |
| Edge Cases | __ | Did I test decreasing/single prices? |
| Code Quality | __ | Clear variable names? |
| Communication | __ | Did I explain the greedy insight? |

**Total Self-Score:** __/25

</div>

---

*Remember: Array problems often have O(n) solutions by tracking state. Look for what you need to "remember" as you scan!* ğŸ’ª

**Ready for the final problem?** ğŸš€
