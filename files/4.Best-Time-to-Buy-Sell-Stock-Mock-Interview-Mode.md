# 🎤 Best Time to Buy and Sell Stock - Mock Interview Mode

> **Difficulty:** 🟢 Easy  
> **Time Limit:** ⏱️ 20 minutes  
> **Problem Link:** [LeetCode #121](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)  
> **Mock Interview:** Problem 4 of 5

---

## ⚡ Interview Rules

- ⏱️ You have **20 minutes** to solve this problem
- 💡 You may request **up to 2 hints** (score penalty applies)
- 🎯 Focus on: Correctness, Efficiency, Code Quality, Edge Cases
- 🗣️ Explain your optimization approach
- ✍️ Avoid brute force O(n²) solution

**Start your timer now!** ⏰

---

## 🧩 Problem Statement

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

Return the **maximum profit** you can achieve from this transaction. If you cannot achieve any profit, return `0`.

---

## 📝 Examples

**Example 1:**
```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

**Example 2:**
```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
```

---

## 🔍 Constraints

- `1 <= prices.length <= 10⁵`
- `0 <= prices[i] <= 10⁴`

---

## 💭 Your Solution Space

### 🎯 Clarifying Questions to Consider:
- Can prices be negative? (No, all non-negative)
- Must I buy before I sell? (Yes, buy day < sell day)
- What if I can't make profit? (Return 0)

<details>
<summary><b>🆘 Hint 1</b> (Click only if needed - Minor score penalty)</summary>

For each price, ask yourself: "What's the best price I could have bought at **so far**?"

Keep track of the **minimum price seen** up to the current position. Then calculate what profit you'd make if you sold today.

Avoid nested loops—you can solve this in O(n) with a single pass!

</details>

<details>
<summary><b>🆘 Hint 2</b> (Click only if needed - Moderate score penalty)</summary>

**Algorithm:**

```python
min_price = float('inf')
max_profit = 0

for price in prices:
    # Update minimum price seen so far
    min_price = min(min_price, price)
    
    # Calculate profit if we sell today
    profit = price - min_price
    
    # Update maximum profit
    max_profit = max(max_profit, profit)

return max_profit
```

The key insight: You only need to track two values as you iterate!

</details>

---

## ✍️ Write Your Solution Below

```python
def maxProfit(prices):
    """
    Find maximum profit from single buy-sell transaction.
    
    Args:
        prices: List[int] - Array of daily stock prices
    
    Returns:
        int - Maximum profit achievable, 0 if none possible
    """
    # TODO: Implement your solution
    pass


# ─────────────────────────────────────────────────
# Test your solution
# ─────────────────────────────────────────────────

if __name__ == "__main__":
    # Test Case 1: Normal case with profit
    print(maxProfit([7, 1, 5, 3, 6, 4]))  # Expected: 5
    
    # Test Case 2: Decreasing prices
    print(maxProfit([7, 6, 4, 3, 1]))     # Expected: 0
    
    # Test Case 3: Increasing prices
    print(maxProfit([1, 2, 3, 4, 5]))     # Expected: 4
    
    # Test Case 4: Single price
    print(maxProfit([5]))                  # Expected: 0
    
    # Test Case 5: Two prices
    print(maxProfit([2, 4]))               # Expected: 2
    
    # Test Case 6: All same
    print(maxProfit([3, 3, 3, 3]))        # Expected: 0
```

---

## ⏸️ Time's Up! Submit Your Solution

Once you've completed your solution (or time has expired), scroll down to see the evaluation.

<br><br><br><br><br>

---

# 📊 Interview Evaluation & Feedback

---

## ✅ Optimal Solution

```python
# Time Complexity: O(n) - Single pass through array
# Space Complexity: O(1) - Only two variables

def maxProfit(prices):
    """
    Find maximum profit from single buy-sell stock transaction.
    
    Strategy: Track the minimum price seen so far (best buy point)
    and calculate profit for each day as if we sell that day.
    
    Args:
        prices: List of daily stock prices
    
    Returns:
        int: Maximum profit achievable, 0 if no profit possible
    """
    # Handle edge case
    if not prices or len(prices) < 2:
        return 0
    
    # Track minimum price seen so far (best buy opportunity)
    min_price = float('inf')
    
    # Track maximum profit achievable
    max_profit = 0
    
    # Single pass through prices
    for price in prices:
        # Update minimum price (could be today's price)
        min_price = min(min_price, price)
        
        # Calculate profit if we sell today
        profit = price - min_price
        
        # Update maximum profit seen
        max_profit = max(max_profit, profit)
    
    return max_profit


# ✅ Alternative Implementation (More Explicit)
def maxProfit_v2(prices):
    """Alternative: Start with first price as minimum."""
    if len(prices) < 2:
        return 0
    
    min_price = prices[0]
    max_profit = 0
    
    for i in range(1, len(prices)):
        # Calculate profit if selling today
        profit = prices[i] - min_price
        max_profit = max(max_profit, profit)
        
        # Update minimum for future calculations
        min_price = min(min_price, prices[i])
    
    return max_profit


# ✅ Comprehensive Test Suite
def test_solution():
    test_cases = [
        ([7, 1, 5, 3, 6, 4], 5, "Buy at 1, sell at 6"),
        ([7, 6, 4, 3, 1], 0, "Decreasing prices - no profit"),
        ([1, 2, 3, 4, 5], 4, "Increasing prices - max profit"),
        ([5], 0, "Single price - can't trade"),
        ([2, 4], 2, "Two prices - simple profit"),
        ([4, 2], 0, "Two prices decreasing"),
        ([3, 3, 3, 3], 0, "All same prices"),
        ([2, 1, 2, 1, 0, 1, 2], 2, "Multiple valleys"),
        ([3, 2, 6, 5, 0, 3], 4, "Buy at 2, sell at 6"),
    ]
    
    for prices, expected, description in test_cases:
        result = maxProfit(prices)
        status = "✅" if result == expected else "❌"
        print(f"{status} {description}: {prices} → {result} (expected {expected})")

test_solution()
```

---

## 🎯 Grading Rubric (Score: __/100)

### ✅ **Correctness (40 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Returns correct profit for normal cases | 12 | __ |
| Handles decreasing prices (returns 0) | 10 | __ |
| Handles edge cases (single price, empty) | 8 | __ |
| Maintains buy-before-sell constraint | 5 | __ |
| Returns 0 for no profit scenarios | 5 | __ |

**Subtotal:** __/40

**Common Mistakes:**
- ❌ Allowing sell before buy → **-10 points**
- ❌ Not handling decreasing prices → **-10 points**
- ❌ Wrong calculation when minimum is at end → **-8 points**

---

### ⚙️ **Time Complexity (20 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Achieves O(n) single-pass solution | 15 | __ |
| Correctly analyzes time complexity | 3 | __ |
| Explained optimization over brute force | 2 | __ |

**Subtotal:** __/20

**Critical Issues:**
- ❌ Using nested loops O(n²) → **-15 points** (Major penalty!)
- ❌ Multiple passes through array → **-8 points**
- ❌ Sorting the array → **-12 points** (loses position info)

---

### 💾 **Space Complexity (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses O(1) constant space | 12 | __ |
| No unnecessary arrays/lists | 2 | __ |
| Correctly analyzes space | 1 | __ |

**Subtotal:** __/15

---

### ✍️ **Code Clarity & Style (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Clear variable names (min_price, max_profit) | 4 | __ |
| Proper comments explaining logic | 3 | __ |
| Clean code structure | 3 | __ |
| Handles edge cases gracefully | 3 | __ |
| Pythonic code style | 2 | __ |

**Subtotal:** __/15

**Best Practices:**
- ✅ Use `min_price` not `mn` or `m`
- ✅ Use `max_profit` not `ans` or `res`
- ✅ Comment the key insight about tracking minimum

---

### 🧪 **Tests & Edge Cases (10 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Tests normal profit case | 2 | __ |
| Tests decreasing prices (no profit) | 3 | __ |
| Tests edge: single price or two prices | 3 | __ |
| Tests multiple valleys and peaks | 2 | __ |

**Subtotal:** __/10

**Critical Edge Cases:**
- ✅ `[7,6,5,4,3,2,1]` → `0`
- ✅ `[1,2,3,4,5]` → `4`
- ✅ `[5]` → `0`
- ✅ `[3,2,6,5,0,3]` → `4` (not fooled by later minimum)

---

## 📈 **Bonus/Penalties**

| Item | Points | Your Score |
|------|--------|------------|
| ✅ Solved within time limit (20 min) | +5 | __ |
| ✅ No hints used | +5 | __ |
| ✅ Explained "track minimum" insight | +3 | __ |
| ✅ Drew visualization/example | +2 | __ |
| ✅ Mentioned brute force first, then optimized | +2 | __ |
| ❌ Used Hint 1 | -3 | __ |
| ❌ Used Hint 2 | -5 | __ |
| ❌ Exceeded time limit | -5 | __ |
| ❌ Used O(n²) brute force | -10 | __ |

**Bonus/Penalties:** __

---

## 🏆 **Final Score: __/100**

### Score Interpretation

| Range | Performance | Feedback |
|-------|-------------|----------|
| **90-100** | 🌟 Excellent | Perfect! You nailed the O(n) optimization. |
| **75-89** | 👍 Good | Solid solution. Minor style or edge case issues. |
| **60-74** | 🤔 Fair | Got the idea but suboptimal or missed edge cases. |
| **Below 60** | 📚 Needs Work | Review greedy algorithms and single-pass patterns. |

---

## 💬 Detailed Feedback

### ✅ What You Did Well
- [ ] Recognized single-pass optimization immediately
- [ ] Tracked minimum price correctly
- [ ] Handled all edge cases properly
- [ ] Wrote clean, readable code
- [ ] Explained the optimization strategy clearly

### 🔧 Areas for Improvement
- [ ] **Optimization:** Should aim for O(n), not O(n²)
- [ ] **Edge Cases:** Test with decreasing prices, single element
- [ ] **Explanation:** Should mention tracking minimum price as key insight
- [ ] **Code Style:** Use descriptive variable names
- [ ] **Testing:** Always test edge cases before submitting

---

## 🎯 Actionable Next Steps

Based on your performance:

### 1️⃣ **If you used O(n²) brute force:**
   - **Study:** Greedy algorithms and optimization techniques
   - **Practice:** Maximum Subarray (LC #53) - Similar pattern
   - **Focus:** How to eliminate nested loops by tracking state

### 2️⃣ **If you missed edge cases:**
   - **Exercise:** Before coding, list 5 edge cases:
     1. Decreasing prices
     2. Single price
     3. All same prices
     4. Two prices
     5. Minimum at end
   - **Practice:** Always test edge cases

### 3️⃣ **If code clarity was an issue:**
   - **Review:** Clean Code principles
   - **Practice:** Rewrite with better variable names
   - **Focus:** Self-documenting code

---

## 🔄 Alternative Approaches Discussion

### Approach 1: Brute Force (Naive ❌)
```python
def maxProfit_bruteforce(prices):
    max_profit = 0
    for i in range(len(prices)):
        for j in range(i + 1, len(prices)):
            profit = prices[j] - prices[i]
            max_profit = max(max_profit, profit)
    return max_profit
```
**Time:** O(n²)  
**Space:** O(1)  
**Pros:** Simple, easy to understand  
**Cons:** Too slow for large inputs (10⁵ elements)

### Approach 2: Track Minimum (Optimal ✅)
```python
def maxProfit(prices):
    min_price = float('inf')
    max_profit = 0
    
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    
    return max_profit
```
**Time:** O(n)  
**Space:** O(1)  
**Pros:** Optimal, single pass, constant space  
**Cons:** None—this is the best solution

### Approach 3: Dynamic Programming (Overkill)
```python
def maxProfit_dp(prices):
    if not prices:
        return 0
    
    # dp[i] = max profit ending at day i
    min_so_far = prices[0]
    max_profit = 0
    
    for price in prices[1:]:
        max_profit = max(max_profit, price - min_so_far)
        min_so_far = min(min_so_far, price)
    
    return max_profit
```
**Same complexity but more conceptual overhead**

---

## 🗣️ Interview Communication Examples

### ❌ Poor Communication
> "I'll check every pair... *starts coding nested loops*"

**Issues:**
- Didn't optimize
- No mention of time complexity
- Went straight to brute force

### ✅ Strong Communication
> "I need to find the maximum profit from buying and selling once, where buy must come before sell.
> 
> **Brute force** would be checking every buy-sell pair—that's O(n²). Can we do better?
> 
> **Key insight:** For each price, I only care about the **minimum price seen so far**. If I track that as I go, I can calculate today's profit in O(1).
> 
> Algorithm:
> 1. Track min_price (best buy point so far)
> 2. For each price, calculate: profit = price - min_price
> 3. Track max_profit
> 
> This gives O(n) time with O(1) space—optimal!
> 
> Let me code this..."

**Strengths:**
- Stated brute force first
- Identified optimization opportunity
- Explained the key insight clearly
- Stated complexity before coding

---

## 📚 Key Takeaways for Future Interviews

### 🔑 Greedy Pattern Recognition
- When you need **one** optimal choice from a sequence
- Can make locally optimal decisions
- Track state as you iterate (min, max, sum, etc.)

### 🔑 Common Greedy Patterns
1. **Track minimum/maximum** (this problem)
2. **Track running sum** (Maximum Subarray)
3. **Track intervals** (Merge Intervals)

### 🔑 Optimization Checklist
Before implementing:
- [ ] Can I solve it in one pass? (usually yes for arrays)
- [ ] What state do I need to track?
- [ ] Can I avoid nested loops?
- [ ] What's the space trade-off?

---

## 🎯 What's Next?

You've completed **Mock Interview Problem 4 of 5**!

**Your Progress:**
- ✅ Problem 1: Two Sum (Hash Map)
- ✅ Problem 2: Add Two Numbers (Linked List)
- ✅ Problem 3: Valid Parentheses (Stack)
- ✅ Problem 4: Best Time to Buy/Sell Stock (Greedy)
- ⬜ Problem 5: Coming next...

**Your Options:**
1. 📘 **Review Teaching Mode** - Deep dive into greedy patterns
2. 🔄 **Continue to Problem 5** - Complete Session 1
3. 📊 **Compare all 4 problems** - See pattern connections
4. 🎤 **Request Detailed Feedback** - Analyze your solution

---

<div align="center">

## 🏅 Self-Assessment

**Rate yourself honestly (1-5):**

| Skill | Rating | Notes |
|-------|--------|-------|
| Optimization (O(n) vs O(n²)) | __ | Did I avoid nested loops? |
| Tracking State | __ | Did I identify min_price as key? |
| Edge Cases | __ | Did I test decreasing/single prices? |
| Code Quality | __ | Clear variable names? |
| Communication | __ | Did I explain the greedy insight? |

**Total Self-Score:** __/25

</div>

---

*Remember: Array problems often have O(n) solutions by tracking state. Look for what you need to "remember" as you scan!* 💪

**Ready for the final problem?** 🚀
