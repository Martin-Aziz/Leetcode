# üìò Best Time to Buy and Sell Stock - Teaching Mode

> **Difficulty:** üü¢ Easy  
> **Problem Link:** [LeetCode #121](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)  
> **Pattern:** Array / Single Pass / Greedy  
> **Session:** Problem 4 of 5

---

## üß© Problem Statement

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

Return the **maximum profit** you can achieve from this transaction. If you cannot achieve any profit, return `0`.

### üìù Examples

**Example 1:**
```python
Input: prices = [7, 1, 5, 3, 6, 4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note: Not 7-1 = 6, as selling price needs to be after buying price.
```

**Example 2:**
```python
Input: prices = [7, 6, 4, 3, 1]
Output: 0
Explanation: In this case, no transactions are done and max profit = 0.
```

### üîç Input/Output Types
- **Input:** `prices` - List of integers representing stock prices (`List[int]`)
- **Output:** Integer representing maximum profit (`int`)

---

## üß† Understanding the Problem

**What is this problem really asking?**

Find the maximum difference between two numbers where the smaller number comes **before** the larger number in the array.

**Real-World Analogy:**  
Imagine you have a time machine that lets you look at stock prices for the next week. You want to find the best day to buy (lowest price) and the best day to sell (highest price **after** buying) to maximize profit.

**Key Points:**
- ‚úÖ Must buy **before** you sell (can't look into the past!)
- ‚úÖ Only one transaction allowed (one buy + one sell)
- ‚úÖ If no profit possible, return 0
- ‚ö†Ô∏è Prices can decrease continuously (all selling days worse than buying day)
- ‚ö†Ô∏è Need to maximize: `sell_price - buy_price`

**Edge Cases:**
- Prices always decreasing: `[7,6,5,4,3,2,1]` ‚Üí `0`
- Prices always increasing: `[1,2,3,4,5,6,7]` ‚Üí `6` (buy at 1, sell at 7)
- Single price: `[5]` ‚Üí `0` (can't buy and sell on same day)
- All same prices: `[3,3,3,3]` ‚Üí `0`

---

## üß≠ Recognizing the Pattern(s)

### üéØ Primary Pattern: **Single Pass / Tracking Minimum**

**Analogy:** Imagine you're walking through a valley. You want to find the deepest point (minimum price) and then climb to the highest point **after** that (maximum profit). As you walk, you keep track of:
1. The lowest point you've seen so far
2. The best profit you could make from that low point

**Why This Pattern?**
- We need to track the **minimum price seen so far** (best buy point)
- For each price, calculate profit if we sell today
- Keep track of the **maximum profit** seen
- Only one pass needed!

**Visual Example:**
```
Prices: [7, 1, 5, 3, 6, 4]

Day 1: price=7, min=7, profit=0
Day 2: price=1, min=1, profit=0     ‚¨ÖÔ∏è New minimum!
Day 3: price=5, min=1, profit=4     (5-1=4)
Day 4: price=3, min=1, profit=4     (3-1=2, not better)
Day 5: price=6, min=1, profit=5     (6-1=5) ‚¨ÖÔ∏è Best profit!
Day 6: price=4, min=1, profit=5     (4-1=3, not better)

Answer: 5
```

**Alternative (Naive) Pattern:** Brute Force
- Check every possible buy-sell pair
- Time: O(n¬≤) ‚Äî too slow!

---

## ü™ú High-Level Plan

### Strategy: Track Minimum and Maximum Profit

1. **Initialize** tracking variables:
   - `min_price` = infinity (or first price)
   - `max_profit` = 0
2. **Iterate through each price** (left to right):
   - **Update minimum:** Is current price lower than `min_price`?
   - **Calculate profit:** `current_price - min_price`
   - **Update max profit:** Is this profit better than `max_profit`?
3. **Return** `max_profit`

### üìã Pseudocode

```python
# Step 1: Initialize
min_price = infinity
max_profit = 0

# Step 2: Scan through prices
for price in prices:
    # Update minimum price seen so far
    min_price = min(min_price, price)
    
    # Calculate profit if we sell today
    profit = price - min_price
    
    # Update maximum profit
    max_profit = max(max_profit, profit)

# Step 3: Return result
return max_profit
```

---

## üí° Hints Policy

### üéì Level 1 Hint (Small Nudge)
<details>
<summary>Click to reveal Level 1 Hint</summary>

Think about what you need to know at each step: "What's the best price I could have bought at so far?" and "What's the best profit I could make if I sell today?"

You only need to track two numbers as you go through the array. Can you solve this in a single pass?

</details>

### üéì Level 2 Hint (Medium Help)
<details>
<summary>Click to reveal Level 2 Hint</summary>

**Key insight:** Keep track of the **minimum price seen so far**. For each price:
1. Update the minimum if current price is lower
2. Calculate profit: `current_price - min_price`
3. Update maximum profit if this is better

Example walkthrough:
```
[7, 1, 5, 3, 6, 4]
 ‚Üì  ‚Üì  ‚Üì  ‚Üì  ‚Üì  ‚Üì
min: 7‚Üí1‚Üí1‚Üí1‚Üí1‚Üí1
profit: 0‚Üí0‚Üí4‚Üí4‚Üí5‚Üí5
```

You don't need nested loops!

</details>

### üéì Level 3 Hint (Almost There)
<details>
<summary>Click to reveal Level 3 Hint</summary>

```python
def maxProfit(prices):
    min_price = float('inf')
    max_profit = 0
    
    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)
    
    return max_profit
```

The trick: For each price, we know the best buy price so far (`min_price`), so we can instantly calculate the profit if we sell today.

</details>

---

## üßë‚Äçüíª Code Solution (Python)

### ‚ú® Optimal Solution

```python
# Time Complexity: O(n) - Single pass through array
# Space Complexity: O(1) - Only two variables

def maxProfit(prices):
    """
    Find maximum profit from buying and selling stock once.
    
    Strategy: Track minimum price seen so far, and calculate
    profit for each price as if we sell that day.
    
    Args:
        prices: List of daily stock prices
    
    Returns:
        int: Maximum profit achievable
    """
    # Handle edge case
    if not prices:
        return 0
    
    # Initialize tracking variables
    min_price = float('inf')  # Lowest price seen so far
    max_profit = 0            # Best profit seen so far
    
    # Single pass through prices
    for price in prices:
        # Update minimum price (best buy point so far)
        min_price = min(min_price, price)
        
        # Calculate profit if we sell today
        profit = price - min_price
        
        # Update maximum profit
        max_profit = max(max_profit, profit)
    
    return max_profit


# ‚úÖ Test Cases
def test_max_profit():
    # Test 1: Normal case with profit
    assert maxProfit([7, 1, 5, 3, 6, 4]) == 5
    print("‚úÖ Test 1 passed: [7,1,5,3,6,4] ‚Üí profit = 5 (buy at 1, sell at 6)")
    
    # Test 2: Decreasing prices (no profit)
    assert maxProfit([7, 6, 4, 3, 1]) == 0
    print("‚úÖ Test 2 passed: [7,6,4,3,1] ‚Üí profit = 0 (no good sell day)")
    
    # Test 3: Increasing prices (max profit)
    assert maxProfit([1, 2, 3, 4, 5]) == 4
    print("‚úÖ Test 3 passed: [1,2,3,4,5] ‚Üí profit = 4 (buy at 1, sell at 5)")
    
    # Test 4: Single price
    assert maxProfit([5]) == 0
    print("‚úÖ Test 4 passed: [5] ‚Üí profit = 0 (need 2 different days)")
    
    # Test 5: Two prices
    assert maxProfit([2, 4]) == 2
    print("‚úÖ Test 5 passed: [2,4] ‚Üí profit = 2")
    
    # Test 6: Two prices (decreasing)
    assert maxProfit([4, 2]) == 0
    print("‚úÖ Test 6 passed: [4,2] ‚Üí profit = 0")
    
    # Test 7: Multiple valleys and peaks
    assert maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) == 4
    print("‚úÖ Test 7 passed: [3,3,5,0,0,3,1,4] ‚Üí profit = 4 (buy at 0, sell at 4)")

test_max_profit()
```

### üîÑ Alternative Solution (Cleaner with enumerate)

```python
def maxProfit_v2(prices):
    """Alternative: explicitly track buy day."""
    if len(prices) < 2:
        return 0
    
    min_price = prices[0]
    max_profit = 0
    
    for price in prices[1:]:
        max_profit = max(max_profit, price - min_price)
        min_price = min(min_price, price)
    
    return max_profit


# Test
print(maxProfit_v2([7, 1, 5, 3, 6, 4]))  # 5
```

---

## üß© Step-by-Step Explanation

Let's trace through **Example 1:** `prices = [7, 1, 5, 3, 6, 4]`

### Initialization
```python
min_price = ‚àû (infinity)
max_profit = 0
```

### Iteration 1: `price = 7`
```
min_price = min(‚àû, 7) = 7
profit = 7 - 7 = 0
max_profit = max(0, 0) = 0

State: min_price=7, max_profit=0
```

### Iteration 2: `price = 1`
```
min_price = min(7, 1) = 1  ‚¨ÖÔ∏è New minimum!
profit = 1 - 1 = 0
max_profit = max(0, 0) = 0

State: min_price=1, max_profit=0
```

### Iteration 3: `price = 5`
```
min_price = min(1, 5) = 1
profit = 5 - 1 = 4  ‚¨ÖÔ∏è Good profit!
max_profit = max(0, 4) = 4

State: min_price=1, max_profit=4
```

### Iteration 4: `price = 3`
```
min_price = min(1, 3) = 1
profit = 3 - 1 = 2
max_profit = max(4, 2) = 4  (no improvement)

State: min_price=1, max_profit=4
```

### Iteration 5: `price = 6`
```
min_price = min(1, 6) = 1
profit = 6 - 1 = 5  ‚¨ÖÔ∏è Best profit!
max_profit = max(4, 5) = 5

State: min_price=1, max_profit=5
```

### Iteration 6: `price = 4`
```
min_price = min(1, 4) = 1
profit = 4 - 1 = 3
max_profit = max(5, 3) = 5  (no improvement)

State: min_price=1, max_profit=5
```

### Return
```python
return 5  ‚úÖ
```

---

## üé¨ Visual Walkthrough

```
Prices: [7, 1, 5, 3, 6, 4]

Graph visualization:
 7 ‚Ä¢
   |
 6 |              ‚Ä¢
   |              
 5 |        ‚Ä¢     
   |           
 4 |                   ‚Ä¢
   |
 3 |           ‚Ä¢
   |
 2 |
   |
 1 |     ‚Ä¢
   |___________________
     0   1   2   3   4   5  (day)

Min price tracking:
Day 0: min=7
Day 1: min=1  ‚¨ÖÔ∏è Buy here!
Day 2: min=1
Day 3: min=1
Day 4: min=1
Day 5: min=1

Profit tracking:
Day 0: 7-7=0
Day 1: 1-1=0
Day 2: 5-1=4  üí∞
Day 3: 3-1=2
Day 4: 6-1=5  üí∞üí∞ ‚¨ÖÔ∏è Sell here!
Day 5: 4-1=3

Best profit: 5
```

---

## ‚è±Ô∏è Complexity Analysis

### Time Complexity: **O(n)**
- `n` = length of prices array
- Single pass through the array (one loop)
- Each iteration does constant work: O(1)
- Total: **O(n)**

### Space Complexity: **O(1)**
- Only use two variables: `min_price` and `max_profit`
- No data structures that grow with input
- **Constant space: O(1)** ‚úÖ

### üìä Comparison with Brute Force

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| **Brute Force** | O(n¬≤) | O(1) | Check every buy-sell pair |
| **Single Pass (Optimal)** | O(n) | O(1) | Track minimum + max profit |

**Trade-off:** None! The optimal solution is better in every way.

---

## üîÅ Variations & Follow-Ups

### üü¢ Related Easy Problems
1. **Best Time to Buy and Sell Stock II** (LeetCode #122) - Multiple transactions allowed
   - Greedy: Buy every valley, sell every peak
   - Still O(n), but different strategy

2. **Maximum Subarray** (LeetCode #53) - Find max sum subarray
   - Same pattern: track current vs best
   - Kadane's algorithm

### üü° Medium Variations
3. **Best Time to Buy and Sell Stock with Cooldown** (LeetCode #309)
   - Dynamic programming required
   - Must wait 1 day after selling

4. **Best Time to Buy and Sell Stock with Transaction Fee** (LeetCode #714)
   - Fee deducted from each transaction
   - DP or greedy with state tracking

### üî¥ Harder Variations
5. **Best Time to Buy and Sell Stock III** (LeetCode #123) - At most 2 transactions
   - DP with state machines
   - Track: buy1, sell1, buy2, sell2

6. **Best Time to Buy and Sell Stock IV** (LeetCode #188) - At most k transactions
   - Generalized DP solution
   - O(nk) time

**Pattern Evolution:**
- **One transaction** (this problem) ‚Üí Track minimum
- **Unlimited transactions** ‚Üí Greedy (sum all upward movements)
- **Limited transactions** ‚Üí Dynamic programming with states

---

## üß© Reflection & Reinforcement

### üìö Check Your Understanding

<details>
<summary><b>Question 1:</b> Why do we need to track the minimum price instead of just finding it once?</summary>

**Answer:** The minimum price **changes** as we scan through the array. Consider `[5, 2, 7, 1, 4]`:
- At index 2 (price=7), minimum is 2, profit = 7-2 = 5
- At index 3 (price=1), minimum becomes 1
- At index 4 (price=4), profit = 4-1 = 3

We need to update the minimum **as we go** because each price could be the new best buy point.

</details>

<details>
<summary><b>Question 2:</b> Can we find the minimum first, then find the maximum after it?</summary>

**Answer:** Not directly in one pass! Consider `[3, 1, 4, 2, 5]`:
- Global minimum: 1 (index 1)
- Maximum after index 1: 5 (index 4)
- Profit: 5 - 1 = 4 ‚úÖ

But what about `[3, 5, 1, 2]`?
- Global minimum: 1 (index 2)
- Maximum after index 2: 2
- But better profit is 5 - 3 = 2 (before global minimum!)

You need to track the **local minimum** at each position, not global minimum.

</details>

<details>
<summary><b>Question 3:</b> What if we want to return the actual buy and sell days, not just the profit?</summary>

**Answer:** We'd need to track indices:
```python
def maxProfit_with_days(prices):
    min_price = float('inf')
    max_profit = 0
    buy_day = 0
    sell_day = 0
    min_day = 0
    
    for i, price in enumerate(prices):
        if price < min_price:
            min_price = price
            min_day = i
        
        profit = price - min_price
        if profit > max_profit:
            max_profit = profit
            buy_day = min_day
            sell_day = i
    
    return max_profit, buy_day, sell_day
```

</details>

---

## üéØ Practice Problems (Similar Pattern)

Here are 3 problems using the **Single Pass / Tracking Min/Max** pattern:

1. **Maximum Subarray** (LeetCode #53) - Easy üü¢
   - *Why:* Track current sum and max sum (same pattern!)
   - *Skill:* Kadane's algorithm‚Äîfundamental dynamic programming

2. **Best Time to Buy and Sell Stock II** (LeetCode #122) - Medium üü°
   - *Why:* Extends this problem with multiple transactions
   - *Skill:* Greedy algorithm with arrays

3. **Container With Most Water** (LeetCode #11) - Medium üü°
   - *Why:* Find maximum area using two pointers
   - *Skill:* Two-pointer technique with tracking maximum

**For Array Fundamentals:**
4. **Contains Duplicate** (LeetCode #217) - Easy üü¢
   - *Why:* Basic array traversal with tracking
   - *Skill:* Using sets for O(1) lookup

---

## üí¨ Interview Mindset Tips

### üéôÔ∏è 1. **Think Aloud - State the Insight**
- Start with: *"I need to find the maximum difference between buy and sell prices, where buy comes before sell..."*
- Key insight: *"If I track the minimum price seen so far, I can calculate the profit for each day by subtracting from the current price."*
- Show optimization: *"Instead of checking every buy-sell pair (O(n¬≤)), I can do this in one pass by tracking the minimum and maximum profit."*

### ‚è∞ 2. **Manage Time - Recognize the Pattern**
- This is a common pattern: **tracking minimum/maximum while scanning**
- Similar to Maximum Subarray (Kadane's algorithm)
- Once you see the pattern, implementation is 5-10 lines

### üß™ 3. **Test Edge Cases**
Before coding, mention:
- *"I should test: all decreasing prices (no profit), all increasing prices (maximum profit), and single price (impossible to trade)."*

After coding:
```python
maxProfit([7, 6, 5, 4, 3])  # 0 (no profit)
maxProfit([1, 2, 3, 4, 5])  # 4 (max profit)
maxProfit([5])              # 0 (need 2 days)
maxProfit([2, 4, 1])        # 2 (not fooled by later minimum)
```

### ‚öñÔ∏è 4. **Compare Trade-offs**
- *"The brute force approach would check every pair: O(n¬≤). But by tracking the minimum price as I go, I can solve it in O(n) with just two variables‚Äîconstant space. This is optimal."*

---

## ‚úÖ Summary Checklist

Before moving to the next problem, make sure you can:

- [ ] Explain why we track minimum price instead of finding it first
- [ ] Write the solution in one pass with O(1) space
- [ ] Handle edge cases (decreasing prices, single price)
- [ ] Recognize this as a "tracking min/max" pattern
- [ ] Draw the graph to visualize buy/sell points
- [ ] Extend the logic to related problems (multiple transactions)

---

## üéØ Next Steps

You've completed **Problem 4 of 5** in this session! üéâ

**Progress Check:**
- ‚úÖ Problem 1: Two Sum (Hash Map)
- ‚úÖ Problem 2: Add Two Numbers (Linked List)
- ‚úÖ Problem 3: Valid Parentheses (Stack)
- ‚úÖ Problem 4: Best Time to Buy and Sell Stock (Array/Greedy)
- ‚¨ú Problem 5: Coming next...

**Choose your next action:**

1. üîÑ **Continue with Problem 5** - Complete the set!
2. üé§ **Try Mock Interview Mode** - Test this problem under pressure
3. üìù **Review all 4 patterns** - See connections
4. üß† **Take a break** - You're almost done!

*One more problem to go! Let me know when you're ready!*

---

<div align="center">

**Happy Coding! üöÄ**

*Greedy algorithms: Sometimes the simple approach is the best!*

</div>
