# 🎯 Problem 13: Validate Binary Search Tree

**Difficulty:** 🟡 Medium  
**Pattern:** Tree Recursion / DFS  
**LeetCode Link:** [#98 Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

---

## 📋 Problem Statement

Given the `root` of a binary tree, *determine if it is a valid binary search tree (BST)*.

A **valid BST** is defined as follows:
- The left subtree of a node contains only nodes with keys **less than** the node's key
- The right subtree contains only nodes with keys **greater than** the node's key
- Both left and right subtrees must also be BSTs

### Examples:

```
Example 1:
    2
   / \
  1   3
Input: root = [2,1,3]
Output: true

Example 2:
    5
   / \
  1   4
     / \
    3   6
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: Root is 5 but right child 4 < 5
```

---

## 🎓 Understanding

### Common Mistake:

```python
# WRONG! Only checks immediate children
def isValidBST(root):
    if root.left and root.left.val >= root.val:
        return False
    if root.right and root.right.val <= root.val:
        return False
    return True
```

This fails for:
```
    10
   /  \
  5   15
     /  \
    6   20
```
Node 6 < 10 violates BST property!

---

## 🔍 Pattern: Recursive with Range

**Key Insight:** Each node must be within a valid range [min, max]

```python
def isValidBST(root):
    def validate(node, low, high):
        if not node:
            return True
        
        if node.val <= low or node.val >= high:
            return False
        
        return (validate(node.left, low, node.val) and
                validate(node.right, node.val, high))
    
    return validate(root, float('-inf'), float('inf'))
```

---

## ✅ Solutions

### Solution 1: Recursive with Range

```python
def isValidBST(root):
    """
    Time: O(n) - visit each node once
    Space: O(h) - recursion stack height
    """
    def validate(node, low=float('-inf'), high=float('inf')):
        if not node:
            return True
        
        if node.val <= low or node.val >= high:
            return False
        
        return (validate(node.left, low, node.val) and
                validate(node.right, node.val, high))
    
    return validate(root)
```

### Solution 2: Inorder Traversal

```python
def isValidBST(root):
    """
    BST inorder traversal is strictly increasing.
    
    Time: O(n)
    Space: O(n)
    """
    def inorder(node):
        if not node:
            return []
        return inorder(node.left) + [node.val] + inorder(node.right)
    
    values = inorder(root)
    return all(values[i] < values[i+1] for i in range(len(values)-1))
```

### Solution 3: Iterative Inorder

```python
def isValidBST(root):
    """
    Space-optimized iterative inorder.
    
    Time: O(n)
    Space: O(h)
    """
    stack = []
    prev = float('-inf')
    current = root
    
    while stack or current:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        if current.val <= prev:
            return False
        prev = current.val
        current = current.right
    
    return True
```

---

## 🎯 Practice Problems

1. **[LeetCode 99] Recover Binary Search Tree** (Medium)
2. **[LeetCode 501] Find Mode in BST** (Easy)
3. **[LeetCode 530] Minimum Absolute Difference in BST** (Easy)

---

## 🏆 Key Takeaways

1. **Don't just check immediate children** - validate entire subtree ranges
2. **Inorder traversal** of BST must be strictly increasing
3. **Three approaches:** Recursive range, Inorder array, Iterative inorder

---

**Ready to test?** 🚀 Move to **`13.Validate-BST-Mock-Interview-Mode.md`**

*Happy Coding! 💻✨*
