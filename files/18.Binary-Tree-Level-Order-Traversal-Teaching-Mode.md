# üéØ Problem 18: Binary Tree Level Order Traversal

**Difficulty:** üü° Medium  
**Pattern:** BFS / Queue / Tree Traversal  
**LeetCode Link:** [#102 Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

---

## üìã Problem Statement

Given the `root` of a binary tree, return the **level order traversal** of its nodes' values (i.e., from left to right, level by level).

### Examples:

```
Input: root = [3,9,20,null,null,15,7]
       3
      / \
     9  20
       /  \
      15   7

Output: [[3],[9,20],[15,7]]

Input: root = [1]
Output: [[1]]

Input: root = []
Output: []
```

---

## üéì Understanding

### Level Order vs Other Traversals

```
Tree:
       1
      / \
     2   3
    / \
   4   5

Preorder (DFS):  [1, 2, 4, 5, 3]
Inorder (DFS):   [4, 2, 5, 1, 3]
Postorder (DFS): [4, 5, 2, 3, 1]
Level Order (BFS): [[1], [2,3], [4,5]] ‚Üê Our goal!
```

**Key:** Process nodes **level by level**, left to right.

---

## üîç Solution 1: BFS with Queue (Iterative)

```python
from collections import deque

def levelOrder(root: TreeNode) -> list[list[int]]:
    """
    BFS with queue - process level by level.
    
    Time: O(n) - visit each node once
    Space: O(w) - width of tree (max nodes in a level)
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        # Process all nodes in current level
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            # Add children for next level
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result
```

### üìä Step-by-Step Example

```
Tree:     3
        /   \
       9    20
           /  \
          15   7

Initial: queue = [3], result = []

Level 1:
  - level_size = 1
  - Process 3 ‚Üí current_level = [3]
  - Add children: queue = [9, 20]
  - result = [[3]]

Level 2:
  - level_size = 2
  - Process 9 ‚Üí current_level = [9]
  - Process 20 ‚Üí current_level = [9, 20]
  - Add children: queue = [15, 7]
  - result = [[3], [9, 20]]

Level 3:
  - level_size = 2
  - Process 15 ‚Üí current_level = [15]
  - Process 7 ‚Üí current_level = [15, 7]
  - queue = []
  - result = [[3], [9, 20], [15, 7]]

Done!
```

---

## üîç Solution 2: DFS with Level Tracking (Recursive)

```python
def levelOrder(root: TreeNode) -> list[list[int]]:
    """
    DFS with level parameter - less intuitive but works.
    
    Time: O(n)
    Space: O(h) - recursion stack height
    """
    if not root:
        return []
    
    result = []
    
    def dfs(node, level):
        if not node:
            return
        
        # Create new level list if needed
        if level == len(result):
            result.append([])
        
        # Add node to its level
        result[level].append(node.val)
        
        # Recurse on children
        dfs(node.left, level + 1)
        dfs(node.right, level + 1)
    
    dfs(root, 0)
    return result
```

---

## üîç Solution 3: BFS with Sentinel (Alternative)

```python
def levelOrder(root: TreeNode) -> list[list[int]]:
    """
    Use None as level separator.
    
    Time: O(n)
    Space: O(w)
    """
    if not root:
        return []
    
    result = []
    queue = deque([root, None])  # None marks end of level
    current_level = []
    
    while queue:
        node = queue.popleft()
        
        if node is None:
            result.append(current_level)
            current_level = []
            if queue:  # More levels to process
                queue.append(None)
        else:
            current_level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    
    return result
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| BFS (Queue) | O(n) | O(w) | w = max width, most intuitive |
| DFS (Recursive) | O(n) | O(h) | h = height, less intuitive |
| BFS (Sentinel) | O(n) | O(w) | Alternative BFS style |

**Recommendation:** BFS with queue (Solution 1) is clearest for level order.

---

## üéØ Key Patterns

### Pattern 1: Level-by-Level Processing
```python
while queue:
    level_size = len(queue)  # Snapshot current level size
    for _ in range(level_size):
        node = queue.popleft()
        # Process node...
```

### Pattern 2: DFS with Level Parameter
```python
def dfs(node, level):
    if level == len(result):
        result.append([])  # Create new level
    result[level].append(node.val)
```

### Pattern 3: Adding Children
```python
if node.left:
    queue.append(node.left)
if node.right:
    queue.append(node.right)
```

---

## üêõ Common Mistakes

### ‚ùå Mistake 1: Not Separating Levels
```python
# WRONG - mixes all levels
while queue:
    node = queue.popleft()
    result.append(node.val)  # No level separation!
```

### ‚ùå Mistake 2: Modifying Queue During Iteration
```python
# WRONG - queue size changes during loop
for node in queue:  # Don't iterate directly!
    queue.append(node.left)
```

### ‚ùå Mistake 3: Forgetting to Check None
```python
# WRONG - will crash
queue.append(node.left)  # What if node.left is None?

# RIGHT
if node.left:
    queue.append(node.left)
```

---

## üéØ Practice Problems

1. **[LeetCode 107] Binary Tree Level Order Traversal II** (Medium) - Bottom-up
2. **[LeetCode 103] Binary Tree Zigzag Level Order** (Medium) - Alternate directions
3. **[LeetCode 637] Average of Levels in Binary Tree** (Easy)
4. **[LeetCode 515] Find Largest Value in Each Tree Row** (Medium)
5. **[LeetCode 199] Binary Tree Right Side View** (Medium)

---

## üèÜ Key Takeaways

1. **BFS = Queue** for level-by-level traversal
2. **Snapshot `len(queue)`** before processing each level
3. **DFS can work** but BFS is more natural for level order
4. **Each level** is a separate list in result
5. **Space complexity** is O(width) for BFS, O(height) for DFS

---

## üí° Interview Tips

**When asked about level order:**
- Mention **BFS with queue** immediately
- Discuss **how to separate levels** (snapshot size)
- Consider follow-ups: zigzag, bottom-up, right side view
- Compare BFS vs DFS approach

**Optimization:** For complete binary trees, can calculate level mathematically.

---

## üîÑ Variations

### Bottom-Up (Level Order II)
```python
return result[::-1]  # Just reverse!
```

### Zigzag (Level Order III)
```python
for i, level in enumerate(result):
    if i % 2 == 1:
        result[i] = level[::-1]
```

### Right Side View
```python
return [level[-1] for level in result]
```

---

**Ready to test?** üöÄ Move to **`18.Binary-Tree-Level-Order-Traversal-Mock-Interview-Mode.md`**

*Happy Coding! üíª‚ú®*
