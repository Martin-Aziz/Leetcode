# 🎯 Problem 8: Number of Islands

**Difficulty:** 🟡 Medium  
**Pattern:** Graph Traversal (DFS/BFS)  
**Time Limit:** 30 minutes  
**LeetCode Link:** [#200 Number of Islands](https://leetcode.com/problems/number-of-islands/)

---

## 📋 Problem Statement

Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

### Examples:

**Example 1:**
```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

**Example 2:**
```
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

### Constraints:
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` is `'0'` or `'1'`

---

## 🎓 Understanding the Problem

### What is an island?

An island is a group of `'1'`s (land) that are connected **horizontally or vertically** (NOT diagonally).

**Visual Example:**
```
Island 1:      Island 2:      NOT an island:
1 1 0          0 0 0          1 0 1
1 0 0          0 1 1          0 1 0
0 0 0          0 1 0          1 0 1
(connected)    (connected)    (diagonal only)
```

### Key Observations:

1. **Connectivity:** Only horizontal/vertical connections count
2. **Visited tracking:** Once we explore a land cell, mark it as visited
3. **Counting:** Each time we find unvisited land, we found a new island
4. **Graph problem:** This is a graph traversal on a 2D grid!

---

## 🔍 Pattern Recognition: Graph Traversal (DFS/BFS)

This is a classic **Graph Traversal** problem!

### Why is this a graph problem?

- **Nodes:** Each cell in the grid
- **Edges:** Connections between adjacent cells (up, down, left, right)
- **Task:** Count connected components (islands)

### Two Main Approaches:

#### 1️⃣ **DFS (Depth-First Search)** - Recursive
```python
# Go deep first, then backtrack
def dfs(row, col):
    if out_of_bounds or water or visited:
        return
    mark_visited()
    dfs(row+1, col)  # down
    dfs(row-1, col)  # up
    dfs(row, col+1)  # right
    dfs(row, col-1)  # left
```

#### 2️⃣ **BFS (Breadth-First Search)** - Iterative with Queue
```python
# Explore level by level
queue = [(start_row, start_col)]
while queue:
    row, col = queue.pop(0)
    add_neighbors_to_queue()
```

---

## 📝 High-Level Plan

### Approach 1: DFS (Recommended)

**Core Idea:**
1. Iterate through every cell in the grid
2. When we find unvisited land ('1'), increment island count
3. Use DFS to mark all connected land cells as visited
4. Continue until all cells are processed

**Pseudocode:**
```
Initialize island_count = 0

For each cell (i, j) in grid:
    If cell is land ('1') and not visited:
        island_count += 1
        DFS(i, j) to mark entire island as visited

Return island_count
```

**DFS Function:**
```
DFS(row, col):
    If out of bounds or water or visited:
        return
    
    Mark current cell as visited
    
    DFS(row + 1, col)  # explore down
    DFS(row - 1, col)  # explore up
    DFS(row, col + 1)  # explore right
    DFS(row, col - 1)  # explore left
```

---

## 💡 Progressive Hints

<details>
<summary><b>💡 Hint 1: How to mark cells as visited?</b></summary>

**Option 1:** Modify the grid in-place (change '1' to '0' or '2')
```python
grid[row][col] = '0'  # Mark as visited
```

**Option 2:** Use a separate visited set
```python
visited = set()
visited.add((row, col))
```

For this problem, modifying in-place is simpler and more efficient!

</details>

<details>
<summary><b>💡 Hint 2: What are the boundary conditions for DFS?</b></summary>

Check if we should STOP exploring:

```python
# Out of bounds
if row < 0 or row >= m or col < 0 or col >= n:
    return

# Water or already visited
if grid[row][col] == '0':
    return
```

These checks prevent infinite recursion!

</details>

<details>
<summary><b>💡 Hint 3: DFS vs BFS - which to choose?</b></summary>

**Both work!** Choose based on:

**DFS (Recursive):**
- ✅ Simpler code
- ✅ More intuitive
- ❌ Stack overflow risk for very large islands
- **Best for interviews**

**BFS (Iterative with Queue):**
- ✅ No recursion limit issues
- ✅ Explores level by level
- ❌ Slightly more code
- **Best for production**

</details>

---

## ✅ Complete Solution

### Solution 1: DFS (Recursive) - Most Popular

```python
def numIslands(grid: list[list[str]]) -> int:
    """
    Count number of islands using DFS.
    
    Approach:
    - Iterate through each cell
    - When finding unvisited land, start DFS to mark entire island
    - Count each new island found
    
    Time: O(m * n) - visit each cell once
    Space: O(m * n) - recursion stack in worst case (entire grid is one island)
    """
    if not grid or not grid[0]:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    islands = 0
    
    def dfs(r: int, c: int) -> None:
        """Mark entire connected island as visited."""
        # Base cases: out of bounds or water/visited
        if (r < 0 or r >= rows or 
            c < 0 or c >= cols or 
            grid[r][c] == '0'):
            return
        
        # Mark as visited by changing to water
        grid[r][c] = '0'
        
        # Explore all 4 directions
        dfs(r + 1, c)  # down
        dfs(r - 1, c)  # up
        dfs(r, c + 1)  # right
        dfs(r, c - 1)  # left
    
    # Iterate through every cell
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1':
                # Found new island!
                islands += 1
                # Mark entire island as visited
                dfs(i, j)
    
    return islands


# Test cases
def test_solution():
    # Test 1: Single island
    grid1 = [
        ["1","1","1","1","0"],
        ["1","1","0","1","0"],
        ["1","1","0","0","0"],
        ["0","0","0","0","0"]
    ]
    assert numIslands(grid1) == 1
    
    # Test 2: Three islands
    grid2 = [
        ["1","1","0","0","0"],
        ["1","1","0","0","0"],
        ["0","0","1","0","0"],
        ["0","0","0","1","1"]
    ]
    assert numIslands(grid2) == 3
    
    # Test 3: All water
    grid3 = [["0","0"],["0","0"]]
    assert numIslands(grid3) == 0
    
    # Test 4: All land (one big island)
    grid4 = [["1","1"],["1","1"]]
    assert numIslands(grid4) == 1
    
    print("✅ All tests passed!")

test_solution()
```

### Solution 2: BFS (Iterative with Queue)

```python
from collections import deque

def numIslands(grid: list[list[str]]) -> int:
    """
    Count number of islands using BFS.
    
    Time: O(m * n)
    Space: O(min(m, n)) - queue size in worst case
    """
    if not grid or not grid[0]:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    islands = 0
    
    def bfs(start_r: int, start_c: int) -> None:
        """Explore entire island using BFS."""
        queue = deque([(start_r, start_c)])
        grid[start_r][start_c] = '0'  # Mark as visited
        
        while queue:
            r, c = queue.popleft()
            
            # Check all 4 directions
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                
                # If valid land cell, add to queue
                if (0 <= nr < rows and 
                    0 <= nc < cols and 
                    grid[nr][nc] == '1'):
                    grid[nr][nc] = '0'  # Mark as visited
                    queue.append((nr, nc))
    
    # Iterate through every cell
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1':
                islands += 1
                bfs(i, j)
    
    return islands
```

### Solution 3: DFS with Directions Array (Clean)

```python
def numIslands(grid: list[list[str]]) -> int:
    """
    DFS with directions array for cleaner code.
    """
    if not grid or not grid[0]:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    islands = 0
    directions = [(1,0), (-1,0), (0,1), (0,-1)]  # down, up, right, left
    
    def dfs(r: int, c: int) -> None:
        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0':
            return
        
        grid[r][c] = '0'  # Mark visited
        
        # Explore all 4 directions
        for dr, dc in directions:
            dfs(r + dr, c + dc)
    
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1':
                islands += 1
                dfs(i, j)
    
    return islands
```

---

## 🔬 Step-by-Step Walkthrough

Let's trace through this grid:
```
["1","1","0"]
["1","0","0"]
["0","0","1"]
```

**Initial state:** islands = 0

```
Step 1: Check (0,0) = '1' → Found land!
├─ islands = 1
├─ Start DFS(0,0)
│
DFS(0,0):
├─ grid[0][0] = '1' → mark as '0'
├─ DFS(1,0): down
│  ├─ grid[1][0] = '1' → mark as '0'
│  ├─ DFS(2,0): down → grid[2][0] = '0', return
│  ├─ DFS(0,0): up → out of bounds, return
│  ├─ DFS(1,1): right → grid[1][1] = '0', return
│  └─ DFS(1,-1): left → out of bounds, return
├─ DFS(-1,0): up → out of bounds, return
├─ DFS(0,1): right
│  └─ grid[0][1] = '1' → mark as '0'
│     └─ (explore neighbors, all water/visited)
└─ DFS(0,-1): left → out of bounds, return

Grid after island 1 marked:
["0","0","0"]
["0","0","0"]
["0","0","1"]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Step 2: Check (0,1) = '0' → skip
Step 3: Check (0,2) = '0' → skip
...
Step 8: Check (2,2) = '1' → Found land!
├─ islands = 2
├─ DFS(2,2)
│  ├─ grid[2][2] = '1' → mark as '0'
│  └─ (explore all neighbors, all water/bounds)

Grid after island 2 marked:
["0","0","0"]
["0","0","0"]
["0","0","0"]

Final Answer: 2 islands
```

---

## ⚡ Complexity Analysis

### Time Complexity: **O(m × n)**
- We visit every cell in the grid exactly once
- Each DFS call marks cells as visited, preventing revisits
- m = number of rows, n = number of columns

### Space Complexity: **O(m × n)**
- **Recursion stack (DFS):** In worst case (entire grid is one island), recursion depth = m × n
- **Queue (BFS):** In worst case, queue size = min(m, n)
- If modifying grid in-place: O(1) extra space
- If using visited set: O(m × n) extra space

---

## 🤔 Reflection Questions

1. **Why does marking visited cells prevent infinite loops?**
   <details>
   <summary>Answer</summary>
   
   Without marking visited, we'd keep revisiting the same cells in a cycle. For example, from (0,0) we'd visit (0,1), then from (0,1) back to (0,0), and so on forever.
   
   </details>

2. **Can we use Union-Find for this problem?**
   <details>
   <summary>Answer</summary>
   
   Yes! Union-Find is another approach:
   - Treat each '1' cell as a node
   - Union adjacent '1' cells
   - Count number of disjoint sets
   - Time: O(m×n×α(m×n)) where α is inverse Ackermann function (nearly constant)
   - More complex but handles dynamic updates better
   
   </details>

3. **What if diagonal connections also count as adjacent?**
   <details>
   <summary>Answer</summary>
   
   Just add 4 more directions:
   ```python
   directions = [
       (1,0), (-1,0), (0,1), (0,-1),    # original 4
       (1,1), (1,-1), (-1,1), (-1,-1)   # add diagonals
   ]
   ```
   
   </details>

---

## 🎯 Practice Problems

1. **[LeetCode 695] Max Area of Island** (Medium)
   - Find size of largest island

2. **[LeetCode 130] Surrounded Regions** (Medium)
   - Capture regions surrounded by 'X'

3. **[LeetCode 417] Pacific Atlantic Water Flow** (Medium)
   - Water flow from two oceans

4. **[LeetCode 994] Rotting Oranges** (Medium)
   - BFS with time tracking

---

## 💡 Interview Tips

✅ **Ask about constraints:**
- Can I modify the input grid?
- Are diagonal connections allowed?

✅ **Discuss trade-offs:**
- DFS vs BFS
- In-place marking vs visited set

✅ **Mention edge cases:**
- Empty grid
- All water / all land
- Single cell

❌ **Common Mistakes:**
- Forgetting boundary checks
- Not marking cells as visited
- Counting cells instead of islands

---

## 🏆 Key Takeaways

1. **Graph traversal on 2D grids** - treat grid as graph
2. **DFS for connected components** - recursive exploration
3. **Mark visited to avoid cycles** - change '1' to '0'
4. **4-directional movement** - up, down, left, right
5. **Both DFS and BFS work** - choose based on preference

---

**Ready to test yourself?** 🚀  
Move on to **`8.Number-of-Islands-Mock-Interview-Mode.md`**

**Pattern Mastery Progress:**  
Session 1: Hash Map ✓ | Linked List ✓ | Stack ✓ | Greedy ✓ | Two Pointers ✓  
**Session 2: Sliding Window ✓ | Binary Search ✓ | BFS/DFS ← YOU ARE HERE** | Array/Prefix | BST

*Happy Coding! 💻✨*
