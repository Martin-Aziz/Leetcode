# 🎯 Problem 9: Product of Array Except Self

**Difficulty:** 🟡 Medium  
**Pattern:** Array / Prefix Product  
**Time Limit:** 25 minutes  
**LeetCode Link:** [#238 Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

---

## 📋 Problem Statement

Given an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.

The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

**You must write an algorithm that runs in O(n) time and without using the division operation.**

### Examples:

**Example 1:**
```
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Explanation:
- answer[0] = 2*3*4 = 24
- answer[1] = 1*3*4 = 12
- answer[2] = 1*2*4 = 8
- answer[3] = 1*2*3 = 6
```

**Example 2:**
```
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
```

### Constraints:
- `2 <= nums.length <= 10^5`
- `-30 <= nums[i] <= 30`
- The product of any prefix or suffix is **guaranteed** to fit in a 32-bit integer

### Follow-up:
Can you solve it in O(1) extra space complexity? (The output array does not count as extra space.)

---

## 🎓 Understanding the Problem

### What are we computing?

For each index `i`, we need the product of **all other elements**.

**Visualization:**
```
nums = [1, 2, 3, 4]
         ↑
For index 0: skip nums[0]=1, multiply rest: 2*3*4 = 24

nums = [1, 2, 3, 4]
            ↑
For index 1: skip nums[1]=2, multiply rest: 1*3*4 = 12

And so on...
```

### Key Constraints:

1. **O(n) time** - Can't use nested loops (O(n²))
2. **No division** - Can't do `total_product / nums[i]`
3. **Handle zeros** - Division would fail anyway!

### Naive Approach (What NOT to do):

```python
# O(n²) - TOO SLOW!
answer = []
for i in range(len(nums)):
    product = 1
    for j in range(len(nums)):
        if i != j:
            product *= nums[j]
    answer.append(product)
```

---

## 🔍 Pattern Recognition: Prefix & Suffix Product

This is a **Prefix/Suffix Array** problem!

### 💡 Key Insight:

For each index `i`, the answer is:
```
answer[i] = (product of all elements to the left) × (product of all elements to the right)
```

**Visual Example:**
```
nums = [1, 2, 3, 4]

For index 2 (value 3):
├─ Left products:  1 × 2 = 2
├─ Right products: 4 = 4
└─ answer[2] = 2 × 4 = 8 ✓
```

### Approach: Two-Pass with Prefix & Suffix Arrays

**Pass 1:** Calculate prefix products (left to right)
```
nums    = [1,  2,  3,  4]
prefix  = [1,  1,  2,  6]
           ↑   ↑   ↑   ↑
          1  1×1 1×2 2×3
```

**Pass 2:** Calculate suffix products (right to left)
```
nums    = [1,  2,  3,  4]
suffix  = [24, 12, 4,  1]
           ↑   ↑   ↑   ↑
         2×3×4 3×4  4   1
```

**Combine:**
```
answer[i] = prefix[i] × suffix[i]
answer = [1×24, 1×12, 2×4, 6×1] = [24, 12, 8, 6] ✓
```

---

## 📝 High-Level Plan

### Approach 1: With Extra Space O(n)

```
1. Create prefix array: prefix[i] = product of nums[0...i-1]
2. Create suffix array: suffix[i] = product of nums[i+1...n-1]
3. Calculate answer: answer[i] = prefix[i] × suffix[i]
```

### Approach 2: Optimized O(1) Space (Follow-up)

```
1. Build answer as prefix array (left to right)
2. Use single variable for suffix product
3. Multiply answer in-place with suffix (right to left)
```

---

## 💡 Progressive Hints

<details>
<summary><b>💡 Hint 1: What does "product except self" mean mathematically?</b></summary>

For index `i`:
```
answer[i] = nums[0] × ... × nums[i-1] × nums[i+1] × ... × nums[n-1]
          = (left products) × (right products)
```

Split the problem into left and right parts!

</details>

<details>
<summary><b>💡 Hint 2: How to build prefix products?</b></summary>

**Prefix product:** Running product from left to right

```python
prefix = [1] * len(nums)
for i in range(1, len(nums)):
    prefix[i] = prefix[i-1] * nums[i-1]
```

Example:
```
nums   = [1,  2,  3,  4]
prefix = [1,  1,  2,  6]
            ↑  ↑   ↑   ↑
           1  1×1 1×2 2×3
```

Note: `prefix[0] = 1` (no elements to the left)

</details>

<details>
<summary><b>💡 Hint 3: How to optimize to O(1) space?</b></summary>

Instead of creating separate prefix and suffix arrays, use the `answer` array itself!

**Step 1:** Build prefix in `answer`
**Step 2:** Use a variable `suffix` to track right products, multiply in-place

```python
# Step 1: answer as prefix
answer = [1] * n
for i in range(1, n):
    answer[i] = answer[i-1] * nums[i-1]

# Step 2: multiply by suffix
suffix = 1
for i in range(n-1, -1, -1):
    answer[i] *= suffix
    suffix *= nums[i]
```

</details>

---

## ✅ Complete Solution

### Solution 1: With Extra Space O(n)

```python
def productExceptSelf(nums: list[int]) -> list[int]:
    """
    Calculate product except self using prefix and suffix arrays.
    
    Approach:
    - prefix[i] = product of all elements before i
    - suffix[i] = product of all elements after i
    - answer[i] = prefix[i] * suffix[i]
    
    Time: O(n) - three passes through array
    Space: O(n) - two auxiliary arrays
    """
    n = len(nums)
    
    # Build prefix products
    prefix = [1] * n
    for i in range(1, n):
        prefix[i] = prefix[i-1] * nums[i-1]
    
    # Build suffix products
    suffix = [1] * n
    for i in range(n-2, -1, -1):
        suffix[i] = suffix[i+1] * nums[i+1]
    
    # Combine
    answer = [prefix[i] * suffix[i] for i in range(n)]
    
    return answer


# Test cases
def test_solution():
    assert productExceptSelf([1,2,3,4]) == [24,12,8,6]
    assert productExceptSelf([-1,1,0,-3,3]) == [0,0,9,0,0]
    assert productExceptSelf([2,3,4,5]) == [60,40,30,24]
    print("✅ All tests passed!")

test_solution()
```

### Solution 2: Optimized O(1) Space (Recommended)

```python
def productExceptSelf(nums: list[int]) -> list[int]:
    """
    Optimized solution using output array for prefix products.
    
    Key insight: Build prefix in answer array, then multiply
    by suffix products in reverse pass.
    
    Time: O(n) - two passes
    Space: O(1) - only output array (doesn't count as extra space)
    """
    n = len(nums)
    answer = [1] * n
    
    # Build prefix products in answer array
    # answer[i] = product of all elements before i
    for i in range(1, n):
        answer[i] = answer[i-1] * nums[i-1]
    
    # Multiply by suffix products
    suffix = 1  # Running suffix product
    for i in range(n-1, -1, -1):
        answer[i] *= suffix
        suffix *= nums[i]
    
    return answer
```

---

## 🔬 Step-by-Step Walkthrough

Let's trace through **`nums = [1, 2, 3, 4]`** with optimized solution:

```
Initial: nums = [1, 2, 3, 4], answer = [1, 1, 1, 1]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PASS 1: Build prefix products (left to right)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

i=1: answer[1] = answer[0] * nums[0] = 1 * 1 = 1
     answer = [1, 1, 1, 1]

i=2: answer[2] = answer[1] * nums[1] = 1 * 2 = 2
     answer = [1, 1, 2, 1]

i=3: answer[3] = answer[2] * nums[2] = 2 * 3 = 6
     answer = [1, 1, 2, 6]

After Pass 1:
answer[0] = 1     (no elements before index 0)
answer[1] = 1     (product before: 1)
answer[2] = 2     (product before: 1×2)
answer[3] = 6     (product before: 1×2×3)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PASS 2: Multiply by suffix (right to left)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Initial: suffix = 1

i=3: answer[3] *= suffix → 6 * 1 = 6
     suffix *= nums[3]   → 1 * 4 = 4
     answer = [1, 1, 2, 6]

i=2: answer[2] *= suffix → 2 * 4 = 8
     suffix *= nums[2]   → 4 * 3 = 12
     answer = [1, 1, 8, 6]

i=1: answer[1] *= suffix → 1 * 12 = 12
     suffix *= nums[1]   → 12 * 2 = 24
     answer = [1, 12, 8, 6]

i=0: answer[0] *= suffix → 1 * 24 = 24
     suffix *= nums[0]   → 24 * 1 = 24
     answer = [24, 12, 8, 6]

Final Answer: [24, 12, 8, 6] ✓
```

---

## ⚡ Complexity Analysis

### Time Complexity: **O(n)**
- Pass 1: Build prefix → O(n)
- Pass 2: Multiply by suffix → O(n)
- **Total: O(n + n) = O(n)**

### Space Complexity: **O(1)**
- Only using the output array (doesn't count as extra space per problem statement)
- Variable `suffix` is O(1)
- No additional arrays needed

---

## 🎨 Variations

### With Division (If allowed):

```python
def productExceptSelf_division(nums: list[int]) -> list[int]:
    """
    If division was allowed and no zeros.
    WARNING: This fails with zeros!
    """
    total_product = 1
    for num in nums:
        total_product *= num
    
    return [total_product // num for num in nums]
```

### Handling zeros properly with division:

```python
def productExceptSelf_with_zeros(nums: list[int]) -> list[int]:
    """
    Handle zeros when division is allowed.
    """
    zeros = nums.count(0)
    
    if zeros > 1:
        return [0] * len(nums)
    
    if zeros == 1:
        product = 1
        for num in nums:
            if num != 0:
                product *= num
        return [product if num == 0 else 0 for num in nums]
    
    # No zeros
    product = 1
    for num in nums:
        product *= num
    return [product // num for num in nums]
```

---

## 🤔 Reflection Questions

1. **Why can't we just use division?**
   <details>
   <summary>Answer</summary>
   
   - Problem explicitly forbids it
   - Division fails with zeros in array
   - Division is slower than multiplication on some hardware
   - Good practice for handling constraints!
   
   </details>

2. **What if array contains zeros?**
   <details>
   <summary>Answer</summary>
   
   Our solution handles zeros naturally!
   - One zero: Only that index gets non-zero product
   - Multiple zeros: All indices get zero
   
   Example: `[-1,1,0,-3,3]` → `[0,0,9,0,0]`
   
   </details>

3. **Can we do this in one pass?**
   <details>
   <summary>Answer</summary>
   
   No! We need information from both sides (left and right products). Two passes is optimal.
   
   </details>

---

## 🎯 Practice Problems

1. **[LeetCode 152] Maximum Product Subarray** (Medium)
2. **[LeetCode 53] Maximum Subarray** (Medium)  
3. **[LeetCode 560] Subarray Sum Equals K** (Medium)
4. **[LeetCode 724] Find Pivot Index** (Easy)

---

## 💡 Interview Tips

✅ **Mention constraints:**
- "I see O(n) time and no division"
- "This suggests prefix/suffix approach"

✅ **Discuss optimization:**
- Start with O(n) space solution
- Then optimize to O(1) space

✅ **Handle edge cases:**
- Single zero vs multiple zeros
- Negative numbers
- All ones

❌ **Common Mistakes:**
- Off-by-one in loop indices
- Forgetting to initialize to 1 (not 0!)
- Not handling zeros

---

## 🏆 Key Takeaways

1. **Prefix/Suffix pattern** for array products
2. **Two passes**: left-to-right, then right-to-left
3. **Space optimization**: Use output array for prefix
4. **Works with zeros** naturally
5. **O(n) time, O(1) space** is optimal

---

**Ready to test yourself?** 🚀  
Move on to **`9.Product-of-Array-Except-Self-Mock-Interview-Mode.md`**

**Pattern Mastery Progress:**  
Session 2: Sliding Window ✓ | Binary Search ✓ | BFS/DFS ✓ | **Array/Prefix ← YOU ARE HERE** | BST

*Happy Coding! 💻✨*
