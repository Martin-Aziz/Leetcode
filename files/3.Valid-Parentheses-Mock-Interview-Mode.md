# ğŸ¤ Valid Parentheses - Mock Interview Mode

> **Difficulty:** ğŸŸ¢ Easy  
> **Time Limit:** â±ï¸ 15 minutes  
> **Problem Link:** [LeetCode #20](https://leetcode.com/problems/valid-parentheses/)  
> **Mock Interview:** Problem 3 of 5

---

## âš¡ Interview Rules

- â±ï¸ You have **15 minutes** to solve this problem
- ğŸ’¡ You may request **up to 2 hints** (score penalty applies)
- ğŸ¯ Focus on: Correctness, Efficiency, Code Quality, Edge Cases
- ğŸ—£ï¸ Explain your thought process clearly
- âœï¸ Test with edge cases before submitting

**Start your timer now!** â°

---

## ğŸ§© Problem Statement

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

---

## ğŸ“ Examples

**Example 1:**
```
Input: s = "()"
Output: true
```

**Example 2:**
```
Input: s = "()[]{}"
Output: true
```

**Example 3:**
```
Input: s = "(]"
Output: false
```

**Example 4:**
```
Input: s = "([)]"
Output: false
```

**Example 5:**
```
Input: s = "{[]}"
Output: true
```

---

## ğŸ” Constraints

- `1 <= s.length <= 10â´`
- `s` consists of parentheses only `'()[]{}'`

---

## ğŸ’­ Your Solution Space

### ğŸ¯ Clarifying Questions to Consider:
- What order must brackets be closed in?
- Can we have unmatched opening or closing brackets?
- Is an empty string considered valid?

<details>
<summary><b>ğŸ†˜ Hint 1</b> (Click only if needed - Minor score penalty)</summary>

Think about **when** you need to match brackets. When you see a closing bracket, which opening bracket should it match with?

The answer: The **most recent** unmatched opening bracket.

What data structure gives you access to the most recent item? Think **Last In, First Out (LIFO)**.

</details>

<details>
<summary><b>ğŸ†˜ Hint 2</b> (Click only if needed - Moderate score penalty)</summary>

Use a **stack**!

**Algorithm:**
```python
stack = []
mapping = {')': '(', '}': '{', ']': '['}

for char in s:
    if char in mapping:  # Closing bracket
        # Check if stack is empty or top doesn't match
        if not stack or stack.pop() != mapping[char]:
            return False
    else:  # Opening bracket
        stack.append(char)

# Stack should be empty at the end
return len(stack) == 0
```

Key insights:
- Push all opening brackets onto stack
- For closing brackets, pop and verify match
- Empty stack at end means all matched

</details>

---

## âœï¸ Write Your Solution Below

```python
def isValid(s):
    """
    Determine if bracket string is valid.
    
    Args:
        s: str - String containing only bracket characters
    
    Returns:
        bool - True if valid, False otherwise
    """
    # TODO: Implement your solution
    pass


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Test your solution
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if __name__ == "__main__":
    # Test Case 1: Simple valid
    print(isValid("()"))        # Expected: True
    
    # Test Case 2: Multiple types
    print(isValid("()[]{}"))    # Expected: True
    
    # Test Case 3: Wrong type
    print(isValid("(]"))        # Expected: False
    
    # Test Case 4: Wrong order
    print(isValid("([)]"))      # Expected: False
    
    # Test Case 5: Properly nested
    print(isValid("{[]}"))      # Expected: True
    
    # Test Case 6: Empty string (if allowed)
    print(isValid(""))          # Expected: True
    
    # Test Case 7: Only opening
    print(isValid("((("))       # Expected: False
    
    # Test Case 8: Only closing
    print(isValid(")))"))       # Expected: False
```

---

## â¸ï¸ Time's Up! Submit Your Solution

Once you've completed your solution (or time has expired), scroll down to see the evaluation.

<br><br><br><br><br>

---

# ğŸ“Š Interview Evaluation & Feedback

---

## âœ… Optimal Solution

```python
# Time Complexity: O(n) - Single pass through string
# Space Complexity: O(n) - Stack can hold up to n/2 brackets

def isValid(s):
    """
    Check if bracket string is valid using stack.
    
    Key insight: Brackets must be closed in reverse order (LIFO),
    which is exactly what a stack provides.
    
    Args:
        s: String containing only bracket characters
    
    Returns:
        bool: True if valid, False otherwise
    """
    # Stack to track opening brackets
    stack = []
    
    # Map closing brackets to their opening counterparts
    mapping = {
        ')': '(',
        '}': '{',
        ']': '['
    }
    
    # Process each character
    for char in s:
        # Case 1: Closing bracket
        if char in mapping:
            # Get top element (or dummy if empty)
            top_element = stack.pop() if stack else '#'
            
            # Check if it matches expected opening bracket
            if mapping[char] != top_element:
                return False
        
        # Case 2: Opening bracket
        else:
            stack.append(char)
    
    # Valid only if all brackets were matched (stack empty)
    return len(stack) == 0


# âœ… Comprehensive Test Suite
def test_solution():
    test_cases = [
        ("()", True, "Simple pair"),
        ("()[]{}", True, "Multiple types"),
        ("(]", False, "Wrong type"),
        ("([)]", False, "Wrong order"),
        ("{[]}", True, "Nested valid"),
        ("", True, "Empty string"),
        ("(((", False, "Only opening"),
        (")))", False, "Only closing"),
        ("({[]})", True, "Complex nested"),
        ("(])", False, "Three chars invalid"),
        ("{", False, "Single opening"),
        ("}", False, "Single closing"),
    ]
    
    for s, expected, description in test_cases:
        result = isValid(s)
        status = "âœ…" if result == expected else "âŒ"
        print(f"{status} {description}: '{s}' â†’ {result}")

test_solution()
```

### ğŸ”„ Alternative (More Concise)

```python
def isValid_v2(s):
    """Concise version with opening bracket check."""
    stack = []
    pairs = {'(': ')', '{': '}', '[': ']'}
    
    for char in s:
        if char in pairs:  # Opening bracket
            stack.append(char)
        elif not stack or pairs[stack.pop()] != char:
            return False
    
    return not stack
```

---

## ğŸ¯ Grading Rubric (Score: __/100)

### âœ… **Correctness (40 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Correct for valid strings | 10 | __ |
| Correct for invalid (wrong type) | 8 | __ |
| Correct for invalid (wrong order) | 8 | __ |
| Handles empty stack case | 7 | __ |
| Returns correct boolean | 7 | __ |

**Subtotal:** __/40

**Common Mistakes:**
- âŒ Not checking if stack is empty before popping â†’ **-10 points**
- âŒ Not checking if stack is empty at the end â†’ **-8 points**
- âŒ Wrong mapping (openingâ†’closing vs closingâ†’opening) â†’ **-5 points**

---

### âš™ï¸ **Time Complexity (20 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Achieves O(n) single-pass solution | 15 | __ |
| Correctly analyzes complexity | 3 | __ |
| Explains approach before coding | 2 | __ |

**Subtotal:** __/20

**Issues to avoid:**
- âŒ Using string replacement approach (O(nÂ²)) â†’ **-10 points**
- âŒ Multiple passes through string â†’ **-5 points**

---

### ğŸ’¾ **Space Complexity (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses O(n) space for stack | 10 | __ |
| No unnecessary data structures | 3 | __ |
| Correctly analyzes space | 2 | __ |

**Subtotal:** __/15

---

### âœï¸ **Code Clarity & Style (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses stack data structure explicitly | 4 | __ |
| Clear variable names | 3 | __ |
| Proper mapping dictionary | 3 | __ |
| Clean code structure | 3 | __ |
| Appropriate comments | 2 | __ |

**Subtotal:** __/15

**Best Practices:**
- âœ… Use `stack` (not `s` or `st`)
- âœ… Create `mapping` dictionary for clarity
- âœ… Comment the two cases (opening vs closing)

---

### ğŸ§ª **Tests & Edge Cases (10 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Tests basic valid cases | 2 | __ |
| Tests wrong type: `"(]"` | 3 | __ |
| Tests wrong order: `"([)]"` | 3 | __ |
| Tests only opening/closing | 2 | __ |

**Subtotal:** __/10

**Critical Edge Cases:**
- âœ… Empty string (if constraints allow)
- âœ… Only opening: `"((("`
- âœ… Only closing: `")))"`
- âœ… Single bracket: `"("` or `")"`

---

## ğŸ“ˆ **Bonus/Penalties**

| Item | Points | Your Score |
|------|--------|------------|
| âœ… Solved within time limit (15 min) | +5 | __ |
| âœ… No hints used | +5 | __ |
| âœ… Mentioned LIFO/stack pattern explicitly | +3 | __ |
| âœ… Explained why stack is optimal | +2 | __ |
| âŒ Used Hint 1 | -3 | __ |
| âŒ Used Hint 2 | -5 | __ |
| âŒ Exceeded time limit | -5 | __ |
| âŒ Code crashed on empty stack | -5 | __ |

**Bonus/Penalties:** __

---

## ğŸ† **Final Score: __/100**

### Score Interpretation

| Range | Performance | Feedback |
|-------|-------------|----------|
| **90-100** | ğŸŒŸ Excellent | Perfect understanding of stack pattern! |
| **75-89** | ğŸ‘ Good | Solid solution. Minor edge case or style issues. |
| **60-74** | ğŸ¤” Fair | Got the idea but missed key details. |
| **Below 60** | ğŸ“š Needs Work | Review stack fundamentals. |

---

## ğŸ’¬ Detailed Feedback

### âœ… What You Did Well
- [ ] Recognized stack pattern immediately
- [ ] Handled both opening and closing brackets correctly
- [ ] Checked for empty stack before popping
- [ ] Verified stack is empty at the end
- [ ] Wrote clean, readable code
- [ ] Tested edge cases thoroughly

### ğŸ”§ Areas for Improvement
- [ ] **Stack Check:** Always check `if not stack` before popping
- [ ] **Mapping:** Use closingâ†’opening mapping (easier for checking)
- [ ] **Edge Cases:** Test empty string, single bracket, only openings
- [ ] **Communication:** Explain "LIFO matches bracket closing order"
- [ ] **Final Check:** Remember to return `len(stack) == 0`, not just `True`

---

## ğŸ¯ Actionable Next Steps

Based on your performance, here are **3 targeted exercises**:

### 1ï¸âƒ£ **If you struggled with Stack concept:**
   - **Study:** Review stack operations (push, pop, peek)
   - **Practice:** Implement Min Stack (LC #155)
   - **Focus:** Understanding LIFO and when to use stacks

### 2ï¸âƒ£ **If you missed edge cases:**
   - **Practice:** Create test cases BEFORE coding
   - **Exercise:** For every problem, list 5 edge cases:
     1. Empty input
     2. Single element
     3. All same type
     4. Alternating types
     5. Maximum constraint
   - **Focus:** Systematic edge case analysis

### 3ï¸âƒ£ **If code clarity was an issue:**
   - **Review:** Python best practices for stack usage
   - **Practice:** Rewrite solution with better names/comments
   - **Focus:** Making code interview-ready

---

## ğŸ”„ Alternative Approaches Discussion

### Approach 1: Stack with Closingâ†’Opening Mapping (Optimal âœ…)
```python
def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:  # Closing
            if not stack or stack.pop() != mapping[char]:
                return False
        else:  # Opening
            stack.append(char)
    
    return len(stack) == 0
```
**Pros:** Clean, O(n) time, O(n) space  
**Cons:** Noneâ€”this is optimal

### Approach 2: Stack with Openingâ†’Closing Mapping
```python
def isValid(s):
    stack = []
    pairs = {'(': ')', '{': '}', '[': ']'}
    
    for char in s:
        if char in pairs:  # Opening
            stack.append(char)
        elif not stack or pairs[stack.pop()] != char:
            return False
    
    return not stack
```
**Pros:** Also valid, slightly different logic  
**Cons:** Must check `pairs[stack.pop()]` instead of `mapping[char]`

### Approach 3: String Replacement (Inefficient âŒ)
```python
def isValid_bad(s):
    while '()' in s or '[]' in s or '{}' in s:
        s = s.replace('()', '').replace('[]', '').replace('{}', '')
    return s == ''
```
**Pros:** Intuitive  
**Cons:** O(nÂ²) time complexityâ€”too slow!

---

## ğŸ—£ï¸ Interview Communication Examples

### âŒ Poor Communication
> "I'll use a list... *starts coding immediately*"

**Issues:**
- Didn't identify it as a stack problem
- No explanation of algorithm
- No edge case discussion

### âœ… Strong Communication
> "This is a classic stack problem. The key insight is that brackets must be closed in reverse orderâ€”Last In, First Outâ€”which is exactly what a stack provides.
>
> My approach:
> 1. Push all opening brackets onto a stack
> 2. When I see a closing bracket, pop from stack and verify it matches
> 3. At the end, the stack should be empty
>
> Edge cases to consider: empty string, only opening brackets, only closing brackets, and wrong order like `([)]`.
>
> Time: O(n), Space: O(n) for the stack.
>
> Let me code this up..."

**Strengths:**
- Identified pattern (stack/LIFO)
- Clear algorithm steps
- Mentioned edge cases
- Stated complexity

---

## ğŸ“š Key Takeaways for Future Interviews

### ğŸ”‘ Stack Pattern Recognition
- **LIFO matching** â†’ Stack
- **Nested structures** â†’ Stack
- **Reverse order processing** â†’ Stack

### ğŸ”‘ Implementation Details
1. Always check `if not stack` before popping
2. Map closingâ†’opening for easier validation
3. Final check: stack must be empty

### ğŸ”‘ Common Pitfalls
- Forgetting to check stack is empty at the end
- Not handling empty stack before pop
- Wrong mapping direction

---

## ğŸ¯ What's Next?

You've completed **Mock Interview Problem 3 of 5**!

**Your Progress:**
- âœ… Problem 1: Two Sum (Hash Map)
- âœ… Problem 2: Add Two Numbers (Linked List)
- âœ… Problem 3: Valid Parentheses (Stack)
- â¬œ Problem 4: Coming next...
- â¬œ Problem 5: Coming next...

**Your Options:**
1. ğŸ“˜ **Review Teaching Mode** - Deep dive into stack patterns
2. ğŸ”„ **Continue to Problem 4** - Keep momentum
3. ğŸ“Š **Compare all 3 patterns** - Hash Map, Linked List, Stack
4. ğŸ¤ **Request Detailed Feedback** - Analyze your solution

---

<div align="center">

## ğŸ… Self-Assessment

**Rate yourself honestly (1-5):**

| Skill | Rating | Notes |
|-------|--------|-------|
| Pattern Recognition | __ | Did I identify the stack pattern? |
| Edge Case Handling | __ | Did I handle empty stack and final check? |
| Code Implementation | __ | Was my code clean and correct? |
| Time Management | __ | Did I finish within 15 minutes? |
| Communication | __ | Did I explain LIFO/stack reasoning? |

**Total Self-Score:** __/25

</div>

---

*Remember: Stack problems are about recognizing LIFO patterns. Once you see it, the implementation is straightforward!* ğŸ’ª

**Ready for Problem 4?** ğŸš€
