# 🎤 Valid Parentheses - Mock Interview Mode

> **Difficulty:** 🟢 Easy  
> **Time Limit:** ⏱️ 15 minutes  
> **Problem Link:** [LeetCode #20](https://leetcode.com/problems/valid-parentheses/)  
> **Mock Interview:** Problem 3 of 5

---

## ⚡ Interview Rules

- ⏱️ You have **15 minutes** to solve this problem
- 💡 You may request **up to 2 hints** (score penalty applies)
- 🎯 Focus on: Correctness, Efficiency, Code Quality, Edge Cases
- 🗣️ Explain your thought process clearly
- ✍️ Test with edge cases before submitting

**Start your timer now!** ⏰

---

## 🧩 Problem Statement

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

---

## 📝 Examples

**Example 1:**
```
Input: s = "()"
Output: true
```

**Example 2:**
```
Input: s = "()[]{}"
Output: true
```

**Example 3:**
```
Input: s = "(]"
Output: false
```

**Example 4:**
```
Input: s = "([)]"
Output: false
```

**Example 5:**
```
Input: s = "{[]}"
Output: true
```

---

## 🔍 Constraints

- `1 <= s.length <= 10⁴`
- `s` consists of parentheses only `'()[]{}'`

---

## 💭 Your Solution Space

### 🎯 Clarifying Questions to Consider:
- What order must brackets be closed in?
- Can we have unmatched opening or closing brackets?
- Is an empty string considered valid?

<details>
<summary><b>🆘 Hint 1</b> (Click only if needed - Minor score penalty)</summary>

Think about **when** you need to match brackets. When you see a closing bracket, which opening bracket should it match with?

The answer: The **most recent** unmatched opening bracket.

What data structure gives you access to the most recent item? Think **Last In, First Out (LIFO)**.

</details>

<details>
<summary><b>🆘 Hint 2</b> (Click only if needed - Moderate score penalty)</summary>

Use a **stack**!

**Algorithm:**
```python
stack = []
mapping = {')': '(', '}': '{', ']': '['}

for char in s:
    if char in mapping:  # Closing bracket
        # Check if stack is empty or top doesn't match
        if not stack or stack.pop() != mapping[char]:
            return False
    else:  # Opening bracket
        stack.append(char)

# Stack should be empty at the end
return len(stack) == 0
```

Key insights:
- Push all opening brackets onto stack
- For closing brackets, pop and verify match
- Empty stack at end means all matched

</details>

---

## ✍️ Write Your Solution Below

```python
def isValid(s):
    """
    Determine if bracket string is valid.
    
    Args:
        s: str - String containing only bracket characters
    
    Returns:
        bool - True if valid, False otherwise
    """
    # TODO: Implement your solution
    pass


# ─────────────────────────────────────────────────
# Test your solution
# ─────────────────────────────────────────────────

if __name__ == "__main__":
    # Test Case 1: Simple valid
    print(isValid("()"))        # Expected: True
    
    # Test Case 2: Multiple types
    print(isValid("()[]{}"))    # Expected: True
    
    # Test Case 3: Wrong type
    print(isValid("(]"))        # Expected: False
    
    # Test Case 4: Wrong order
    print(isValid("([)]"))      # Expected: False
    
    # Test Case 5: Properly nested
    print(isValid("{[]}"))      # Expected: True
    
    # Test Case 6: Empty string (if allowed)
    print(isValid(""))          # Expected: True
    
    # Test Case 7: Only opening
    print(isValid("((("))       # Expected: False
    
    # Test Case 8: Only closing
    print(isValid(")))"))       # Expected: False
```

---

## ⏸️ Time's Up! Submit Your Solution

Once you've completed your solution (or time has expired), scroll down to see the evaluation.

<br><br><br><br><br>

---

# 📊 Interview Evaluation & Feedback

---

## ✅ Optimal Solution

```python
# Time Complexity: O(n) - Single pass through string
# Space Complexity: O(n) - Stack can hold up to n/2 brackets

def isValid(s):
    """
    Check if bracket string is valid using stack.
    
    Key insight: Brackets must be closed in reverse order (LIFO),
    which is exactly what a stack provides.
    
    Args:
        s: String containing only bracket characters
    
    Returns:
        bool: True if valid, False otherwise
    """
    # Stack to track opening brackets
    stack = []
    
    # Map closing brackets to their opening counterparts
    mapping = {
        ')': '(',
        '}': '{',
        ']': '['
    }
    
    # Process each character
    for char in s:
        # Case 1: Closing bracket
        if char in mapping:
            # Get top element (or dummy if empty)
            top_element = stack.pop() if stack else '#'
            
            # Check if it matches expected opening bracket
            if mapping[char] != top_element:
                return False
        
        # Case 2: Opening bracket
        else:
            stack.append(char)
    
    # Valid only if all brackets were matched (stack empty)
    return len(stack) == 0


# ✅ Comprehensive Test Suite
def test_solution():
    test_cases = [
        ("()", True, "Simple pair"),
        ("()[]{}", True, "Multiple types"),
        ("(]", False, "Wrong type"),
        ("([)]", False, "Wrong order"),
        ("{[]}", True, "Nested valid"),
        ("", True, "Empty string"),
        ("(((", False, "Only opening"),
        (")))", False, "Only closing"),
        ("({[]})", True, "Complex nested"),
        ("(])", False, "Three chars invalid"),
        ("{", False, "Single opening"),
        ("}", False, "Single closing"),
    ]
    
    for s, expected, description in test_cases:
        result = isValid(s)
        status = "✅" if result == expected else "❌"
        print(f"{status} {description}: '{s}' → {result}")

test_solution()
```

### 🔄 Alternative (More Concise)

```python
def isValid_v2(s):
    """Concise version with opening bracket check."""
    stack = []
    pairs = {'(': ')', '{': '}', '[': ']'}
    
    for char in s:
        if char in pairs:  # Opening bracket
            stack.append(char)
        elif not stack or pairs[stack.pop()] != char:
            return False
    
    return not stack
```

---

## 🎯 Grading Rubric (Score: __/100)

### ✅ **Correctness (40 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Correct for valid strings | 10 | __ |
| Correct for invalid (wrong type) | 8 | __ |
| Correct for invalid (wrong order) | 8 | __ |
| Handles empty stack case | 7 | __ |
| Returns correct boolean | 7 | __ |

**Subtotal:** __/40

**Common Mistakes:**
- ❌ Not checking if stack is empty before popping → **-10 points**
- ❌ Not checking if stack is empty at the end → **-8 points**
- ❌ Wrong mapping (opening→closing vs closing→opening) → **-5 points**

---

### ⚙️ **Time Complexity (20 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Achieves O(n) single-pass solution | 15 | __ |
| Correctly analyzes complexity | 3 | __ |
| Explains approach before coding | 2 | __ |

**Subtotal:** __/20

**Issues to avoid:**
- ❌ Using string replacement approach (O(n²)) → **-10 points**
- ❌ Multiple passes through string → **-5 points**

---

### 💾 **Space Complexity (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses O(n) space for stack | 10 | __ |
| No unnecessary data structures | 3 | __ |
| Correctly analyzes space | 2 | __ |

**Subtotal:** __/15

---

### ✍️ **Code Clarity & Style (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses stack data structure explicitly | 4 | __ |
| Clear variable names | 3 | __ |
| Proper mapping dictionary | 3 | __ |
| Clean code structure | 3 | __ |
| Appropriate comments | 2 | __ |

**Subtotal:** __/15

**Best Practices:**
- ✅ Use `stack` (not `s` or `st`)
- ✅ Create `mapping` dictionary for clarity
- ✅ Comment the two cases (opening vs closing)

---

### 🧪 **Tests & Edge Cases (10 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Tests basic valid cases | 2 | __ |
| Tests wrong type: `"(]"` | 3 | __ |
| Tests wrong order: `"([)]"` | 3 | __ |
| Tests only opening/closing | 2 | __ |

**Subtotal:** __/10

**Critical Edge Cases:**
- ✅ Empty string (if constraints allow)
- ✅ Only opening: `"((("`
- ✅ Only closing: `")))"`
- ✅ Single bracket: `"("` or `")"`

---

## 📈 **Bonus/Penalties**

| Item | Points | Your Score |
|------|--------|------------|
| ✅ Solved within time limit (15 min) | +5 | __ |
| ✅ No hints used | +5 | __ |
| ✅ Mentioned LIFO/stack pattern explicitly | +3 | __ |
| ✅ Explained why stack is optimal | +2 | __ |
| ❌ Used Hint 1 | -3 | __ |
| ❌ Used Hint 2 | -5 | __ |
| ❌ Exceeded time limit | -5 | __ |
| ❌ Code crashed on empty stack | -5 | __ |

**Bonus/Penalties:** __

---

## 🏆 **Final Score: __/100**

### Score Interpretation

| Range | Performance | Feedback |
|-------|-------------|----------|
| **90-100** | 🌟 Excellent | Perfect understanding of stack pattern! |
| **75-89** | 👍 Good | Solid solution. Minor edge case or style issues. |
| **60-74** | 🤔 Fair | Got the idea but missed key details. |
| **Below 60** | 📚 Needs Work | Review stack fundamentals. |

---

## 💬 Detailed Feedback

### ✅ What You Did Well
- [ ] Recognized stack pattern immediately
- [ ] Handled both opening and closing brackets correctly
- [ ] Checked for empty stack before popping
- [ ] Verified stack is empty at the end
- [ ] Wrote clean, readable code
- [ ] Tested edge cases thoroughly

### 🔧 Areas for Improvement
- [ ] **Stack Check:** Always check `if not stack` before popping
- [ ] **Mapping:** Use closing→opening mapping (easier for checking)
- [ ] **Edge Cases:** Test empty string, single bracket, only openings
- [ ] **Communication:** Explain "LIFO matches bracket closing order"
- [ ] **Final Check:** Remember to return `len(stack) == 0`, not just `True`

---

## 🎯 Actionable Next Steps

Based on your performance, here are **3 targeted exercises**:

### 1️⃣ **If you struggled with Stack concept:**
   - **Study:** Review stack operations (push, pop, peek)
   - **Practice:** Implement Min Stack (LC #155)
   - **Focus:** Understanding LIFO and when to use stacks

### 2️⃣ **If you missed edge cases:**
   - **Practice:** Create test cases BEFORE coding
   - **Exercise:** For every problem, list 5 edge cases:
     1. Empty input
     2. Single element
     3. All same type
     4. Alternating types
     5. Maximum constraint
   - **Focus:** Systematic edge case analysis

### 3️⃣ **If code clarity was an issue:**
   - **Review:** Python best practices for stack usage
   - **Practice:** Rewrite solution with better names/comments
   - **Focus:** Making code interview-ready

---

## 🔄 Alternative Approaches Discussion

### Approach 1: Stack with Closing→Opening Mapping (Optimal ✅)
```python
def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:  # Closing
            if not stack or stack.pop() != mapping[char]:
                return False
        else:  # Opening
            stack.append(char)
    
    return len(stack) == 0
```
**Pros:** Clean, O(n) time, O(n) space  
**Cons:** None—this is optimal

### Approach 2: Stack with Opening→Closing Mapping
```python
def isValid(s):
    stack = []
    pairs = {'(': ')', '{': '}', '[': ']'}
    
    for char in s:
        if char in pairs:  # Opening
            stack.append(char)
        elif not stack or pairs[stack.pop()] != char:
            return False
    
    return not stack
```
**Pros:** Also valid, slightly different logic  
**Cons:** Must check `pairs[stack.pop()]` instead of `mapping[char]`

### Approach 3: String Replacement (Inefficient ❌)
```python
def isValid_bad(s):
    while '()' in s or '[]' in s or '{}' in s:
        s = s.replace('()', '').replace('[]', '').replace('{}', '')
    return s == ''
```
**Pros:** Intuitive  
**Cons:** O(n²) time complexity—too slow!

---

## 🗣️ Interview Communication Examples

### ❌ Poor Communication
> "I'll use a list... *starts coding immediately*"

**Issues:**
- Didn't identify it as a stack problem
- No explanation of algorithm
- No edge case discussion

### ✅ Strong Communication
> "This is a classic stack problem. The key insight is that brackets must be closed in reverse order—Last In, First Out—which is exactly what a stack provides.
>
> My approach:
> 1. Push all opening brackets onto a stack
> 2. When I see a closing bracket, pop from stack and verify it matches
> 3. At the end, the stack should be empty
>
> Edge cases to consider: empty string, only opening brackets, only closing brackets, and wrong order like `([)]`.
>
> Time: O(n), Space: O(n) for the stack.
>
> Let me code this up..."

**Strengths:**
- Identified pattern (stack/LIFO)
- Clear algorithm steps
- Mentioned edge cases
- Stated complexity

---

## 📚 Key Takeaways for Future Interviews

### 🔑 Stack Pattern Recognition
- **LIFO matching** → Stack
- **Nested structures** → Stack
- **Reverse order processing** → Stack

### 🔑 Implementation Details
1. Always check `if not stack` before popping
2. Map closing→opening for easier validation
3. Final check: stack must be empty

### 🔑 Common Pitfalls
- Forgetting to check stack is empty at the end
- Not handling empty stack before pop
- Wrong mapping direction

---

## 🎯 What's Next?

You've completed **Mock Interview Problem 3 of 5**!

**Your Progress:**
- ✅ Problem 1: Two Sum (Hash Map)
- ✅ Problem 2: Add Two Numbers (Linked List)
- ✅ Problem 3: Valid Parentheses (Stack)
- ⬜ Problem 4: Coming next...
- ⬜ Problem 5: Coming next...

**Your Options:**
1. 📘 **Review Teaching Mode** - Deep dive into stack patterns
2. 🔄 **Continue to Problem 4** - Keep momentum
3. 📊 **Compare all 3 patterns** - Hash Map, Linked List, Stack
4. 🎤 **Request Detailed Feedback** - Analyze your solution

---

<div align="center">

## 🏅 Self-Assessment

**Rate yourself honestly (1-5):**

| Skill | Rating | Notes |
|-------|--------|-------|
| Pattern Recognition | __ | Did I identify the stack pattern? |
| Edge Case Handling | __ | Did I handle empty stack and final check? |
| Code Implementation | __ | Was my code clean and correct? |
| Time Management | __ | Did I finish within 15 minutes? |
| Communication | __ | Did I explain LIFO/stack reasoning? |

**Total Self-Score:** __/25

</div>

---

*Remember: Stack problems are about recognizing LIFO patterns. Once you see it, the implementation is straightforward!* 💪

**Ready for Problem 4?** 🚀
