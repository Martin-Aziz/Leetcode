# ğŸ“˜ Valid Parentheses - Teaching Mode

> **Difficulty:** ğŸŸ¢ Easy  
> **Problem Link:** [LeetCode #20](https://leetcode.com/problems/valid-parentheses/)  
> **Pattern:** Stack / String Processing  
> **Session:** Problem 3 of 5

---

## ğŸ§© Problem Statement

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:
1. Open brackets must be closed by the **same type** of brackets.
2. Open brackets must be closed in the **correct order**.
3. Every close bracket has a corresponding open bracket of the same type.

### ğŸ“ Examples

**Example 1:**
```python
Input: s = "()"
Output: True
```

**Example 2:**
```python
Input: s = "()[]{}"
Output: True
```

**Example 3:**
```python
Input: s = "(]"
Output: False
Explanation: Opening '(' but closing ']' (wrong type)
```

**Example 4:**
```python
Input: s = "([)]"
Output: False
Explanation: Opened '(' then '[', but closed ')' before ']' (wrong order)
```

**Example 5:**
```python
Input: s = "{[]}"
Output: True
Explanation: Properly nested
```

### ğŸ” Input/Output Types
- **Input:** `s` - String containing only bracket characters (`str`)
- **Output:** Boolean - `True` if valid, `False` otherwise (`bool`)

---

## ğŸ§  Understanding the Problem

**What is this problem really asking?**

Think of it like a **matching game**. Every opening bracket needs a partner (a closing bracket of the same type), and they must be matched in the **reverse order** they appear.

**Real-World Analogy:** 
Imagine putting on clothes: you put on socks â†’ shoes â†’ jacket. When you take them off, you must do it in reverse: jacket â†’ shoes â†’ socks. You can't take off shoes before the jacket!

**Key Points:**
- âœ… Each opening bracket needs its matching closing bracket
- âœ… Must close in **reverse order** (LIFO - Last In, First Out)
- âœ… Can't have mismatched types: `(]` is invalid
- âœ… Can't have wrong order: `([)]` is invalid
- âš ï¸ String can be empty (empty string is valid)

**Edge Cases:**
- Empty string: `""` â†’ `True`
- Single bracket: `"("` â†’ `False`
- Only closing brackets: `")"` â†’ `False`
- Only opening brackets: `"((("` â†’ `False`
- Proper nesting: `"{[()]}"` â†’ `True`
- Improper nesting: `"([)]"` â†’ `False`

---

## ğŸ§­ Recognizing the Pattern(s)

### ğŸ¯ Primary Pattern: **Stack (LIFO)**

**Analogy:** Think of a stack of plates. You can only:
- **Push** a plate on top
- **Pop** the top plate off

The last plate you put on is the first one you take off â€” **Last In, First Out (LIFO)**.

For brackets:
- When you see an **opening bracket** â†’ Push it onto the stack
- When you see a **closing bracket** â†’ Pop from stack and check if they match
- If stack is empty at the end â†’ All brackets matched! âœ…

**Why Stack?**
- Brackets must be closed in **reverse order** of opening
- Stack naturally tracks the most recent unmatched opening bracket
- Perfect for nested structures

**Visual Example:**
```
String: "([{}])"

Step 1: '(' â†’ Push '(' â†’ Stack: ['(']
Step 2: '[' â†’ Push '[' â†’ Stack: ['(', '[']
Step 3: '{' â†’ Push '{' â†’ Stack: ['(', '[', '{']
Step 4: '}' â†’ Pop '{', matches! â†’ Stack: ['(', '[']
Step 5: ']' â†’ Pop '[', matches! â†’ Stack: ['(']
Step 6: ')' â†’ Pop '(', matches! â†’ Stack: []

Stack empty â†’ Valid! âœ…
```

---

## ğŸªœ High-Level Plan

### Strategy: Stack-Based Matching

1. **Create an empty stack** to track opening brackets
2. **Create a mapping** of closing â†’ opening brackets
3. **Iterate through each character** in the string:
   - If it's an **opening bracket** `(`, `{`, `[` â†’ Push to stack
   - If it's a **closing bracket** `)`, `}`, `]`:
     - Check if stack is empty â†’ Invalid!
     - Pop from stack
     - Check if popped bracket matches â†’ If not, invalid!
4. **After loop ends**, check if stack is empty:
   - Empty â†’ All matched âœ…
   - Not empty â†’ Unmatched opening brackets âŒ

### ğŸ“‹ Pseudocode

```python
# Step 1: Setup
stack = []
mapping = {')': '(', '}': '{', ']': '['}

# Step 2: Process each character
for char in s:
    if char in mapping:  # Closing bracket
        # Check if we have a matching opening
        if not stack or stack.pop() != mapping[char]:
            return False
    else:  # Opening bracket
        stack.append(char)

# Step 3: Check if all matched
return len(stack) == 0
```

---

## ğŸ’¡ Hints Policy

### ğŸ“ Level 1 Hint (Small Nudge)
<details>
<summary>Click to reveal Level 1 Hint</summary>

Think about the **order** in which brackets must be closed. If you open `(` then `[`, you must close `]` before `)`. What data structure naturally handles **Last In, First Out** (LIFO) behavior?

The key insight: When you see a closing bracket, it must match the **most recent** unmatched opening bracket.

</details>

### ğŸ“ Level 2 Hint (Medium Help)
<details>
<summary>Click to reveal Level 2 Hint</summary>

Use a **stack**!

**Algorithm:**
1. When you see an opening bracket `(`, `{`, `[` â†’ Push it onto the stack
2. When you see a closing bracket `)`, `}`, `]`:
   - Pop from the stack
   - Check if the popped bracket matches the closing one
   - If not, or if stack is empty, return `False`
3. At the end, the stack should be empty (all brackets matched)

Create a dictionary to map closing brackets to their opening counterparts:
```python
mapping = {')': '(', '}': '{', ']': '['}
```

</details>

### ğŸ“ Level 3 Hint (Almost There)
<details>
<summary>Click to reveal Level 3 Hint</summary>

```python
def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:  # It's a closing bracket
            if not stack or stack.pop() != mapping[char]:
                return False
        else:  # It's an opening bracket
            stack.append(char)
    
    return len(stack) == 0
```

**Key tricks:**
- `char in mapping` checks if it's a closing bracket (since mapping only has closing as keys)
- `stack.pop()` removes and returns the top element
- Final check: `len(stack) == 0` ensures no unmatched opening brackets remain

</details>

---

## ğŸ§‘â€ğŸ’» Code Solution (Python)

### âœ¨ Optimal Solution

```python
# Time Complexity: O(n) - Single pass through string
# Space Complexity: O(n) - Stack can hold up to n/2 brackets

def isValid(s):
    """
    Check if string has valid matching brackets.
    
    Args:
        s: String containing only bracket characters
    
    Returns:
        bool: True if valid, False otherwise
    """
    # Step 1: Initialize stack and mapping
    stack = []
    # Map closing brackets to their opening counterparts
    mapping = {
        ')': '(',
        '}': '{',
        ']': '['
    }
    
    # Step 2: Process each character
    for char in s:
        # Case 1: Closing bracket
        if char in mapping:
            # Pop top element (or use dummy if stack empty)
            top_element = stack.pop() if stack else '#'
            
            # Check if it matches the expected opening bracket
            if mapping[char] != top_element:
                return False
        
        # Case 2: Opening bracket
        else:
            stack.append(char)
    
    # Step 3: Valid only if all brackets were matched
    return len(stack) == 0


# âœ… Test Cases
def test_valid_parentheses():
    # Test 1: Simple valid
    assert isValid("()") == True
    print("âœ… Test 1 passed: '()' is valid")
    
    # Test 2: Multiple types
    assert isValid("()[]{}") == True
    print("âœ… Test 2 passed: '()[]{}' is valid")
    
    # Test 3: Wrong type
    assert isValid("(]") == False
    print("âœ… Test 3 passed: '(]' is invalid (wrong type)")
    
    # Test 4: Wrong order
    assert isValid("([)]") == False
    print("âœ… Test 4 passed: '([)]' is invalid (wrong order)")
    
    # Test 5: Properly nested
    assert isValid("{[]}") == True
    print("âœ… Test 5 passed: '{[]}' is valid (nested)")
    
    # Test 6: Empty string
    assert isValid("") == True
    print("âœ… Test 6 passed: '' is valid (empty)")
    
    # Test 7: Only opening
    assert isValid("(((") == False
    print("âœ… Test 7 passed: '(((' is invalid (no closing)")
    
    # Test 8: Only closing
    assert isValid(")))") == False
    print("âœ… Test 8 passed: ')))' is invalid (no opening)")
    
    # Test 9: Complex nested
    assert isValid("({[]})") == True
    print("âœ… Test 9 passed: '({[]})' is valid (complex nesting)")

test_valid_parentheses()
```

### ğŸ”„ Alternative Solution (More Concise)

```python
def isValid_v2(s):
    """More concise version."""
    stack = []
    pairs = {'(': ')', '{': '}', '[': ']'}
    
    for char in s:
        if char in pairs:  # Opening bracket
            stack.append(char)
        elif not stack or pairs[stack.pop()] != char:
            # No match or empty stack
            return False
    
    return not stack  # True if empty


# Test
print(isValid_v2("()[]{}"))  # True
print(isValid_v2("([)]"))    # False
```

---

## ğŸ§© Step-by-Step Explanation

Let's trace through **Example 4:** `s = "([)]"` (should return `False`)

### Initialization
```python
stack = []
mapping = {')': '(', '}': '{', ']': '['}
```

### Iteration 1: `char = '('`
```
'(' is NOT in mapping â†’ It's an opening bracket
Action: Push to stack
stack = ['(']
```

### Iteration 2: `char = '['`
```
'[' is NOT in mapping â†’ It's an opening bracket
Action: Push to stack
stack = ['(', '[']
```

### Iteration 3: `char = ')'`
```
')' IS in mapping â†’ It's a closing bracket
Expected opening: mapping[')'] = '('
Pop from stack: top_element = '['
Check: '(' == '['? NO! âŒ
Return False
```

**Result:** Invalid because `)` tried to match with `[` instead of `(`.

---

### ğŸ¬ Visual Walkthrough (Valid Example)

**Input:** `s = "{[]}"`

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Char: '{'                â”‚
â”‚ Type: Opening            â”‚
â”‚ Action: Push             â”‚
â”‚ Stack: ['{']             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Char: '['                â”‚
â”‚ Type: Opening            â”‚
â”‚ Action: Push             â”‚
â”‚ Stack: ['{', '[']        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Char: ']'                â”‚
â”‚ Type: Closing            â”‚
â”‚ Expected: '['            â”‚
â”‚ Pop: '['                 â”‚
â”‚ Match: âœ…                â”‚
â”‚ Stack: ['{']             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Char: '}'                â”‚
â”‚ Type: Closing            â”‚
â”‚ Expected: '{'            â”‚
â”‚ Pop: '{'                 â”‚
â”‚ Match: âœ…                â”‚
â”‚ Stack: []                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Final check: Stack is empty âœ…
Result: True (Valid!)
```

---

## â±ï¸ Complexity Analysis

### Time Complexity: **O(n)**
- `n` = length of string
- We iterate through each character exactly once
- Stack operations (push/pop) are **O(1)**
- Total: O(n) Ã— O(1) = **O(n)**

### Space Complexity: **O(n)**
- In worst case, all characters are opening brackets
- Example: `"((((("` â†’ Stack will hold all 5 brackets
- Space used by stack: **O(n)**

**Best/Worst Cases:**
- **Best:** Early rejection (e.g., `")"` returns `False` immediately)
- **Worst:** All opening brackets (e.g., `"((((("`) â†’ Must process all, then reject

---

## ğŸ” Variations & Follow-Ups

### ğŸŸ¢ Similar Problems
1. **Min Stack** (LeetCode #155) - Stack with min() operation
   - Same stack pattern, different application

2. **Evaluate Reverse Polish Notation** (LeetCode #150) - Use stack to evaluate expressions
   - Stack for processing nested structures

### ğŸŸ¡ Medium Variations
3. **Generate Parentheses** (LeetCode #22) - Generate all valid combinations
   - Uses backtracking + stack concepts
   - Inverse of validation problem

4. **Remove Invalid Parentheses** (LeetCode #301) - Remove minimum brackets to make valid
   - BFS + stack validation
   - Much harder!

### ğŸ”´ Advanced Applications
5. **Longest Valid Parentheses** (LeetCode #32) - Find longest valid substring
   - DP or stack-based solution
   - Requires tracking positions

6. **Different Ways to Add Parentheses** (LeetCode #241) - Evaluate all parenthesizations
   - Divide and conquer + memoization

**Pattern Evolution:**
- **Validation** (this problem) â†’ Use stack to check
- **Generation** â†’ Use recursion/backtracking with stack validation
- **Optimization** â†’ Dynamic programming with stack concepts

---

## ğŸ§© Reflection & Reinforcement

### ğŸ“š Check Your Understanding

<details>
<summary><b>Question 1:</b> Why do we use a stack instead of a counter?</summary>

**Answer:** A counter can't track **types** and **order**. Consider `"([)]"`:
- Counter would say: 2 opening, 2 closing â†’ Balanced âœ…
- But it's actually invalid because of wrong order âŒ

Stack tracks **which specific bracket** needs to be closed next, not just how many.

</details>

<details>
<summary><b>Question 2:</b> What happens if we check `if not stack` before popping?</summary>

**Answer:** We avoid a **crash**! If stack is empty and we try to `pop()`, Python raises an `IndexError`. The check:
```python
if not stack or stack.pop() != mapping[char]:
    return False
```
Uses **short-circuit evaluation**: if `not stack` is `True`, it doesn't even try to pop.

Alternative approach:
```python
top_element = stack.pop() if stack else '#'
```
Uses a dummy value if stack is empty.

</details>

<details>
<summary><b>Question 3:</b> Can we solve this without a stack?</summary>

**Answer:** Not efficiently for the general case. You could use:
1. **Recursion** (which uses the call stack anyway)
2. **String replacement** (repeatedly remove `()`, `{}`, `[]` until empty) â†’ O(nÂ²) time

Stack is the optimal O(n) solution.

</details>

---

## ğŸ¯ Practice Problems (Similar Pattern)

Here are 3 problems using the **Stack Pattern**:

1. **Min Stack** (LeetCode #155) - Easy ğŸŸ¢
   - *Why:* Implement stack with additional min() operation
   - *Skill:* Understanding stack invariants and auxiliary structures

2. **Baseball Game** (LeetCode #682) - Easy ğŸŸ¢
   - *Why:* Process operations using a stack
   - *Skill:* Stack for sequential operations

3. **Daily Temperatures** (LeetCode #739) - Medium ğŸŸ¡
   - *Why:* Use stack to track waiting elements
   - *Skill:* Monotonic stack pattern (important!)

**For String + Stack:**
4. **Simplify Path** (LeetCode #71) - Medium ğŸŸ¡
   - *Why:* Parse Unix paths using stack
   - *Skill:* String parsing + stack navigation

---

## ğŸ’¬ Interview Mindset Tips

### ğŸ™ï¸ 1. **Think Aloud - Recognize the Pattern**
- Start with: *"I notice this is about matching pairs in reverse orderâ€”that suggests a stack..."*
- Verbalize: *"When I see an opening bracket, I'll push it. When I see a closing bracket, I need to check if it matches the most recent opening..."*
- Show pattern recognition: *"This is a classic stack problem because of the Last In, First Out matching requirement."*

### â° 2. **Manage Time - Start Simple**
- Spend 1-2 minutes confirming understanding:
  - *"So `([)]` is invalid because we opened `(` then `[`, but closed `)` before `]`?"*
- Quick plan: *"I'll use a stack and a mapping dictionary..."*
- Code efficientlyâ€”this is a straightforward problem once you see the pattern

### ğŸ§ª 3. **Test Edge Cases**
Before coding, mention:
- *"I should test: empty string, only opening brackets, only closing brackets, and wrong order."*

After coding:
```python
# Empty
isValid("")        # True
# Only opening
isValid("(((")     # False
# Only closing  
isValid(")))")     # False
# Wrong type
isValid("(]")      # False
# Wrong order
isValid("([)]")    # False
# Valid nested
isValid("({[]})")  # True
```

### âš–ï¸ 4. **Compare Trade-offs**
- *"I could repeatedly remove valid pairs from the string (like `()`, `{}`, `[]`) until it's empty, but that would be O(nÂ²). The stack approach is O(n) with one pass."*
- Shows you consider alternatives

---

## âœ… Summary Checklist

Before moving to the next problem, make sure you can:

- [ ] Explain why stack is the right data structure (LIFO matches bracket closing order)
- [ ] Implement the solution without looking
- [ ] Identify when to push vs pop
- [ ] Handle the edge case of empty stack (closing bracket with no opening)
- [ ] Check final stack is empty (no unmatched opening brackets)
- [ ] Recognize this pattern in other problems

---

## ğŸ¯ Next Steps

You've completed **Problem 3 of 5** in this session! ğŸ‰

**Progress Check:**
- âœ… Problem 1: Two Sum (Hash Map)
- âœ… Problem 2: Add Two Numbers (Linked List)
- âœ… Problem 3: Valid Parentheses (Stack)
- â¬œ Problem 4: Coming next...
- â¬œ Problem 5: Coming next...

**Choose your next action:**

1. ğŸ”„ **Continue with Problem 4** - Keep the momentum!
2. ğŸ¤ **Try Mock Interview Mode** - Test under pressure
3. ğŸ“ **Review all 3 patterns** - Hash Map, Linked List, Stack
4. ğŸ§  **Take a break** - Process what you've learned

*When you're ready, let me know!*

---

<div align="center">

**Happy Coding! ğŸš€**

*Stack is your friend for nested structures!*

</div>
