# 📘 Valid Parentheses - Teaching Mode

> **Difficulty:** 🟢 Easy  
> **Problem Link:** [LeetCode #20](https://leetcode.com/problems/valid-parentheses/)  
> **Pattern:** Stack / String Processing  
> **Session:** Problem 3 of 5

---

## 🧩 Problem Statement

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:
1. Open brackets must be closed by the **same type** of brackets.
2. Open brackets must be closed in the **correct order**.
3. Every close bracket has a corresponding open bracket of the same type.

### 📝 Examples

**Example 1:**
```python
Input: s = "()"
Output: True
```

**Example 2:**
```python
Input: s = "()[]{}"
Output: True
```

**Example 3:**
```python
Input: s = "(]"
Output: False
Explanation: Opening '(' but closing ']' (wrong type)
```

**Example 4:**
```python
Input: s = "([)]"
Output: False
Explanation: Opened '(' then '[', but closed ')' before ']' (wrong order)
```

**Example 5:**
```python
Input: s = "{[]}"
Output: True
Explanation: Properly nested
```

### 🔍 Input/Output Types
- **Input:** `s` - String containing only bracket characters (`str`)
- **Output:** Boolean - `True` if valid, `False` otherwise (`bool`)

---

## 🧠 Understanding the Problem

**What is this problem really asking?**

Think of it like a **matching game**. Every opening bracket needs a partner (a closing bracket of the same type), and they must be matched in the **reverse order** they appear.

**Real-World Analogy:** 
Imagine putting on clothes: you put on socks → shoes → jacket. When you take them off, you must do it in reverse: jacket → shoes → socks. You can't take off shoes before the jacket!

**Key Points:**
- ✅ Each opening bracket needs its matching closing bracket
- ✅ Must close in **reverse order** (LIFO - Last In, First Out)
- ✅ Can't have mismatched types: `(]` is invalid
- ✅ Can't have wrong order: `([)]` is invalid
- ⚠️ String can be empty (empty string is valid)

**Edge Cases:**
- Empty string: `""` → `True`
- Single bracket: `"("` → `False`
- Only closing brackets: `")"` → `False`
- Only opening brackets: `"((("` → `False`
- Proper nesting: `"{[()]}"` → `True`
- Improper nesting: `"([)]"` → `False`

---

## 🧭 Recognizing the Pattern(s)

### 🎯 Primary Pattern: **Stack (LIFO)**

**Analogy:** Think of a stack of plates. You can only:
- **Push** a plate on top
- **Pop** the top plate off

The last plate you put on is the first one you take off — **Last In, First Out (LIFO)**.

For brackets:
- When you see an **opening bracket** → Push it onto the stack
- When you see a **closing bracket** → Pop from stack and check if they match
- If stack is empty at the end → All brackets matched! ✅

**Why Stack?**
- Brackets must be closed in **reverse order** of opening
- Stack naturally tracks the most recent unmatched opening bracket
- Perfect for nested structures

**Visual Example:**
```
String: "([{}])"

Step 1: '(' → Push '(' → Stack: ['(']
Step 2: '[' → Push '[' → Stack: ['(', '[']
Step 3: '{' → Push '{' → Stack: ['(', '[', '{']
Step 4: '}' → Pop '{', matches! → Stack: ['(', '[']
Step 5: ']' → Pop '[', matches! → Stack: ['(']
Step 6: ')' → Pop '(', matches! → Stack: []

Stack empty → Valid! ✅
```

---

## 🪜 High-Level Plan

### Strategy: Stack-Based Matching

1. **Create an empty stack** to track opening brackets
2. **Create a mapping** of closing → opening brackets
3. **Iterate through each character** in the string:
   - If it's an **opening bracket** `(`, `{`, `[` → Push to stack
   - If it's a **closing bracket** `)`, `}`, `]`:
     - Check if stack is empty → Invalid!
     - Pop from stack
     - Check if popped bracket matches → If not, invalid!
4. **After loop ends**, check if stack is empty:
   - Empty → All matched ✅
   - Not empty → Unmatched opening brackets ❌

### 📋 Pseudocode

```python
# Step 1: Setup
stack = []
mapping = {')': '(', '}': '{', ']': '['}

# Step 2: Process each character
for char in s:
    if char in mapping:  # Closing bracket
        # Check if we have a matching opening
        if not stack or stack.pop() != mapping[char]:
            return False
    else:  # Opening bracket
        stack.append(char)

# Step 3: Check if all matched
return len(stack) == 0
```

---

## 💡 Hints Policy

### 🎓 Level 1 Hint (Small Nudge)
<details>
<summary>Click to reveal Level 1 Hint</summary>

Think about the **order** in which brackets must be closed. If you open `(` then `[`, you must close `]` before `)`. What data structure naturally handles **Last In, First Out** (LIFO) behavior?

The key insight: When you see a closing bracket, it must match the **most recent** unmatched opening bracket.

</details>

### 🎓 Level 2 Hint (Medium Help)
<details>
<summary>Click to reveal Level 2 Hint</summary>

Use a **stack**!

**Algorithm:**
1. When you see an opening bracket `(`, `{`, `[` → Push it onto the stack
2. When you see a closing bracket `)`, `}`, `]`:
   - Pop from the stack
   - Check if the popped bracket matches the closing one
   - If not, or if stack is empty, return `False`
3. At the end, the stack should be empty (all brackets matched)

Create a dictionary to map closing brackets to their opening counterparts:
```python
mapping = {')': '(', '}': '{', ']': '['}
```

</details>

### 🎓 Level 3 Hint (Almost There)
<details>
<summary>Click to reveal Level 3 Hint</summary>

```python
def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:  # It's a closing bracket
            if not stack or stack.pop() != mapping[char]:
                return False
        else:  # It's an opening bracket
            stack.append(char)
    
    return len(stack) == 0
```

**Key tricks:**
- `char in mapping` checks if it's a closing bracket (since mapping only has closing as keys)
- `stack.pop()` removes and returns the top element
- Final check: `len(stack) == 0` ensures no unmatched opening brackets remain

</details>

---

## 🧑‍💻 Code Solution (Python)

### ✨ Optimal Solution

```python
# Time Complexity: O(n) - Single pass through string
# Space Complexity: O(n) - Stack can hold up to n/2 brackets

def isValid(s):
    """
    Check if string has valid matching brackets.
    
    Args:
        s: String containing only bracket characters
    
    Returns:
        bool: True if valid, False otherwise
    """
    # Step 1: Initialize stack and mapping
    stack = []
    # Map closing brackets to their opening counterparts
    mapping = {
        ')': '(',
        '}': '{',
        ']': '['
    }
    
    # Step 2: Process each character
    for char in s:
        # Case 1: Closing bracket
        if char in mapping:
            # Pop top element (or use dummy if stack empty)
            top_element = stack.pop() if stack else '#'
            
            # Check if it matches the expected opening bracket
            if mapping[char] != top_element:
                return False
        
        # Case 2: Opening bracket
        else:
            stack.append(char)
    
    # Step 3: Valid only if all brackets were matched
    return len(stack) == 0


# ✅ Test Cases
def test_valid_parentheses():
    # Test 1: Simple valid
    assert isValid("()") == True
    print("✅ Test 1 passed: '()' is valid")
    
    # Test 2: Multiple types
    assert isValid("()[]{}") == True
    print("✅ Test 2 passed: '()[]{}' is valid")
    
    # Test 3: Wrong type
    assert isValid("(]") == False
    print("✅ Test 3 passed: '(]' is invalid (wrong type)")
    
    # Test 4: Wrong order
    assert isValid("([)]") == False
    print("✅ Test 4 passed: '([)]' is invalid (wrong order)")
    
    # Test 5: Properly nested
    assert isValid("{[]}") == True
    print("✅ Test 5 passed: '{[]}' is valid (nested)")
    
    # Test 6: Empty string
    assert isValid("") == True
    print("✅ Test 6 passed: '' is valid (empty)")
    
    # Test 7: Only opening
    assert isValid("(((") == False
    print("✅ Test 7 passed: '(((' is invalid (no closing)")
    
    # Test 8: Only closing
    assert isValid(")))") == False
    print("✅ Test 8 passed: ')))' is invalid (no opening)")
    
    # Test 9: Complex nested
    assert isValid("({[]})") == True
    print("✅ Test 9 passed: '({[]})' is valid (complex nesting)")

test_valid_parentheses()
```

### 🔄 Alternative Solution (More Concise)

```python
def isValid_v2(s):
    """More concise version."""
    stack = []
    pairs = {'(': ')', '{': '}', '[': ']'}
    
    for char in s:
        if char in pairs:  # Opening bracket
            stack.append(char)
        elif not stack or pairs[stack.pop()] != char:
            # No match or empty stack
            return False
    
    return not stack  # True if empty


# Test
print(isValid_v2("()[]{}"))  # True
print(isValid_v2("([)]"))    # False
```

---

## 🧩 Step-by-Step Explanation

Let's trace through **Example 4:** `s = "([)]"` (should return `False`)

### Initialization
```python
stack = []
mapping = {')': '(', '}': '{', ']': '['}
```

### Iteration 1: `char = '('`
```
'(' is NOT in mapping → It's an opening bracket
Action: Push to stack
stack = ['(']
```

### Iteration 2: `char = '['`
```
'[' is NOT in mapping → It's an opening bracket
Action: Push to stack
stack = ['(', '[']
```

### Iteration 3: `char = ')'`
```
')' IS in mapping → It's a closing bracket
Expected opening: mapping[')'] = '('
Pop from stack: top_element = '['
Check: '(' == '['? NO! ❌
Return False
```

**Result:** Invalid because `)` tried to match with `[` instead of `(`.

---

### 🎬 Visual Walkthrough (Valid Example)

**Input:** `s = "{[]}"`

```
┌──────────────────────────┐
│ Char: '{'                │
│ Type: Opening            │
│ Action: Push             │
│ Stack: ['{']             │
└──────────────────────────┘

┌──────────────────────────┐
│ Char: '['                │
│ Type: Opening            │
│ Action: Push             │
│ Stack: ['{', '[']        │
└──────────────────────────┘

┌──────────────────────────┐
│ Char: ']'                │
│ Type: Closing            │
│ Expected: '['            │
│ Pop: '['                 │
│ Match: ✅                │
│ Stack: ['{']             │
└──────────────────────────┘

┌──────────────────────────┐
│ Char: '}'                │
│ Type: Closing            │
│ Expected: '{'            │
│ Pop: '{'                 │
│ Match: ✅                │
│ Stack: []                │
└──────────────────────────┘

Final check: Stack is empty ✅
Result: True (Valid!)
```

---

## ⏱️ Complexity Analysis

### Time Complexity: **O(n)**
- `n` = length of string
- We iterate through each character exactly once
- Stack operations (push/pop) are **O(1)**
- Total: O(n) × O(1) = **O(n)**

### Space Complexity: **O(n)**
- In worst case, all characters are opening brackets
- Example: `"((((("` → Stack will hold all 5 brackets
- Space used by stack: **O(n)**

**Best/Worst Cases:**
- **Best:** Early rejection (e.g., `")"` returns `False` immediately)
- **Worst:** All opening brackets (e.g., `"((((("`) → Must process all, then reject

---

## 🔁 Variations & Follow-Ups

### 🟢 Similar Problems
1. **Min Stack** (LeetCode #155) - Stack with min() operation
   - Same stack pattern, different application

2. **Evaluate Reverse Polish Notation** (LeetCode #150) - Use stack to evaluate expressions
   - Stack for processing nested structures

### 🟡 Medium Variations
3. **Generate Parentheses** (LeetCode #22) - Generate all valid combinations
   - Uses backtracking + stack concepts
   - Inverse of validation problem

4. **Remove Invalid Parentheses** (LeetCode #301) - Remove minimum brackets to make valid
   - BFS + stack validation
   - Much harder!

### 🔴 Advanced Applications
5. **Longest Valid Parentheses** (LeetCode #32) - Find longest valid substring
   - DP or stack-based solution
   - Requires tracking positions

6. **Different Ways to Add Parentheses** (LeetCode #241) - Evaluate all parenthesizations
   - Divide and conquer + memoization

**Pattern Evolution:**
- **Validation** (this problem) → Use stack to check
- **Generation** → Use recursion/backtracking with stack validation
- **Optimization** → Dynamic programming with stack concepts

---

## 🧩 Reflection & Reinforcement

### 📚 Check Your Understanding

<details>
<summary><b>Question 1:</b> Why do we use a stack instead of a counter?</summary>

**Answer:** A counter can't track **types** and **order**. Consider `"([)]"`:
- Counter would say: 2 opening, 2 closing → Balanced ✅
- But it's actually invalid because of wrong order ❌

Stack tracks **which specific bracket** needs to be closed next, not just how many.

</details>

<details>
<summary><b>Question 2:</b> What happens if we check `if not stack` before popping?</summary>

**Answer:** We avoid a **crash**! If stack is empty and we try to `pop()`, Python raises an `IndexError`. The check:
```python
if not stack or stack.pop() != mapping[char]:
    return False
```
Uses **short-circuit evaluation**: if `not stack` is `True`, it doesn't even try to pop.

Alternative approach:
```python
top_element = stack.pop() if stack else '#'
```
Uses a dummy value if stack is empty.

</details>

<details>
<summary><b>Question 3:</b> Can we solve this without a stack?</summary>

**Answer:** Not efficiently for the general case. You could use:
1. **Recursion** (which uses the call stack anyway)
2. **String replacement** (repeatedly remove `()`, `{}`, `[]` until empty) → O(n²) time

Stack is the optimal O(n) solution.

</details>

---

## 🎯 Practice Problems (Similar Pattern)

Here are 3 problems using the **Stack Pattern**:

1. **Min Stack** (LeetCode #155) - Easy 🟢
   - *Why:* Implement stack with additional min() operation
   - *Skill:* Understanding stack invariants and auxiliary structures

2. **Baseball Game** (LeetCode #682) - Easy 🟢
   - *Why:* Process operations using a stack
   - *Skill:* Stack for sequential operations

3. **Daily Temperatures** (LeetCode #739) - Medium 🟡
   - *Why:* Use stack to track waiting elements
   - *Skill:* Monotonic stack pattern (important!)

**For String + Stack:**
4. **Simplify Path** (LeetCode #71) - Medium 🟡
   - *Why:* Parse Unix paths using stack
   - *Skill:* String parsing + stack navigation

---

## 💬 Interview Mindset Tips

### 🎙️ 1. **Think Aloud - Recognize the Pattern**
- Start with: *"I notice this is about matching pairs in reverse order—that suggests a stack..."*
- Verbalize: *"When I see an opening bracket, I'll push it. When I see a closing bracket, I need to check if it matches the most recent opening..."*
- Show pattern recognition: *"This is a classic stack problem because of the Last In, First Out matching requirement."*

### ⏰ 2. **Manage Time - Start Simple**
- Spend 1-2 minutes confirming understanding:
  - *"So `([)]` is invalid because we opened `(` then `[`, but closed `)` before `]`?"*
- Quick plan: *"I'll use a stack and a mapping dictionary..."*
- Code efficiently—this is a straightforward problem once you see the pattern

### 🧪 3. **Test Edge Cases**
Before coding, mention:
- *"I should test: empty string, only opening brackets, only closing brackets, and wrong order."*

After coding:
```python
# Empty
isValid("")        # True
# Only opening
isValid("(((")     # False
# Only closing  
isValid(")))")     # False
# Wrong type
isValid("(]")      # False
# Wrong order
isValid("([)]")    # False
# Valid nested
isValid("({[]})")  # True
```

### ⚖️ 4. **Compare Trade-offs**
- *"I could repeatedly remove valid pairs from the string (like `()`, `{}`, `[]`) until it's empty, but that would be O(n²). The stack approach is O(n) with one pass."*
- Shows you consider alternatives

---

## ✅ Summary Checklist

Before moving to the next problem, make sure you can:

- [ ] Explain why stack is the right data structure (LIFO matches bracket closing order)
- [ ] Implement the solution without looking
- [ ] Identify when to push vs pop
- [ ] Handle the edge case of empty stack (closing bracket with no opening)
- [ ] Check final stack is empty (no unmatched opening brackets)
- [ ] Recognize this pattern in other problems

---

## 🎯 Next Steps

You've completed **Problem 3 of 5** in this session! 🎉

**Progress Check:**
- ✅ Problem 1: Two Sum (Hash Map)
- ✅ Problem 2: Add Two Numbers (Linked List)
- ✅ Problem 3: Valid Parentheses (Stack)
- ⬜ Problem 4: Coming next...
- ⬜ Problem 5: Coming next...

**Choose your next action:**

1. 🔄 **Continue with Problem 4** - Keep the momentum!
2. 🎤 **Try Mock Interview Mode** - Test under pressure
3. 📝 **Review all 3 patterns** - Hash Map, Linked List, Stack
4. 🧠 **Take a break** - Process what you've learned

*When you're ready, let me know!*

---

<div align="center">

**Happy Coding! 🚀**

*Stack is your friend for nested structures!*

</div>
