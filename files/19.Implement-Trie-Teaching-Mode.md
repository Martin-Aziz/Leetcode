# ðŸŽ¯ Problem 19: Implement Trie (Prefix Tree)

**Difficulty:** ðŸŸ¡ Medium  
**Pattern:** Design / Tree / String  
**LeetCode Link:** [#208 Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/)

---

## ðŸ“‹ Problem Statement

Implement a **trie** (prefix tree) with the following operations:

- `Trie()` Initializes the trie object
- `void insert(String word)` Inserts string `word` into the trie
- `boolean search(String word)` Returns `true` if `word` is in the trie
- `boolean startsWith(String prefix)` Returns `true` if any word starts with `prefix`

### Example:

```python
trie = Trie()
trie.insert("apple")
trie.search("apple")   # True
trie.search("app")     # False
trie.startsWith("app") # True
trie.insert("app")
trie.search("app")     # True
```

---

## ðŸŽ“ Understanding

### What is a Trie?

A **trie** (pronounced "try") is a tree where:
- Each node represents a character
- Paths from root spell out words
- Each node can have up to 26 children (for lowercase English letters)

```
Example: ["cat", "car", "dog"]

       root
      /    \
     c      d
     |      |
     a      o
    / \     |
   t   r    g
  [*] [*]  [*]

[*] = end of word marker
```

---

## ðŸ” Solution: TrieNode Design

```python
class TrieNode:
    """Node in the trie."""
    def __init__(self):
        self.children = {}  # char -> TrieNode
        self.is_end_of_word = False


class Trie:
    """
    Trie (Prefix Tree) implementation.
    
    Operations:
    - insert: O(m) where m = word length
    - search: O(m)
    - startsWith: O(m)
    Space: O(n * m) where n = number of words
    """
    
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """Insert a word into the trie."""
        node = self.root
        
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        
        node.is_end_of_word = True
    
    def search(self, word: str) -> bool:
        """Check if word exists in trie."""
        node = self.root
        
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return node.is_end_of_word
    
    def startsWith(self, prefix: str) -> bool:
        """Check if any word starts with prefix."""
        node = self.root
        
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return True
```

---

## ðŸ“Š Step-by-Step Example

### Insert "cat"

```
1. Start at root
2. 'c' not in children â†’ create new node
3. Move to 'c' node
4. 'a' not in children â†’ create new node
5. Move to 'a' node
6. 't' not in children â†’ create new node
7. Move to 't' node
8. Mark as end of word

Result:
    root
     |
     c
     |
     a
     |
     t [*]
```

### Insert "car" (after "cat")

```
1. Start at root
2. 'c' exists â†’ move to 'c'
3. 'a' exists â†’ move to 'a'
4. 'r' not in children â†’ create new node
5. Move to 'r' node
6. Mark as end of word

Result:
    root
     |
     c
     |
     a
    / \
   t   r
  [*] [*]
```

### Search "car"

```
1. Start at root
2. 'c' exists â†’ move to 'c'
3. 'a' exists â†’ move to 'a'
4. 'r' exists â†’ move to 'r'
5. Check is_end_of_word â†’ True âœ…

Return True
```

### Search "ca"

```
1. Start at root
2. 'c' exists â†’ move to 'c'
3. 'a' exists â†’ move to 'a'
4. Check is_end_of_word â†’ False âŒ

Return False (prefix exists but not a word)
```

### StartsWith "ca"

```
1. Start at root
2. 'c' exists â†’ move to 'c'
3. 'a' exists â†’ move to 'a'
4. All chars found â†’ True âœ…

Return True (we don't check is_end_of_word)
```

---

## ðŸ”„ Alternative: Array-Based Children

```python
class TrieNode:
    """Array-based for lowercase letters only."""
    def __init__(self):
        self.children = [None] * 26  # a-z
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def _char_to_index(self, char):
        return ord(char) - ord('a')
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            index = self._char_to_index(char)
            if not node.children[index]:
                node.children[index] = TrieNode()
            node = node.children[index]
        node.is_end_of_word = True
    
    def search(self, word: str) -> bool:
        node = self.root
        for char in word:
            index = self._char_to_index(char)
            if not node.children[index]:
                return False
            node = node.children[index]
        return node.is_end_of_word
    
    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            index = self._char_to_index(char)
            if not node.children[index]:
                return False
            node = node.children[index]
        return True
```

---

## âš¡ Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| insert | O(m) | O(m) | m = word length |
| search | O(m) | O(1) | No extra space |
| startsWith | O(m) | O(1) | No extra space |
| **Total Space** | - | O(n Ã— m Ã— 26) | Worst case |

**Dict vs Array:**
- **Dict (HashMap):** Flexible, handles any characters, sparse
- **Array:** Fixed size 26, faster access, more memory if sparse

---

## ðŸŽ¯ Key Patterns

### Pattern 1: Traversing Trie
```python
node = self.root
for char in word:
    if char not in node.children:
        return False
    node = node.children[char]
```

### Pattern 2: End of Word vs Prefix
```python
# search: must be end of word
return node.is_end_of_word

# startsWith: just need to reach end of prefix
return True
```

### Pattern 3: Creating Nodes
```python
if char not in node.children:
    node.children[char] = TrieNode()
node = node.children[char]
```

---

## ðŸ› Common Mistakes

### âŒ Mistake 1: Forgetting End Marker
```python
# WRONG - "cat" and "ca" both return True
def search(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            return False
        node = node.children[char]
    return True  # Missing is_end_of_word check!
```

### âŒ Mistake 2: Modifying Root
```python
# WRONG - loses reference to root
def insert(self, word):
    self.root = self.root.children.get(word[0], TrieNode())
```

### âŒ Mistake 3: Confusing search vs startsWith
```python
# They're different!
search("app")      # Must be complete word
startsWith("app")  # Just needs prefix
```

---

## ðŸŽ¯ Practice Problems

1. **[LeetCode 211] Design Add and Search Words Data Structure** (Medium)
2. **[LeetCode 212] Word Search II** (Hard) - Use Trie!
3. **[LeetCode 648] Replace Words** (Medium)
4. **[LeetCode 677] Map Sum Pairs** (Medium)
5. **[LeetCode 720] Longest Word in Dictionary** (Medium)

---

## ðŸ† Key Takeaways

1. **Trie** is a tree where each path represents a string
2. **Each node** has children map/array and `is_end_of_word` flag
3. **All operations** are O(m) where m = string length
4. **Dict vs Array:** Dict for flexibility, Array for speed
5. **Use case:** Autocomplete, spell check, IP routing

---

## ðŸ’¡ Interview Tips

**When to use a Trie:**
- **Prefix matching** (autocomplete, spell check)
- **Word lookup** with many queries
- **Space optimization** for shared prefixes

**Trie vs HashMap:**
- **HashMap:** O(1) exact lookup, no prefix support
- **Trie:** O(m) lookup, excellent for prefix queries

**Follow-ups:**
- "How would you delete a word?"
- "How would you implement autocomplete?"
- "What if words contain uppercase/special chars?"

---

## ðŸ”§ Advanced: Delete Operation

```python
def delete(self, word: str) -> bool:
    """Delete a word from trie. Returns True if deleted."""
    
    def _delete(node, word, index):
        if index == len(word):
            if not node.is_end_of_word:
                return False  # Word not in trie
            node.is_end_of_word = False
            return len(node.children) == 0  # Can delete if no children
        
        char = word[index]
        if char not in node.children:
            return False
        
        child = node.children[char]
        should_delete_child = _delete(child, word, index + 1)
        
        if should_delete_child:
            del node.children[char]
            return not node.is_end_of_word and len(node.children) == 0
        
        return False
    
    return _delete(self.root, word, 0)
```

---

**Ready to test?** ðŸš€ Move to **`19.Implement-Trie-Mock-Interview-Mode.md`**

*Happy Coding! ðŸ’»âœ¨*
