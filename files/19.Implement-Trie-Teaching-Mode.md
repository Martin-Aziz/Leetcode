# 🎯 Problem 19: Implement Trie (Prefix Tree)

**Difficulty:** 🟡 Medium  
**Pattern:** Design / Tree / String  
**LeetCode Link:** [#208 Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/)

---

## 📋 Problem Statement

Implement a **trie** (prefix tree) with the following operations:

- `Trie()` Initializes the trie object
- `void insert(String word)` Inserts string `word` into the trie
- `boolean search(String word)` Returns `true` if `word` is in the trie
- `boolean startsWith(String prefix)` Returns `true` if any word starts with `prefix`

### Example:

```python
trie = Trie()
trie.insert("apple")
trie.search("apple")   # True
trie.search("app")     # False
trie.startsWith("app") # True
trie.insert("app")
trie.search("app")     # True
```

---

## 🎓 Understanding

### What is a Trie?

A **trie** (pronounced "try") is a tree where:
- Each node represents a character
- Paths from root spell out words
- Each node can have up to 26 children (for lowercase English letters)

```
Example: ["cat", "car", "dog"]

       root
      /    \
     c      d
     |      |
     a      o
    / \     |
   t   r    g
  [*] [*]  [*]

[*] = end of word marker
```

---

## 🔍 Solution: TrieNode Design

```python
class TrieNode:
    """Node in the trie."""
    def __init__(self):
        self.children = {}  # char -> TrieNode
        self.is_end_of_word = False


class Trie:
    """
    Trie (Prefix Tree) implementation.
    
    Operations:
    - insert: O(m) where m = word length
    - search: O(m)
    - startsWith: O(m)
    Space: O(n * m) where n = number of words
    """
    
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """Insert a word into the trie."""
        node = self.root
        
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        
        node.is_end_of_word = True
    
    def search(self, word: str) -> bool:
        """Check if word exists in trie."""
        node = self.root
        
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return node.is_end_of_word
    
    def startsWith(self, prefix: str) -> bool:
        """Check if any word starts with prefix."""
        node = self.root
        
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return True
```

---

## 📊 Step-by-Step Example

### Insert "cat"

```
1. Start at root
2. 'c' not in children → create new node
3. Move to 'c' node
4. 'a' not in children → create new node
5. Move to 'a' node
6. 't' not in children → create new node
7. Move to 't' node
8. Mark as end of word

Result:
    root
     |
     c
     |
     a
     |
     t [*]
```

### Insert "car" (after "cat")

```
1. Start at root
2. 'c' exists → move to 'c'
3. 'a' exists → move to 'a'
4. 'r' not in children → create new node
5. Move to 'r' node
6. Mark as end of word

Result:
    root
     |
     c
     |
     a
    / \
   t   r
  [*] [*]
```

### Search "car"

```
1. Start at root
2. 'c' exists → move to 'c'
3. 'a' exists → move to 'a'
4. 'r' exists → move to 'r'
5. Check is_end_of_word → True ✅

Return True
```

### Search "ca"

```
1. Start at root
2. 'c' exists → move to 'c'
3. 'a' exists → move to 'a'
4. Check is_end_of_word → False ❌

Return False (prefix exists but not a word)
```

### StartsWith "ca"

```
1. Start at root
2. 'c' exists → move to 'c'
3. 'a' exists → move to 'a'
4. All chars found → True ✅

Return True (we don't check is_end_of_word)
```

---

## 🔄 Alternative: Array-Based Children

```python
class TrieNode:
    """Array-based for lowercase letters only."""
    def __init__(self):
        self.children = [None] * 26  # a-z
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def _char_to_index(self, char):
        return ord(char) - ord('a')
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            index = self._char_to_index(char)
            if not node.children[index]:
                node.children[index] = TrieNode()
            node = node.children[index]
        node.is_end_of_word = True
    
    def search(self, word: str) -> bool:
        node = self.root
        for char in word:
            index = self._char_to_index(char)
            if not node.children[index]:
                return False
            node = node.children[index]
        return node.is_end_of_word
    
    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            index = self._char_to_index(char)
            if not node.children[index]:
                return False
            node = node.children[index]
        return True
```

---

## ⚡ Complexity Analysis

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| insert | O(m) | O(m) | m = word length |
| search | O(m) | O(1) | No extra space |
| startsWith | O(m) | O(1) | No extra space |
| **Total Space** | - | O(n × m × 26) | Worst case |

**Dict vs Array:**
- **Dict (HashMap):** Flexible, handles any characters, sparse
- **Array:** Fixed size 26, faster access, more memory if sparse

---

## 🎯 Key Patterns

### Pattern 1: Traversing Trie
```python
node = self.root
for char in word:
    if char not in node.children:
        return False
    node = node.children[char]
```

### Pattern 2: End of Word vs Prefix
```python
# search: must be end of word
return node.is_end_of_word

# startsWith: just need to reach end of prefix
return True
```

### Pattern 3: Creating Nodes
```python
if char not in node.children:
    node.children[char] = TrieNode()
node = node.children[char]
```

---

## 🐛 Common Mistakes

### ❌ Mistake 1: Forgetting End Marker
```python
# WRONG - "cat" and "ca" both return True
def search(self, word):
    node = self.root
    for char in word:
        if char not in node.children:
            return False
        node = node.children[char]
    return True  # Missing is_end_of_word check!
```

### ❌ Mistake 2: Modifying Root
```python
# WRONG - loses reference to root
def insert(self, word):
    self.root = self.root.children.get(word[0], TrieNode())
```

### ❌ Mistake 3: Confusing search vs startsWith
```python
# They're different!
search("app")      # Must be complete word
startsWith("app")  # Just needs prefix
```

---

## 🎯 Practice Problems

1. **[LeetCode 211] Design Add and Search Words Data Structure** (Medium)
2. **[LeetCode 212] Word Search II** (Hard) - Use Trie!
3. **[LeetCode 648] Replace Words** (Medium)
4. **[LeetCode 677] Map Sum Pairs** (Medium)
5. **[LeetCode 720] Longest Word in Dictionary** (Medium)

---

## 🏆 Key Takeaways

1. **Trie** is a tree where each path represents a string
2. **Each node** has children map/array and `is_end_of_word` flag
3. **All operations** are O(m) where m = string length
4. **Dict vs Array:** Dict for flexibility, Array for speed
5. **Use case:** Autocomplete, spell check, IP routing

---

## 💡 Interview Tips

**When to use a Trie:**
- **Prefix matching** (autocomplete, spell check)
- **Word lookup** with many queries
- **Space optimization** for shared prefixes

**Trie vs HashMap:**
- **HashMap:** O(1) exact lookup, no prefix support
- **Trie:** O(m) lookup, excellent for prefix queries

**Follow-ups:**
- "How would you delete a word?"
- "How would you implement autocomplete?"
- "What if words contain uppercase/special chars?"

---

## 🔧 Advanced: Delete Operation

```python
def delete(self, word: str) -> bool:
    """Delete a word from trie. Returns True if deleted."""
    
    def _delete(node, word, index):
        if index == len(word):
            if not node.is_end_of_word:
                return False  # Word not in trie
            node.is_end_of_word = False
            return len(node.children) == 0  # Can delete if no children
        
        char = word[index]
        if char not in node.children:
            return False
        
        child = node.children[char]
        should_delete_child = _delete(child, word, index + 1)
        
        if should_delete_child:
            del node.children[char]
            return not node.is_end_of_word and len(node.children) == 0
        
        return False
    
    return _delete(self.root, word, 0)
```

---

**Ready to test?** 🚀 Move to **`19.Implement-Trie-Mock-Interview-Mode.md`**

*Happy Coding! 💻✨*
