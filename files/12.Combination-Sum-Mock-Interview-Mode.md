# â±ï¸ MOCK INTERVIEW: Combination Sum

**Difficulty:** ğŸŸ¡ Medium  
**Pattern:** Backtracking  
**Time Limit:** â° **25 minutes**  
**Points:** 100

---

## ğŸ“‹ Problem Statement

Given an array of **distinct** integers `candidates` and a target integer `target`, return *a list of all unique combinations of* `candidates` *where the chosen numbers sum to* `target`.

The **same** number may be chosen **unlimited times**. Two combinations are unique if the frequency of at least one number is different.

### Examples:

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]

Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
```

---

## â“ Clarifying Questions

1. **"Can I reuse same number?"** â†’ Yes, unlimited
2. **"Does order matter?"** â†’ No, [2,3] same as [3,2]
3. **"What if no solution?"** â†’ Return empty list
4. **"All positive integers?"** â†’ Yes (given constraints)

---

## ğŸ’¡ Optional Hints

<details>
<summary>ğŸ†˜ Hint 1 (âˆ’5 points)</summary>

Use **backtracking** to explore all combinations. Pass a `start` index to avoid duplicates.

</details>

<details>
<summary>ğŸ†˜ Hint 2 (âˆ’10 points)</summary>

```python
def backtrack(path, start, remaining):
    if remaining == 0:
        result.append(path.copy())
        return
    for i in range(start, len(candidates)):
        backtrack(path + [candidates[i]], i, remaining - candidates[i])
```

</details>

---

## ğŸ§‘â€ğŸ’» Your Solution Space

```python
def combinationSum(candidates: list[int], target: int) -> list[list[int]]:
    # Your code here
    pass
```

---

## âœ… Optimal Solution

<details>
<summary><b>ğŸ” Click to Reveal</b></summary>

```python
def combinationSum(candidates: list[int], target: int) -> list[list[int]]:
    result = []
    
    def backtrack(path, start, remaining):
        if remaining == 0:
            result.append(path.copy())
            return
        if remaining < 0:
            return
        
        for i in range(start, len(candidates)):
            path.append(candidates[i])
            backtrack(path, i, remaining - candidates[i])
            path.pop()
    
    backtrack([], 0, target)
    return result
```

</details>

---

## ğŸ¯ Grading Rubric (100 Points)

- Correctness: 40 pts
- Time complexity O(N^(T/M)): 25 pts
- Proper backtracking: 15 pts
- Code quality: 10 pts
- Communication: 10 pts

---

*"Backtrack = Try, Recurse, Undo!"* ğŸ¯âœ¨
