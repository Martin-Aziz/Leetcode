# ⏱️ MOCK INTERVIEW: Combination Sum

**Difficulty:** 🟡 Medium  
**Pattern:** Backtracking  
**Time Limit:** ⏰ **25 minutes**  
**Points:** 100

---

## 📋 Problem Statement

Given an array of **distinct** integers `candidates` and a target integer `target`, return *a list of all unique combinations of* `candidates` *where the chosen numbers sum to* `target`.

The **same** number may be chosen **unlimited times**. Two combinations are unique if the frequency of at least one number is different.

### Examples:

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]

Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
```

---

## ❓ Clarifying Questions

1. **"Can I reuse same number?"** → Yes, unlimited
2. **"Does order matter?"** → No, [2,3] same as [3,2]
3. **"What if no solution?"** → Return empty list
4. **"All positive integers?"** → Yes (given constraints)

---

## 💡 Optional Hints

<details>
<summary>🆘 Hint 1 (−5 points)</summary>

Use **backtracking** to explore all combinations. Pass a `start` index to avoid duplicates.

</details>

<details>
<summary>🆘 Hint 2 (−10 points)</summary>

```python
def backtrack(path, start, remaining):
    if remaining == 0:
        result.append(path.copy())
        return
    for i in range(start, len(candidates)):
        backtrack(path + [candidates[i]], i, remaining - candidates[i])
```

</details>

---

## 🧑‍💻 Your Solution Space

```python
def combinationSum(candidates: list[int], target: int) -> list[list[int]]:
    # Your code here
    pass
```

---

## ✅ Optimal Solution

<details>
<summary><b>🔍 Click to Reveal</b></summary>

```python
def combinationSum(candidates: list[int], target: int) -> list[list[int]]:
    result = []
    
    def backtrack(path, start, remaining):
        if remaining == 0:
            result.append(path.copy())
            return
        if remaining < 0:
            return
        
        for i in range(start, len(candidates)):
            path.append(candidates[i])
            backtrack(path, i, remaining - candidates[i])
            path.pop()
    
    backtrack([], 0, target)
    return result
```

</details>

---

## 🎯 Grading Rubric (100 Points)

- Correctness: 40 pts
- Time complexity O(N^(T/M)): 25 pts
- Proper backtracking: 15 pts
- Code quality: 10 pts
- Communication: 10 pts

---

*"Backtrack = Try, Recurse, Undo!"* 🎯✨
