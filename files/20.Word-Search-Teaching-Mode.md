# üéØ Problem 20: Word Search

**Difficulty:** üü° Medium  
**Pattern:** Backtracking on Grid / DFS  
**LeetCode Link:** [#79 Word Search](https://leetcode.com/problems/word-search/)

---

## üìã Problem Statement

Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.

The word can be constructed from letters of sequentially **adjacent cells**, where adjacent cells are horizontally or vertically neighboring. The same letter cell **may not be used more than once**.

### Examples:

```
Input: board = [["A","B","C","E"],
                ["S","F","C","S"],
                ["A","D","E","E"]], word = "ABCCED"
Output: true

Visualization:
A ‚Üí B ‚Üí C ‚Üê C
    ‚Üì       ‚Üë
    F       E
    ‚Üì       ‚Üë
    D ‚Üí E ‚Üí D

Input: board = [["A","B","C","E"],
                ["S","F","C","S"],
                ["A","D","E","E"]], word = "SEE"
Output: true

Input: board = [["A","B","C","E"],
                ["S","F","C","S"],
                ["A","D","E","E"]], word = "ABCB"
Output: false
Explanation: Can't reuse 'B' cell
```

---

## üéì Understanding

### Key Constraints:

1. **Sequential:** Must follow path in order (A‚ÜíB‚ÜíC, not A‚ÜíC‚ÜíB)
2. **Adjacent:** Only horizontal/vertical (no diagonal)
3. **No Reuse:** Each cell used at most once per path

### Why Backtracking?

We need to explore **all possible paths** starting from each cell. If one path fails, we **backtrack** and try another.

---

## üîç Solution: DFS with Backtracking

```python
def exist(board: list[list[str]], word: str) -> bool:
    """
    Search for word using DFS + backtracking.
    
    Time: O(m √ó n √ó 4^L) where L = len(word)
    Space: O(L) for recursion stack
    """
    if not board or not board[0]:
        return False
    
    rows, cols = len(board), len(board[0])
    
    def backtrack(row, col, index):
        # Found complete word!
        if index == len(word):
            return True
        
        # Out of bounds or wrong character
        if (row < 0 or row >= rows or 
            col < 0 or col >= cols or 
            board[row][col] != word[index]):
            return False
        
        # Mark cell as visited (in-place)
        temp = board[row][col]
        board[row][col] = '#'
        
        # Explore 4 directions
        found = (backtrack(row + 1, col, index + 1) or  # Down
                 backtrack(row - 1, col, index + 1) or  # Up
                 backtrack(row, col + 1, index + 1) or  # Right
                 backtrack(row, col - 1, index + 1))    # Left
        
        # Restore cell (backtrack)
        board[row][col] = temp
        
        return found
    
    # Try starting from each cell
    for row in range(rows):
        for col in range(cols):
            if backtrack(row, col, 0):
                return True
    
    return False
```

---

## üìä Step-by-Step Example

**Board:**
```
A B C E
S F C S
A D E E
```
**Word:** "ABCCED"

### Execution:

```
1. Start at (0,0) 'A'
   - Match! Mark visited: '#'
   - Try neighbors with 'B' (index=1)

2. Move to (0,1) 'B'
   - Match! Mark visited: '#'
   - Board now:
     # # C E
     S F C S
     A D E E
   - Try neighbors with 'C' (index=2)

3. Move to (0,2) 'C'
   - Match! Mark visited: '#'
   - Try neighbors with 'C' (index=3)

4. Move to (1,2) 'C'
   - Match! Mark visited: '#'
   - Try neighbors with 'E' (index=4)

5. Move to (2,2) 'E'
   - Match! Mark visited: '#'
   - Try neighbors with 'D' (index=5)

6. Move to (2,1) 'D'
   - Match! index == len(word) ‚Üí Return True! ‚úÖ
```

---

## üîÑ Alternative: Visited Set

```python
def exist(board: list[list[str]], word: str) -> bool:
    """
    Use separate visited set instead of modifying board.
    
    Time: O(m √ó n √ó 4^L)
    Space: O(L) for recursion + O(L) for visited set
    """
    rows, cols = len(board), len(board[0])
    visited = set()
    
    def backtrack(row, col, index):
        if index == len(word):
            return True
        
        if (row < 0 or row >= rows or 
            col < 0 or col >= cols or 
            (row, col) in visited or
            board[row][col] != word[index]):
            return False
        
        visited.add((row, col))
        
        found = (backtrack(row + 1, col, index + 1) or
                 backtrack(row - 1, col, index + 1) or
                 backtrack(row, col + 1, index + 1) or
                 backtrack(row, col - 1, index + 1))
        
        visited.remove((row, col))  # Backtrack
        
        return found
    
    for row in range(rows):
        for col in range(cols):
            if backtrack(row, col, 0):
                return True
    
    return False
```

---

## ‚ö° Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| In-place marking | O(m√ón√ó4^L) | O(L) | Modifies board temporarily |
| Visited set | O(m√ón√ó4^L) | O(L) | Cleaner, no board modification |

**m, n** = board dimensions  
**L** = word length  
**4^L** = worst case: explore 4 directions at each step

---

## üéØ Key Patterns

### Pattern 1: Backtracking Template
```python
# 1. Base cases
if success_condition:
    return True
if invalid_condition:
    return False

# 2. Mark as visited
mark_visited()

# 3. Explore options
result = explore_all_directions()

# 4. Undo (backtrack)
undo_visited()

return result
```

### Pattern 2: Grid Bounds Check
```python
if (row < 0 or row >= rows or 
    col < 0 or col >= cols):
    return False
```

### Pattern 3: Four Directions
```python
directions = [(0,1), (0,-1), (1,0), (-1,0)]  # Right, Left, Down, Up

for dr, dc in directions:
    new_row, new_col = row + dr, col + dc
    if backtrack(new_row, new_col, index + 1):
        return True
```

---

## üêõ Common Mistakes

### ‚ùå Mistake 1: Forgetting to Backtrack
```python
# WRONG - cell stays marked!
board[row][col] = '#'
backtrack(...)
# Missing: board[row][col] = temp
```

### ‚ùå Mistake 2: Not Checking All Starting Points
```python
# WRONG - only tries (0,0)
return backtrack(0, 0, 0)

# RIGHT - try all cells
for row in range(rows):
    for col in range(cols):
        if backtrack(row, col, 0):
            return True
```

### ‚ùå Mistake 3: Wrong Base Case Order
```python
# WRONG - checks bounds before success
if row < 0 or ...:
    return False
if index == len(word):  # Too late!
    return True
```

---

## üöÄ Optimizations

### Optimization 1: Early Character Check
```python
# Count characters in board
from collections import Counter
board_count = Counter(char for row in board for char in row)
word_count = Counter(word)

# If word needs more of any char than board has, impossible!
for char, count in word_count.items():
    if board_count[char] < count:
        return False
```

### Optimization 2: Reverse Word if Helpful
```python
# If last char is rarer than first, search backwards
if word_count[word[-1]] < word_count[word[0]]:
    word = word[::-1]
```

---

## üéØ Practice Problems

1. **[LeetCode 212] Word Search II** (Hard) - Multiple words with Trie
2. **[LeetCode 351] Android Unlock Patterns** (Medium)
3. **[LeetCode 980] Unique Paths III** (Hard)
4. **[LeetCode 1219] Path with Maximum Gold** (Medium)

---

## üèÜ Key Takeaways

1. **Backtracking on grid** = DFS + mark visited + undo
2. **Try all starting points** (each cell could be start)
3. **In-place marking** with temporary character is space-efficient
4. **Time complexity** is exponential: O(m√ón√ó4^L)
5. **Early termination** at first successful path

---

## üí° Interview Tips

**When asked about word search:**
- Recognize **backtracking** immediately
- Mention **4 directions** and **no reuse**
- Discuss **in-place marking** vs visited set
- Consider **optimizations** (character counting, word reversal)
- Mention **Word Search II** follow-up with Trie

**Common follow-ups:**
- "What if diagonal movement allowed?" ‚Üí 8 directions
- "What if multiple words?" ‚Üí Use Trie (Problem 212)
- "What if board is very large?" ‚Üí Pruning strategies

---

**Ready to test?** üöÄ Move to **`20.Word-Search-Mock-Interview-Mode.md`**

*Happy Coding! üíª‚ú®*
