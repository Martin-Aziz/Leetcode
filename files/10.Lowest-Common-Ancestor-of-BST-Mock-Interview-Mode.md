# â±ï¸ MOCK INTERVIEW: Lowest Common Ancestor of a BST

**Difficulty:** ğŸŸ¡ Medium  
**Pattern:** Binary Search Tree  
**Time Limit:** â° **20 minutes**  
**Points:** 100

---

## ğŸ¯ Interview Simulation

**Start your timer NOW!** â°

---

## ğŸ“‹ Problem Statement

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

The lowest common ancestor is the lowest node that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).

### Example:

```
        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5

Input: root = [6,2,8,0,4,7,9,3,5], p = 2, q = 8
Output: 6

Input: root = [6,2,8,0,4,7,9,3,5], p = 2, q = 4
Output: 2
```

### Constraints:
- Number of nodes: `[2, 10^5]`
- All values are unique
- `p` and `q` exist in the BST
- `p != q`

---

## â“ Clarifying Questions

1. **"Can a node be an ancestor of itself?"** â†’ Yes
2. **"Is this a BST or regular binary tree?"** â†’ BST (use properties!)
3. **"Are p and q guaranteed to exist?"** â†’ Yes
4. **"What should I optimize for?"** â†’ Time and space

---

## ğŸ’­ Think Out Loud

"Since this is a BST, I can use the ordering property. If both nodes are smaller than current, go left. If both larger, go right. Otherwise, current is the LCA..."

---

## ğŸ’¡ Optional Hints

<details>
<summary>ğŸ†˜ Hint 1: What makes BST special? (âˆ’5 points)</summary>

BST property: left < node < right

You can determine which subtree contains a node by value comparison!

</details>

<details>
<summary>ğŸ†˜ Hint 2: When is LCA found? (âˆ’10 points)</summary>

LCA is found when paths to p and q diverge:
- If both < current â†’ go left
- If both > current â†’ go right  
- Otherwise â†’ current is LCA!

</details>

<details>
<summary>ğŸ†˜ Hint 3: Recursive or iterative? (âˆ’15 points)</summary>

**Iterative is simpler:**

```python
while root:
    if p.val < root.val and q.val < root.val:
        root = root.left
    elif p.val > root.val and q.val > root.val:
        root = root.right
    else:
        return root
```

</details>

---

## ğŸ§‘â€ğŸ’» Your Solution Space

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Find the lowest common ancestor in a BST.
    
    Args:
        root: Root of BST
        p: First node
        q: Second node
        
    Returns:
        The LCA node
    """
    # Your code here
    pass


# Test your solution
if __name__ == "__main__":
    # Build tree
    root = TreeNode(6)
    root.left = TreeNode(2)
    root.right = TreeNode(8)
    root.left.left = TreeNode(0)
    root.left.right = TreeNode(4)
    
    # Test
    lca = lowestCommonAncestor(root, root.left, root.right)
    assert lca.val == 6
    
    print("âœ… Test passed!")
```

---

## â° Time Check!

- â±ï¸ **5 min:** Should have approach
- â±ï¸ **12 min:** Should have working solution
- â±ï¸ **17 min:** Should be testing
- â±ï¸ **20 min:** TIME'S UP!

---

## âœ… Optimal Solution

<details>
<summary><b>ğŸ” Click to Reveal</b></summary>

```python
def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Iterative solution using BST properties.
    
    Time: O(h) where h is height
    Space: O(1) - no extra space
    """
    current = root
    
    while current:
        # Both in left subtree
        if p.val < current.val and q.val < current.val:
            current = current.left
        
        # Both in right subtree
        elif p.val > current.val and q.val > current.val:
            current = current.right
        
        # Split or current is p/q
        else:
            return current
    
    return None


# Recursive alternative
def lowestCommonAncestor_recursive(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Time: O(h)
    Space: O(h) - recursion stack
    """
    if p.val < root.val and q.val < root.val:
        return lowestCommonAncestor_recursive(root.left, p, q)
    elif p.val > root.val and q.val > root.val:
        return lowestCommonAncestor_recursive(root.right, p, q)
    else:
        return root
```

</details>

---

## ğŸ¯ Grading Rubric (100 Points)

### 1ï¸âƒ£ Correctness (40 points)
- All test cases pass: 20 pts
- Handles node as self-ancestor: 10 pts
- Handles split correctly: 10 pts

### 2ï¸âƒ£ Time Complexity (25 points)
- Achieves O(h): 20 pts
- Explains BST advantage: 5 pts
- **Penalty:** O(n) when O(h) possible: -10 pts

### 3ï¸âƒ£ Space Complexity (15 points)
- O(1) iterative or O(h) recursive: 12 pts
- Explains space usage: 3 pts

### 4ï¸âƒ£ Code Quality (10 points)
- Uses BST property: 5 pts
- Clean logic: 5 pts

### 5ï¸âƒ£ Communication (10 points)
- Explained BST advantage: 5 pts
- Drew/described tree: 3 pts
- Tested: 2 pts

### Penalties:
- Used hints: -5, -10, -15
- Wrong answer: -30
- Overtime: -10

---

## ğŸ“ˆ Your Performance Summary

| Metric | Your Result |
|--------|-------------|
| **Total Score** | ___/100 |
| **Time Taken** | ___ min |
| **Complexity** | O(___) time, O(___) space |

---

## ğŸŠ Session 2 Complete!

**Congratulations!** You've completed all 5 Session 2 problems!

**Patterns Mastered:**
- âœ… Sliding Window
- âœ… Binary Search (Modified)
- âœ… BFS/DFS Graph Traversal
- âœ… Array/Prefix Product
- âœ… Binary Search Tree

---

## ğŸš€ What's Next?

1. **Review your scores** across all 10 mock interviews
2. **Practice weak patterns** with similar problems
3. **Ready for Session 3?** More advanced patterns await!

---

*"A BST's structure IS the solution!"* ğŸŒ³âœ¨
