# ⏱️ MOCK INTERVIEW: Lowest Common Ancestor of a BST

**Difficulty:** 🟡 Medium  
**Pattern:** Binary Search Tree  
**Time Limit:** ⏰ **20 minutes**  
**Points:** 100

---

## 🎯 Interview Simulation

**Start your timer NOW!** ⏰

---

## 📋 Problem Statement

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

The lowest common ancestor is the lowest node that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).

### Example:

```
        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5

Input: root = [6,2,8,0,4,7,9,3,5], p = 2, q = 8
Output: 6

Input: root = [6,2,8,0,4,7,9,3,5], p = 2, q = 4
Output: 2
```

### Constraints:
- Number of nodes: `[2, 10^5]`
- All values are unique
- `p` and `q` exist in the BST
- `p != q`

---

## ❓ Clarifying Questions

1. **"Can a node be an ancestor of itself?"** → Yes
2. **"Is this a BST or regular binary tree?"** → BST (use properties!)
3. **"Are p and q guaranteed to exist?"** → Yes
4. **"What should I optimize for?"** → Time and space

---

## 💭 Think Out Loud

"Since this is a BST, I can use the ordering property. If both nodes are smaller than current, go left. If both larger, go right. Otherwise, current is the LCA..."

---

## 💡 Optional Hints

<details>
<summary>🆘 Hint 1: What makes BST special? (−5 points)</summary>

BST property: left < node < right

You can determine which subtree contains a node by value comparison!

</details>

<details>
<summary>🆘 Hint 2: When is LCA found? (−10 points)</summary>

LCA is found when paths to p and q diverge:
- If both < current → go left
- If both > current → go right  
- Otherwise → current is LCA!

</details>

<details>
<summary>🆘 Hint 3: Recursive or iterative? (−15 points)</summary>

**Iterative is simpler:**

```python
while root:
    if p.val < root.val and q.val < root.val:
        root = root.left
    elif p.val > root.val and q.val > root.val:
        root = root.right
    else:
        return root
```

</details>

---

## 🧑‍💻 Your Solution Space

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Find the lowest common ancestor in a BST.
    
    Args:
        root: Root of BST
        p: First node
        q: Second node
        
    Returns:
        The LCA node
    """
    # Your code here
    pass


# Test your solution
if __name__ == "__main__":
    # Build tree
    root = TreeNode(6)
    root.left = TreeNode(2)
    root.right = TreeNode(8)
    root.left.left = TreeNode(0)
    root.left.right = TreeNode(4)
    
    # Test
    lca = lowestCommonAncestor(root, root.left, root.right)
    assert lca.val == 6
    
    print("✅ Test passed!")
```

---

## ⏰ Time Check!

- ⏱️ **5 min:** Should have approach
- ⏱️ **12 min:** Should have working solution
- ⏱️ **17 min:** Should be testing
- ⏱️ **20 min:** TIME'S UP!

---

## ✅ Optimal Solution

<details>
<summary><b>🔍 Click to Reveal</b></summary>

```python
def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Iterative solution using BST properties.
    
    Time: O(h) where h is height
    Space: O(1) - no extra space
    """
    current = root
    
    while current:
        # Both in left subtree
        if p.val < current.val and q.val < current.val:
            current = current.left
        
        # Both in right subtree
        elif p.val > current.val and q.val > current.val:
            current = current.right
        
        # Split or current is p/q
        else:
            return current
    
    return None


# Recursive alternative
def lowestCommonAncestor_recursive(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
    """
    Time: O(h)
    Space: O(h) - recursion stack
    """
    if p.val < root.val and q.val < root.val:
        return lowestCommonAncestor_recursive(root.left, p, q)
    elif p.val > root.val and q.val > root.val:
        return lowestCommonAncestor_recursive(root.right, p, q)
    else:
        return root
```

</details>

---

## 🎯 Grading Rubric (100 Points)

### 1️⃣ Correctness (40 points)
- All test cases pass: 20 pts
- Handles node as self-ancestor: 10 pts
- Handles split correctly: 10 pts

### 2️⃣ Time Complexity (25 points)
- Achieves O(h): 20 pts
- Explains BST advantage: 5 pts
- **Penalty:** O(n) when O(h) possible: -10 pts

### 3️⃣ Space Complexity (15 points)
- O(1) iterative or O(h) recursive: 12 pts
- Explains space usage: 3 pts

### 4️⃣ Code Quality (10 points)
- Uses BST property: 5 pts
- Clean logic: 5 pts

### 5️⃣ Communication (10 points)
- Explained BST advantage: 5 pts
- Drew/described tree: 3 pts
- Tested: 2 pts

### Penalties:
- Used hints: -5, -10, -15
- Wrong answer: -30
- Overtime: -10

---

## 📈 Your Performance Summary

| Metric | Your Result |
|--------|-------------|
| **Total Score** | ___/100 |
| **Time Taken** | ___ min |
| **Complexity** | O(___) time, O(___) space |

---

## 🎊 Session 2 Complete!

**Congratulations!** You've completed all 5 Session 2 problems!

**Patterns Mastered:**
- ✅ Sliding Window
- ✅ Binary Search (Modified)
- ✅ BFS/DFS Graph Traversal
- ✅ Array/Prefix Product
- ✅ Binary Search Tree

---

## 🚀 What's Next?

1. **Review your scores** across all 10 mock interviews
2. **Practice weak patterns** with similar problems
3. **Ready for Session 3?** More advanced patterns await!

---

*"A BST's structure IS the solution!"* 🌳✨
