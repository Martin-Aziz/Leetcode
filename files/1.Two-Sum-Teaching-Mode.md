# 📘 Two Sum - Teaching Mode

> **Difficulty:** 🟢 Easy  
> **Problem Link:** [LeetCode #1](https://leetcode.com/problems/two-sum/)  
> **Pattern:** Hash Map / Array  
> **Session:** Problem 1 of 5

---

## 🧩 Problem Statement

Given an array of integers `nums` and an integer `target`, return **indices** of the two numbers such that they add up to `target`.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

### 📝 Examples

**Example 1:**
```python
Input: nums = [2, 7, 11, 15], target = 9
Output: [0, 1]
Explanation: nums[0] + nums[1] = 2 + 7 = 9
```

**Example 2:**
```python
Input: nums = [3, 2, 4], target = 6
Output: [1, 2]
```

**Example 3:**
```python
Input: nums = [3, 3], target = 6
Output: [0, 1]
```

### 🔍 Input/Output Types
- **Input:** 
  - `nums`: List of integers (`List[int]`)
  - `target`: Integer (`int`)
- **Output:** List of two integers representing indices (`List[int]`)

---

## 🧠 Understanding the Problem

**What is this problem really asking?**

You need to find **two different positions** in the array where the numbers at those positions add up to the target. You return the **indices** (positions), not the numbers themselves.

**Key Points:**
- ✅ Exactly one solution exists (guaranteed)
- ✅ Can't use the same element twice (different indices required)
- ✅ Order of output doesn't matter
- ⚠️ Array can contain duplicates (like `[3, 3]`)
- ⚠️ Array can contain negative numbers

**Edge Cases:**
- Array with exactly 2 elements (minimum size)
- Array with duplicate numbers
- Target is negative or zero
- Numbers in array are negative

---

## 🧭 Recognizing the Pattern(s)

### 🎯 Primary Pattern: **Hash Map (Dictionary Lookup)**

**Analogy:** Imagine you're at a party looking for your dance partner. Instead of asking every person "Are you my partner?" one by one, you write everyone's name on a guest list as they arrive. When you need to find your partner, you just check the list instantly!

**Why This Pattern?**
- We need to find if a **complement** exists: `complement = target - current_number`
- Hash maps allow **O(1) lookup** instead of O(n) search
- We can store numbers we've seen and check if their complement appears later

**Alternative Pattern:** Brute Force (Two Nested Loops)
- Check every possible pair
- Simpler but slower: O(n²)

---

## 🪜 High-Level Plan

### Strategy: One-Pass Hash Map

1. **Create an empty hash map** to store numbers we've seen and their indices
2. **Loop through each number** in the array (with its index)
3. **Calculate the complement** needed to reach the target: `complement = target - num`
4. **Check if complement exists** in our hash map
   - If **YES** → We found the pair! Return `[complement_index, current_index]`
   - If **NO** → Store the current number and its index in the hash map
5. Continue until we find the solution

### 📋 Pseudocode

```python
# Step 1: Initialize hash map
seen = {}

# Step 2: Iterate through array
for index, num in enumerate(nums):
    # Step 3: Calculate what number we need
    complement = target - num
    
    # Step 4: Check if we've seen it before
    if complement in seen:
        return [seen[complement], index]
    
    # Step 5: Store current number for future lookups
    seen[num] = index
```

---

## 💡 Hints Policy

### 🎓 Level 1 Hint (Small Nudge)
<details>
<summary>Click to reveal Level 1 Hint</summary>

Think about what you need to find: For each number, you're looking for its "complement" — the number that would add up to the target. How can you quickly check if you've already seen that complement?

</details>

### 🎓 Level 2 Hint (Medium Help)
<details>
<summary>Click to reveal Level 2 Hint</summary>

Use a **dictionary** to remember numbers you've already seen. For each new number:
1. Calculate: `complement = target - current_number`
2. Check: Is `complement` in your dictionary?
3. If yes → you found both indices!
4. If no → add current number to dictionary

</details>

### 🎓 Level 3 Hint (Almost There)
<details>
<summary>Click to reveal Level 3 Hint</summary>

```python
def twoSum(nums, target):
    seen = {}  # {value: index}
    
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
```

The key insight: Store each number with its index as you go. When you find the complement, you already have its index stored!

</details>

---

## 🧑‍💻 Code Solution (Python)

### ✨ Optimal Solution: Hash Map (One-Pass)

```python
# Time Complexity: O(n) - Single pass through array
# Space Complexity: O(n) - Hash map stores up to n elements

def twoSum(nums, target):
    """
    Find two indices where nums[i] + nums[j] = target.
    
    Args:
        nums: List of integers
        target: Target sum
    
    Returns:
        List of two indices [i, j]
    """
    # Dictionary to store {value: index} pairs we've seen
    seen = {}
    
    # Iterate through array with index and value
    for i, num in enumerate(nums):
        # Calculate the complement needed to reach target
        complement = target - num
        
        # Check if we've seen the complement before
        if complement in seen:
            # Found it! Return the stored index and current index
            return [seen[complement], i]
        
        # Haven't found pair yet, store current number and its index
        seen[num] = i
    
    # This line should never be reached per problem constraints
    return []


# ✅ Example Tests
print(twoSum([2, 7, 11, 15], 9))  # Output: [0, 1]
print(twoSum([3, 2, 4], 6))       # Output: [1, 2]
print(twoSum([3, 3], 6))          # Output: [0, 1]
print(twoSum([-1, -2, -3, -4, -5], -8))  # Output: [2, 4]
```

### 🔄 Alternative Solution: Brute Force (For Comparison)

```python
# Time Complexity: O(n²) - Nested loops
# Space Complexity: O(1) - No extra space

def twoSumBruteForce(nums, target):
    """
    Brute force approach: Check every pair.
    Simple but slower.
    """
    n = len(nums)
    
    # Check every possible pair
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    
    return []


# ✅ Example Tests
print(twoSumBruteForce([2, 7, 11, 15], 9))  # Output: [0, 1]
print(twoSumBruteForce([3, 2, 4], 6))       # Output: [1, 2]
```

---

## 🧩 Step-by-Step Explanation

Let's trace through **Example 1:** `nums = [2, 7, 11, 15]`, `target = 9`

### Initialization
```python
seen = {}  # Empty dictionary
```

### Iteration 1: `i=0, num=2`
```python
complement = 9 - 2 = 7
Is 7 in seen? No (seen is empty)
seen = {2: 0}  # Store 2 at index 0
```

### Iteration 2: `i=1, num=7`
```python
complement = 9 - 7 = 2
Is 2 in seen? YES! (seen[2] = 0)
Return [0, 1] ✅
```

**Done!** We found that indices 0 and 1 contain numbers that sum to 9.

---

### 🎬 Visual Walkthrough

```
Array:  [2,  7,  11, 15]
Index:   0   1   2   3
Target: 9

Step 1: Look at 2 (index 0)
  ├─ Need: 9 - 2 = 7
  ├─ Is 7 in seen? No
  └─ Store: seen = {2: 0}

Step 2: Look at 7 (index 1)
  ├─ Need: 9 - 7 = 2
  ├─ Is 2 in seen? YES! ✅
  └─ Return: [seen[2], 1] = [0, 1]
```

---

## ⏱️ Complexity Analysis

### Time Complexity: **O(n)**
- We iterate through the array **once** (single loop)
- Hash map lookup and insertion are **O(1)** operations
- Total: n iterations × O(1) = **O(n)**

### Space Complexity: **O(n)**
- In the worst case, we store almost every element in the hash map
- Example: If the solution is the last two elements, we store n-1 elements
- Hash map space: **O(n)**

### 📊 Comparison with Brute Force

| Approach | Time | Space | When to Use |
|----------|------|-------|-------------|
| **Hash Map** | O(n) | O(n) | ✅ Optimal for most cases |
| **Brute Force** | O(n²) | O(1) | Only when space is extremely limited |

**Trade-off:** We sacrifice space to gain massive time improvement!

---

## 🔁 Variations & Follow-Ups

### 🟢 Easier Variations
1. **Two Sum II (Sorted Array)** - Array is already sorted, use two pointers
   - Can achieve O(n) time, O(1) space

2. **Two Sum (Return Values, Not Indices)** - Return the actual numbers
   - Slightly simpler, same approach

### 🟡 Medium Variations
3. **Three Sum** (LeetCode #15) - Find three numbers that sum to target
   - Use hash map + one outer loop
   - Time: O(n²)

4. **Two Sum - Count Pairs** - Count all pairs that sum to target (duplicates allowed)
   - Modify solution to count instead of return immediately

### 🔴 Harder Variations
5. **Four Sum** (LeetCode #18) - Find four numbers that sum to target
   - Extend to O(n³) or optimized O(n²) with hash map

6. **Two Sum - All Unique Pairs** - Return all unique pairs (no duplicates)
   - Need to handle duplicate numbers carefully

**How the Pattern Changes:**
- **Sorted array** → Two pointers instead of hash map
- **Multiple numbers** → Nested loops + hash map
- **Count instead of find** → Continue searching instead of return early

---

## 🧩 Reflection & Reinforcement

### 📚 Check Your Understanding

<details>
<summary><b>Question 1:</b> Why do we use a hash map instead of nested loops?</summary>

**Answer:** Hash maps provide O(1) lookup time, allowing us to check if a complement exists instantly. Nested loops would require O(n) time for each search, resulting in O(n²) total time.

</details>

<details>
<summary><b>Question 2:</b> What happens if the array contains duplicate numbers like [3, 3]?</summary>

**Answer:** It works correctly! When we see the first 3 at index 0, we store it. When we see the second 3 at index 1, we calculate complement = 6 - 3 = 3, find it in our hash map at index 0, and return [0, 1].

</details>

<details>
<summary><b>Question 3:</b> Can we modify this to return the values instead of indices?</summary>

**Answer:** Yes! Instead of returning `[seen[complement], i]`, return `[complement, num]`. We don't even need to store indices in the hash map—just use a set to track seen values.

</details>

---

## 🎯 Practice Problems (Similar Pattern)

Here are 3 problems that use the same **Hash Map Pattern:**

1. **Contains Duplicate** (LeetCode #217) - Easy 🟢
   - *Why:* Use hash set to track seen numbers, same O(1) lookup concept
   - *Skill:* Understanding when to use set vs dictionary

2. **Valid Anagram** (LeetCode #242) - Easy 🟢
   - *Why:* Hash map to count character frequencies
   - *Skill:* Using hash maps for counting/frequency problems

3. **Group Anagrams** (LeetCode #49) - Medium 🟡
   - *Why:* Hash map with sorted string as key
   - *Skill:* Using complex keys in hash maps

---

## 💬 Interview Mindset Tips

### 🎙️ 1. **Think Aloud**
- Start with: *"I need to find two indices where the numbers sum to target..."*
- Verbalize your thought process: *"I could use nested loops, but that would be O(n²). A hash map would let me check for complements in O(1)..."*
- Show you're considering trade-offs

### ⏰ 2. **Manage Time**
- Spend 2-3 minutes understanding the problem
- Mention brute force first (shows you can solve it)
- Then optimize: *"Can I do better than O(n²)?"*
- Don't code immediately—discuss approach first

### 🧪 3. **Test Edge Cases**
- Before coding: Ask about constraints
  - *"Can the array be empty?"* (No, per constraints)
  - *"Can numbers be negative?"* (Yes)
  - *"Are there always exactly 2 elements that sum to target?"* (Yes)
- After coding: Test with your examples
  - Minimum case: `[1, 2]`, `target = 3`
  - Duplicates: `[3, 3]`, `target = 6`
  - Negatives: `[-1, -2]`, `target = -3`

### ⚖️ 4. **Compare Trade-offs**
- Always mention time vs space trade-off
- *"The hash map uses O(n) extra space, but reduces time from O(n²) to O(n). This trade-off is worth it in most practical scenarios."*

---

## ✅ Summary Checklist

Before moving to the next problem, make sure you can:

- [ ] Explain why hash maps are better than nested loops here
- [ ] Write the solution from memory (without looking)
- [ ] Identify the complement calculation as the key insight
- [ ] Handle edge cases like duplicates and negative numbers
- [ ] Articulate the O(n) time and O(n) space complexity

---

## 🎯 Next Steps

You've completed **Problem 1 of 5** in this session! 🎉

**Choose your next action:**

1. 🔄 **Try another Easy problem** - Build more confidence
2. ⬆️ **Move to Medium** - Challenge yourself
3. 🎤 **Switch to Mock-Interview Mode** - Test under pressure
4. 📝 **Review this problem again** - Solidify understanding

*When you're ready, let me know and we'll continue your journey!*

---

<div align="center">

**Happy Coding! 🚀**

*Remember: Understanding the pattern is more important than memorizing the code!*

</div>
