# 🎯 Problem 14: Kth Largest Element in an Array

**Difficulty:** 🟡 Medium  
**Pattern:** Heap / Quickselect  
**LeetCode Link:** [#215 Kth Largest Element](https://leetcode.com/problems/kth-largest-element-in-an-array/)

---

## 📋 Problem Statement

Given an integer array `nums` and an integer `k`, return *the* `k`*th largest element in the array*.

Note that it is the `k`th largest element in the sorted order, not the `k`th distinct element.

Can you solve it without sorting?

### Examples:

```
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5

Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
```

---

## 🎓 Understanding

**k=1** → largest element  
**k=2** → second largest  
**k=n** → smallest element

---

## 🔍 Three Approaches

### Approach 1: Sorting (Simple)

```python
def findKthLargest(nums, k):
    """Time: O(n log n), Space: O(1)"""
    nums.sort()
    return nums[-k]
```

### Approach 2: Min-Heap (K elements)

```python
import heapq

def findKthLargest(nums, k):
    """
    Keep heap of k largest elements.
    Time: O(n log k), Space: O(k)
    """
    heap = nums[:k]
    heapq.heapify(heap)
    
    for num in nums[k:]:
        if num > heap[0]:
            heapq.heapreplace(heap, num)
    
    return heap[0]
```

### Approach 3: Quickselect (Optimal)

```python
import random

def findKthLargest(nums, k):
    """
    Partition-based selection like quicksort.
    Average: O(n), Worst: O(n²), Space: O(1)
    """
    k = len(nums) - k  # Convert to kth smallest for easier indexing
    
    def quickselect(left, right):
        pivot = random.randint(left, right)
        nums[pivot], nums[right] = nums[right], nums[pivot]
        
        store_index = left
        for i in range(left, right):
            if nums[i] < nums[right]:
                nums[store_index], nums[i] = nums[i], nums[store_index]
                store_index += 1
        
        nums[right], nums[store_index] = nums[store_index], nums[right]
        
        if k < store_index:
            return quickselect(left, store_index - 1)
        elif k > store_index:
            return quickselect(store_index + 1, right)
        else:
            return nums[k]
    
    return quickselect(0, len(nums) - 1)
```

---

## ⚡ Complexity Comparison

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Sorting | O(n log n) | O(1) | Simplest |
| Min-Heap | O(n log k) | O(k) | Good when k small |
| Quickselect | O(n) avg | O(1) | Optimal average case |

---

## 🎯 Practice Problems

1. **[LeetCode 703] Kth Largest Element in Stream** (Easy)
2. **[LeetCode 347] Top K Frequent Elements** (Medium)
3. **[LeetCode 973] K Closest Points to Origin** (Medium)

---

## 🏆 Key Takeaways

1. **Heap approach** best for small k
2. **Quickselect** optimal average case O(n)
3. **Sorting** acceptable if not asked to optimize

---

**Ready to test?** 🚀 Move to **`14.Kth-Largest-Element-Mock-Interview-Mode.md`**

*Happy Coding! 💻✨*
