# 🎯 Problem 17: Course Schedule

**Difficulty:** 🟡 Medium  
**Pattern:** Topological Sort / Cycle Detection  
**LeetCode Link:** [#207 Course Schedule](https://leetcode.com/problems/course-schedule/)

---

## 📋 Problem Statement

There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`.

You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.

Return `true` if you can finish all courses. Otherwise, return `false`.

### Examples:

```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: Take course 0, then course 1.

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: To take course 1 you need course 0, and vice versa. Impossible!

Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: true
Explanation: 0 → 1 → 3
             0 → 2 → 3
```

---

## 🎓 Understanding

This is a **cycle detection** problem disguised as a scheduling problem!

### Key Insight:

**Can finish all courses?** ⟺ **Graph has NO cycles**

```
Valid (No cycle):          Invalid (Has cycle):
    0 → 1 → 2                  0 → 1
                               ↑   ↓
                               ← 2 ←
```

---

## 🔍 Two Approaches

### Approach 1: DFS with States (Cycle Detection)

**Idea:** Track each node's state during DFS
- **White (0):** Not visited
- **Gray (1):** Currently visiting (in recursion stack)
- **Black (2):** Finished visiting

**Cycle exists** if we encounter a **GRAY** node!

```python
def canFinish(numCourses, prerequisites):
    """
    DFS cycle detection.
    
    Time: O(V + E)
    Space: O(V + E)
    """
    # Build adjacency list
    graph = [[] for _ in range(numCourses)]
    for course, prereq in prerequisites:
        graph[course].append(prereq)
    
    # 0 = white (unvisited)
    # 1 = gray (visiting)
    # 2 = black (finished)
    state = [0] * numCourses
    
    def has_cycle(course):
        if state[course] == 1:  # Gray - found cycle!
            return True
        if state[course] == 2:  # Black - already checked
            return False
        
        state[course] = 1  # Mark as visiting (gray)
        
        # Visit all prerequisites
        for prereq in graph[course]:
            if has_cycle(prereq):
                return True
        
        state[course] = 2  # Mark as finished (black)
        return False
    
    # Check each course
    for course in range(numCourses):
        if has_cycle(course):
            return False
    
    return True
```

---

### Approach 2: BFS Topological Sort (Kahn's Algorithm)

**Idea:** 
1. Calculate **in-degree** (number of prerequisites) for each course
2. Start with courses that have no prerequisites (in-degree = 0)
3. Remove courses one by one, updating in-degrees
4. If we can't remove all courses → cycle exists!

```python
from collections import deque

def canFinish(numCourses, prerequisites):
    """
    BFS topological sort (Kahn's algorithm).
    
    Time: O(V + E)
    Space: O(V + E)
    """
    # Build graph and calculate in-degrees
    graph = [[] for _ in range(numCourses)]
    in_degree = [0] * numCourses
    
    for course, prereq in prerequisites:
        graph[prereq].append(course)  # prereq → course
        in_degree[course] += 1
    
    # Start with courses that have no prerequisites
    queue = deque([i for i in range(numCourses) if in_degree[i] == 0])
    completed = 0
    
    while queue:
        course = queue.popleft()
        completed += 1
        
        # "Remove" this course from graph
        for next_course in graph[course]:
            in_degree[next_course] -= 1
            if in_degree[next_course] == 0:
                queue.append(next_course)
    
    # Could we complete all courses?
    return completed == numCourses
```

---

## 📊 Step-by-Step Example

**Input:** `numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]`

### DFS Approach:

```
Graph:
0 ← 1 ← 3
↑   ↑   ↑
└── 2 ──┘

DFS from each course:
- Course 0: No prereqs → OK
- Course 1: Prereq 0 (black) → OK
- Course 2: Prereq 0 (black) → OK
- Course 3: Prereqs 1,2 (both black) → OK

No gray nodes encountered → No cycle → True
```

### BFS Approach:

```
Initial in-degrees: [0, 1, 1, 2]
Queue: [0]

Step 1: Process 0, completed=1
  - Update in-degree[1]=0, in-degree[2]=0
  - Queue: [1, 2]

Step 2: Process 1, completed=2
  - Update in-degree[3]=1
  - Queue: [2]

Step 3: Process 2, completed=3
  - Update in-degree[3]=0
  - Queue: [3]

Step 4: Process 3, completed=4
  - Queue: []

completed (4) == numCourses (4) → True
```

---

## ⚡ Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| DFS (States) | O(V + E) | O(V + E) | Graph + recursion stack |
| BFS (Kahn's) | O(V + E) | O(V + E) | Graph + queue |

**V** = numCourses (vertices)  
**E** = len(prerequisites) (edges)

---

## 🎯 Key Patterns

### Pattern 1: Cycle Detection with Colors
```python
WHITE = 0  # Unvisited
GRAY = 1   # Visiting (in current path)
BLACK = 2  # Finished

if state[node] == GRAY:
    return True  # Cycle found!
```

### Pattern 2: Topological Sort with In-Degrees
```python
in_degree = [0] * n
for a, b in edges:
    in_degree[a] += 1

# Start with nodes having in_degree = 0
```

### Pattern 3: Building Adjacency List
```python
graph = [[] for _ in range(n)]
for course, prereq in prerequisites:
    graph[prereq].append(course)
```

---

## 🐛 Common Mistakes

### ❌ Mistake 1: Wrong Graph Direction
```python
# WRONG
for course, prereq in prerequisites:
    graph[course].append(prereq)  # Backwards!

# RIGHT (for BFS)
for course, prereq in prerequisites:
    graph[prereq].append(course)  # prereq → course
```

### ❌ Mistake 2: Not Handling Disconnected Components
```python
# Must check ALL courses
for course in range(numCourses):
    if has_cycle(course):
        return False
```

### ❌ Mistake 3: Forgetting to Mark as Visited
```python
# WRONG - infinite loop possible
def dfs(course):
    for prereq in graph[course]:
        if dfs(prereq):
            return True
    # Forgot to mark as visited!
```

---

## 🎯 Practice Problems

1. **[LeetCode 210] Course Schedule II** (Medium) - Return the order
2. **[LeetCode 802] Find Eventual Safe States** (Medium)
3. **[LeetCode 310] Minimum Height Trees** (Medium)
4. **[LeetCode 269] Alien Dictionary** (Hard)

---

## 🏆 Key Takeaways

1. **Scheduling = Cycle Detection** in directed graph
2. **DFS with 3 colors** (white, gray, black) detects cycles
3. **BFS with in-degrees** (Kahn's algorithm) for topological sort
4. Both approaches are **O(V + E)** time and space
5. **Gray node = cycle** in DFS approach

---

## 💡 Interview Tips

**When asked about prerequisites/dependencies:**
- Recognize it as a **graph problem**
- Mention **cycle detection** vs **topological sort**
- Discuss **DFS** (recursive, easier) vs **BFS** (iterative, clearer)
- Consider **multiple disconnected components**

**Follow-up:** "Can you return the order?" → Course Schedule II (Problem 210)

---

**Ready to test?** 🚀 Move to **`17.Course-Schedule-Mock-Interview-Mode.md`**

*Happy Coding! 💻✨*
