# 🎤 Merge Two Sorted Lists - Mock Interview Mode

> **Difficulty:** 🟢 Easy  
> **Time Limit:** ⏱️ 20 minutes  
> **Problem Link:** [LeetCode #21](https://leetcode.com/problems/merge-two-sorted-lists/)  
> **Mock Interview:** Problem 5 of 5 - Final Challenge!

---

## ⚡ Interview Rules

- ⏱️ You have **20 minutes** to solve this problem
- 💡 You may request **up to 2 hints** (score penalty applies)
- 🎯 Focus on: Correctness, Pointer Management, Code Quality
- 🗣️ Explain your merge strategy clearly
- ✍️ Handle edge cases (empty lists, different lengths)

**This is your final problem in Session 1! Start your timer now!** ⏰

---

## 🧩 Problem Statement

You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists into one **sorted** list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

---

## 📝 Examples

**Example 1:**
```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

**Example 2:**
```
Input: list1 = [], list2 = []
Output: []
```

**Example 3:**
```
Input: list1 = [], list2 = [0]
Output: [0]
```

---

## 🔍 Constraints

- The number of nodes in both lists is in the range `[0, 50]`
- `-100 <= Node.val <= 100`
- Both `list1` and `list2` are sorted in **non-decreasing** order

---

## 📐 ListNode Definition

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

---

## 💭 Your Solution Space

### 🎯 Clarifying Questions to Consider:
- Are both lists sorted? (Yes, non-decreasing order)
- Can either list be empty? (Yes)
- Should I create new nodes or reuse existing? (Reuse existing)

<details>
<summary><b>🆘 Hint 1</b> (Click only if needed - Minor score penalty)</summary>

Think about the **merge** step in merge sort. You have two sorted sequences and you want to combine them.

Use **two pointers**, one for each list. At each step, compare the values and choose the smaller one. Don't forget to use a **dummy head** node to simplify building the result!

</details>

<details>
<summary><b>🆘 Hint 2</b> (Click only if needed - Moderate score penalty)</summary>

**Algorithm:**

```python
dummy = ListNode(0)
current = dummy

while list1 and list2:
    if list1.val <= list2.val:
        current.next = list1
        list1 = list1.next
    else:
        current.next = list2
        list2 = list2.next
    current = current.next

# Append remaining nodes (one list might still have nodes)
current.next = list1 if list1 else list2

return dummy.next
```

The key: Compare values, append smaller, move pointers forward!

</details>

---

## ✍️ Write Your Solution Below

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def mergeTwoLists(list1, list2):
    """
    Merge two sorted linked lists into one sorted list.
    
    Args:
        list1: ListNode - Head of first sorted linked list
        list2: ListNode - Head of second sorted linked list
    
    Returns:
        ListNode - Head of merged sorted linked list
    """
    # TODO: Implement your solution
    pass


# ─────────────────────────────────────────────────
# Helper functions (provided for testing)
# ─────────────────────────────────────────────────

def create_linked_list(arr):
    """Helper: Create linked list from array."""
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for val in arr[1:]:
        current.next = ListNode(val)
        current = current.next
    return head


def linked_list_to_array(head):
    """Helper: Convert linked list to array."""
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result


# ─────────────────────────────────────────────────
# Test your solution
# ─────────────────────────────────────────────────

if __name__ == "__main__":
    # Test Case 1: Normal merge
    list1 = create_linked_list([1, 2, 4])
    list2 = create_linked_list([1, 3, 4])
    result = mergeTwoLists(list1, list2)
    print(f"Test 1: {linked_list_to_array(result)}")  # Expected: [1,1,2,3,4,4]
    
    # Test Case 2: Both empty
    list1 = create_linked_list([])
    list2 = create_linked_list([])
    result = mergeTwoLists(list1, list2)
    print(f"Test 2: {linked_list_to_array(result)}")  # Expected: []
    
    # Test Case 3: One empty
    list1 = create_linked_list([])
    list2 = create_linked_list([0])
    result = mergeTwoLists(list1, list2)
    print(f"Test 3: {linked_list_to_array(result)}")  # Expected: [0]
    
    # Test Case 4: Different lengths
    list1 = create_linked_list([1, 2, 3, 4])
    list2 = create_linked_list([5])
    result = mergeTwoLists(list1, list2)
    print(f"Test 4: {linked_list_to_array(result)}")  # Expected: [1,2,3,4,5]
```

---

## ⏸️ Time's Up! Submit Your Solution

Once you've completed your solution (or time has expired), scroll down to see the evaluation.

<br><br><br><br><br>

---

# 📊 Interview Evaluation & Feedback

---

## ✅ Optimal Solution

```python
# Time Complexity: O(m + n) where m, n are list lengths
# Space Complexity: O(1) - Only pointer manipulation

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def mergeTwoLists(list1, list2):
    """
    Merge two sorted linked lists into one sorted list.
    
    Key insight: Like merge step in merge sort—compare front
    elements, take smaller, repeat.
    
    Args:
        list1: Head of first sorted linked list
        list2: Head of second sorted linked list
    
    Returns:
        Head of merged sorted linked list
    """
    # Create dummy head to simplify result construction
    dummy = ListNode(0)
    current = dummy
    
    # Merge while both lists have nodes
    while list1 and list2:
        # Compare values and choose smaller
        if list1.val <= list2.val:
            current.next = list1
            list1 = list1.next
        else:
            current.next = list2
            list2 = list2.next
        
        # Move current pointer forward
        current = current.next
    
    # Append remaining nodes (one list is exhausted)
    current.next = list1 if list1 else list2
    
    # Return result (skip dummy head)
    return dummy.next


# ✅ Alternative: Recursive Solution
def mergeTwoLists_recursive(list1, list2):
    """
    Elegant recursive approach.
    Space: O(m+n) due to call stack.
    """
    # Base cases
    if not list1:
        return list2
    if not list2:
        return list1
    
    # Recursive case: choose smaller head
    if list1.val <= list2.val:
        list1.next = mergeTwoLists_recursive(list1.next, list2)
        return list1
    else:
        list2.next = mergeTwoLists_recursive(list1, list2.next)
        return list2


# ✅ Comprehensive Test Suite
def test_solution():
    test_cases = [
        ([1, 2, 4], [1, 3, 4], [1, 1, 2, 3, 4, 4], "Normal merge"),
        ([], [], [], "Both empty"),
        ([], [0], [0], "First empty"),
        ([0], [], [0], "Second empty"),
        ([1, 2, 3, 4], [5], [1, 2, 3, 4, 5], "Different lengths"),
        ([1, 3, 5], [2, 4, 6], [1, 2, 3, 4, 5, 6], "Interleaved"),
        ([1, 1, 1], [1, 1], [1, 1, 1, 1, 1], "All duplicates"),
    ]
    
    for l1_arr, l2_arr, expected, description in test_cases:
        list1 = create_linked_list(l1_arr)
        list2 = create_linked_list(l2_arr)
        result = mergeTwoLists(list1, list2)
        result_arr = linked_list_to_array(result)
        
        status = "✅" if result_arr == expected else "❌"
        print(f"{status} {description}: {l1_arr} + {l2_arr} = {result_arr}")

test_solution()
```

---

## 🎯 Grading Rubric (Score: __/100)

### ✅ **Correctness (40 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Correct merge for normal cases | 12 | __ |
| Handles both lists empty | 8 | __ |
| Handles one list empty | 8 | __ |
| Handles different length lists | 7 | __ |
| Maintains sorted order | 5 | __ |

**Subtotal:** __/40

**Common Mistakes:**
- ❌ Not handling empty lists → **-10 points**
- ❌ Losing nodes (not appending remaining) → **-12 points**
- ❌ Wrong pointer updates (infinite loop or crash) → **-15 points**

---

### ⚙️ **Time Complexity (20 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Achieves O(m+n) single-pass solution | 15 | __ |
| Correctly analyzes complexity | 3 | __ |
| Explained approach before coding | 2 | __ |

**Subtotal:** __/20

**Issues:**
- ❌ Multiple passes through lists → **-8 points**
- ❌ Converting to array and sorting → **-12 points** (defeats purpose)

---

### 💾 **Space Complexity (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses O(1) space (iterative) | 12 | __ |
| No unnecessary data structures | 2 | __ |
| Correctly analyzes space | 1 | __ |

**Subtotal:** __/15

**Note:** Recursive solution uses O(m+n) call stack—mention this trade-off if you used recursion.

---

### ✍️ **Code Clarity & Style (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses dummy head technique | 4 | __ |
| Clear variable names (list1, list2, current) | 3 | __ |
| Proper pointer management | 3 | __ |
| Clean code structure | 3 | __ |
| Appropriate comments | 2 | __ |

**Subtotal:** __/15

**Best Practices:**
- ✅ Use dummy head (almost always for linked list construction)
- ✅ Clear names: `current`, not `c` or `ptr`
- ✅ Comment the key steps (compare, append, remaining)

---

### 🧪 **Tests & Edge Cases (10 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Tests normal merge | 2 | __ |
| Tests both empty lists | 3 | __ |
| Tests one empty list | 3 | __ |
| Tests different lengths | 2 | __ |

**Subtotal:** __/10

**Critical Edge Cases:**
- ✅ `[] + []` → `[]`
- ✅ `[1,2,3] + []` → `[1,2,3]`
- ✅ `[1,2,3,4] + [5]` → No overlap, append remainder

---

## 📈 **Bonus/Penalties**

| Item | Points | Your Score |
|------|--------|------------|
| ✅ Solved within time limit (20 min) | +5 | __ |
| ✅ No hints used | +5 | __ |
| ✅ Explained merge sort connection | +3 | __ |
| ✅ Implemented both iterative and recursive | +3 | __ |
| ✅ Drew diagram/walkthrough | +2 | __ |
| ❌ Used Hint 1 | -3 | __ |
| ❌ Used Hint 2 | -5 | __ |
| ❌ Exceeded time limit | -5 | __ |
| ❌ Forgot to append remaining nodes | -5 | __ |

**Bonus/Penalties:** __

---

## 🏆 **Final Score: __/100**

### Score Interpretation

| Range | Performance | Feedback |
|-------|-------------|----------|
| **90-100** | 🌟 Excellent | Perfect! You mastered linked list merging! |
| **75-89** | 👍 Good | Solid solution. Minor edge case or style issues. |
| **60-74** | 🤔 Fair | Got the idea but missed pointer management details. |
| **Below 60** | 📚 Needs Work | Review linked list fundamentals and dummy head pattern. |

---

## 💬 Detailed Feedback

### ✅ What You Did Well
- [ ] Used dummy head technique correctly
- [ ] Handled empty lists properly
- [ ] Maintained sorted order throughout
- [ ] Appended remaining nodes correctly
- [ ] Wrote clean, readable code
- [ ] Explained merge sort connection

### 🔧 Areas for Improvement
- [ ] **Dummy Head:** This technique simplifies linked list construction
- [ ] **Edge Cases:** Always test empty lists, single element, different lengths
- [ ] **Remaining Nodes:** Don't forget `current.next = list1 if list1 else list2`
- [ ] **Communication:** Mention "like merge step in merge sort"
- [ ] **Pointer Management:** Be careful with `.next` assignments

---

## 🎯 Actionable Next Steps

Based on your performance:

### 1️⃣ **If you struggled with Linked Lists:**
   - **Study:** Linked list basics (insertion, deletion, traversal)
   - **Practice:** 
     - Remove Duplicates from Sorted List (LC #83)
     - Reverse Linked List (LC #206)
   - **Focus:** Pointer manipulation and dummy head pattern

### 2️⃣ **If you forgot remaining nodes:**
   - **Common mistake:** Forgetting one list might be longer
   - **Remember:** After loop, append all remaining: `current.next = list1 or list2`
   - **Practice:** Walk through examples with different lengths

### 3️⃣ **If code clarity was an issue:**
   - **Pattern:** Dummy head is **standard** for linked list construction
   - **Practice:** Rewrite without dummy head to see why it's better
   - **Study:** Compare clean vs messy linked list code

---

## 🔄 Alternative Approaches Discussion

### Approach 1: Iterative with Dummy Head (Optimal ✅)
```python
def mergeTwoLists(list1, list2):
    dummy = ListNode(0)
    current = dummy
    
    while list1 and list2:
        if list1.val <= list2.val:
            current.next = list1
            list1 = list1.next
        else:
            current.next = list2
            list2 = list2.next
        current = current.next
    
    current.next = list1 if list1 else list2
    return dummy.next
```
**Time:** O(m+n), **Space:** O(1)  
**Pros:** Optimal in every way

### Approach 2: Recursive (Elegant)
```python
def mergeTwoLists(list1, list2):
    if not list1:
        return list2
    if not list2:
        return list1
    
    if list1.val <= list2.val:
        list1.next = mergeTwoLists(list1.next, list2)
        return list1
    else:
        list2.next = mergeTwoLists(list1, list2.next)
        return list2
```
**Time:** O(m+n), **Space:** O(m+n) call stack  
**Pros:** Elegant, concise  
**Cons:** Uses more space, potential stack overflow

### Approach 3: Convert to Array (Bad ❌)
```python
# Don't do this!
def mergeTwoLists_bad(list1, list2):
    # Convert to arrays
    arr1 = list_to_array(list1)
    arr2 = list_to_array(list2)
    # Merge arrays
    merged = sorted(arr1 + arr2)
    # Convert back to list
    return array_to_list(merged)
```
**Why bad:** Defeats the purpose, uses O(m+n) extra space, slower

---

## 🗣️ Interview Communication Examples

### ❌ Poor Communication
> "I'll go through both lists... *starts coding immediately*"

**Issues:**
- No algorithm explanation
- Didn't mention dummy head
- No edge case discussion

### ✅ Strong Communication
> "This is a classic merge operation—the same logic used in merge sort. I have two sorted sequences and need to combine them while maintaining order.
> 
> My approach:
> 1. Use a dummy head node to simplify construction
> 2. Use two pointers to track position in each list
> 3. At each step, compare values and choose the smaller one
> 4. After one list is exhausted, append all remaining nodes from the other
> 
> Edge cases: Both lists empty, one list empty, different lengths.
> 
> Time: O(m+n) since we visit each node once.
> Space: O(1) since we just rearrange pointers.
> 
> Let me code this up..."

**Strengths:**
- Related to merge sort (shows pattern knowledge)
- Clear algorithm steps
- Mentioned dummy head technique
- Stated edge cases
- Analyzed complexity

---

## 📚 Key Takeaways for Future Interviews

### 🔑 Linked List Patterns
1. **Dummy Head** - Use when building a new list
2. **Two Pointers** - For traversing two lists simultaneously
3. **Pointer Manipulation** - Carefully update `.next` references

### 🔑 Merge Pattern
- Always appears in: Merge sort, k-way merge, sorted list operations
- Key: Compare fronts, take smaller, repeat
- Don't forget remaining elements!

### 🔑 Common Mistakes
- Forgetting to append remaining nodes
- Not handling empty lists
- Creating new nodes instead of reusing
- Losing track of pointers

---

## 🎊 Session 1 Complete!

**🎉 Congratulations! You've finished all 5 problems! 🎉**

**Your Progress:**
- ✅ Problem 1: Two Sum (Hash Map)
- ✅ Problem 2: Add Two Numbers (Linked List)
- ✅ Problem 3: Valid Parentheses (Stack)
- ✅ Problem 4: Best Time to Buy/Sell Stock (Greedy)
- ✅ Problem 5: Merge Two Sorted Lists (Two Pointers)

**Patterns Mastered:**
- ✅ Hash Map for O(1) lookup
- ✅ Linked List manipulation (dummy head, traversal)
- ✅ Stack for LIFO operations
- ✅ Greedy algorithms with state tracking
- ✅ Two-pointer technique for sorted data

---

## 🎯 What's Next?

You now have **10 comprehensive files** (5 teaching + 5 mock interview) covering fundamental patterns!

**Recommended Next Steps:**

1. **📊 Track Your Scores**
   - Complete all 5 mock interviews
   - Record your scores
   - Identify weak patterns

2. **🔄 Practice Similar Problems**
   - Each file recommends 3-4 similar problems
   - Focus on your weakest pattern first

3. **⬆️ Move to Medium Difficulty**
   - Once you score 85+ on all mocks
   - Ready for Session 2

4. **💪 Real Interview Practice**
   - Mock interviews with friends
   - LeetCode contests
   - Interview prep platforms

---

<div align="center">

## 🏅 Final Self-Assessment

**Rate your overall Session 1 performance (1-5):**

| Problem | Understanding | Mock Score | Confidence |
|---------|---------------|------------|------------|
| Two Sum | __ | __/100 | __ |
| Add Two Numbers | __ | __/100 | __ |
| Valid Parentheses | __ | __/100 | __ |
| Best Time Buy/Sell | __ | __/100 | __ |
| Merge Two Lists | __ | __/100 | __ |

**Average Score:** __/100  
**Ready for Session 2?** __ (Yes/No)

</div>

---

*Remember: The goal isn't to memorize solutions—it's to recognize patterns and solve new problems using these techniques!* 💪

**You did it! Time to celebrate! 🎉🚀**
