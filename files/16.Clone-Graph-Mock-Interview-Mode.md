# ⏱️ MOCK INTERVIEW: Clone Graph

**Difficulty:** 🟡 Medium  
**Pattern:** Graph Traversal + Hash Map  
**Time Limit:** ⏰ **30 minutes**  
**Points:** 100

---

## 📋 Problem Statement

Given a reference of a node in a **connected undirected graph**, return a **deep copy** of the graph.

Each node contains:
```python
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
```

**Example:**
```
Graph: 1 -- 2 -- 3 -- 4
Return: A completely new graph with same structure
```

---

## 💡 Clarifying Questions

Before coding, ask:

1. Can the graph have cycles? **Yes**
2. Is it connected? **Yes**
3. Can there be duplicate values? **Yes, values can repeat**
4. What if input is None? **Return None**

---

## 💡 Optional Hints

<details>
<summary>🆘 Hint 1 (−10 points)</summary>

Use a **hash map** to track `original_node -> cloned_node` mapping. This prevents infinite loops and ensures each node is cloned exactly once.

</details>

<details>
<summary>🆘 Hint 2 (−15 points)</summary>

**DFS approach:**
```python
visited = {}

def dfs(node):
    if node in visited:
        return visited[node]
    
    clone = Node(node.val)
    visited[node] = clone
    
    for neighbor in node.neighbors:
        clone.neighbors.append(dfs(neighbor))
    
    return clone
```

</details>

<details>
<summary>🆘 Hint 3 (−20 points)</summary>

**BFS approach:**
```python
from collections import deque

visited = {node: Node(node.val)}
queue = deque([node])

while queue:
    current = queue.popleft()
    for neighbor in current.neighbors:
        if neighbor not in visited:
            visited[neighbor] = Node(neighbor.val)
            queue.append(neighbor)
        visited[current].neighbors.append(visited[neighbor])
```

</details>

---

## 🧑‍💻 Your Solution

```python
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

def cloneGraph(node: 'Node') -> 'Node':
    """
    Return a deep copy of the graph.
    """
    # Your code here
    pass
```

---

## ✅ Test Cases

```python
# Test Case 1: Empty graph
assert cloneGraph(None) == None

# Test Case 2: Single node
node1 = Node(1)
clone1 = cloneGraph(node1)
assert clone1.val == 1
assert len(clone1.neighbors) == 0
assert clone1 is not node1  # Different object!

# Test Case 3: Two connected nodes
node1 = Node(1)
node2 = Node(2)
node1.neighbors = [node2]
node2.neighbors = [node1]
clone = cloneGraph(node1)
assert clone.val == 1
assert clone.neighbors[0].val == 2
assert clone is not node1  # Deep copy!

# Test Case 4: Cycle
#   1 -- 2
#   |    |
#   4 -- 3
# Should handle without infinite loop
```

---

## 📊 Grading Rubric (100 points)

### Correctness (50 points)
- ✅ Handles empty graph (5 pts)
- ✅ Deep copy (not shallow) (10 pts)
- ✅ All nodes cloned (10 pts)
- ✅ All edges preserved (10 pts)
- ✅ Handles cycles correctly (15 pts)

### Time Complexity (20 points)
- ✅ O(N + E) solution (20 pts)
- ⚠️ O(N²) or worse (5 pts)

### Space Complexity (15 points)
- ✅ O(N) for hash map (15 pts)
- ⚠️ O(N²) or worse (5 pts)

### Code Quality (10 points)
- ✅ Clean, readable code (5 pts)
- ✅ Proper variable names (3 pts)
- ✅ Edge case handling (2 pts)

### Communication (5 points)
- ✅ Explained approach clearly (3 pts)
- ✅ Discussed trade-offs (2 pts)

---

## ✅ Optimal Solution

<details>
<summary>🔍 DFS Solution</summary>

```python
def cloneGraph(node: 'Node') -> 'Node':
    if not node:
        return None
    
    visited = {}
    
    def dfs(node):
        if node in visited:
            return visited[node]
        
        clone = Node(node.val)
        visited[node] = clone
        
        for neighbor in node.neighbors:
            clone.neighbors.append(dfs(neighbor))
        
        return clone
    
    return dfs(node)
```

**Time:** O(N + E) - visit each node and edge once  
**Space:** O(N) - hash map + recursion stack

</details>

<details>
<summary>🔍 BFS Solution</summary>

```python
from collections import deque

def cloneGraph(node: 'Node') -> 'Node':
    if not node:
        return None
    
    visited = {node: Node(node.val)}
    queue = deque([node])
    
    while queue:
        current = queue.popleft()
        
        for neighbor in current.neighbors:
            if neighbor not in visited:
                visited[neighbor] = Node(neighbor.val)
                queue.append(neighbor)
            
            visited[current].neighbors.append(visited[neighbor])
    
    return visited[node]
```

**Time:** O(N + E)  
**Space:** O(N)

</details>

---

## 🎯 Performance Summary

| Metric | Target | Your Score |
|--------|--------|------------|
| Correctness | 50 pts | ___/50 |
| Time Complexity | 20 pts | ___/20 |
| Space Complexity | 15 pts | ___/15 |
| Code Quality | 10 pts | ___/10 |
| Communication | 5 pts | ___/5 |
| **Hints Used** | 0 pts | −___ |
| **Total** | **100 pts** | **___/100** |

---

## 💭 Self-Reflection

1. Did you use a hash map to track visited nodes?
2. Did you handle cycles correctly?
3. Is your solution O(N + E) time?
4. Would you choose DFS or BFS in a real interview? Why?

---

*"Hash map is your friend for graph cloning!"* 🗺️✨
