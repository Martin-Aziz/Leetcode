# â±ï¸ MOCK INTERVIEW: Longest Substring Without Repeating Characters

**Difficulty:** ğŸŸ¡ Medium  
**Pattern:** Sliding Window  
**Time Limit:** â° **25 minutes**  
**Points:** 100

---

## ğŸ¯ Interview Simulation

You are in a real technical interview. The interviewer has just asked you this question. You have **25 minutes** to:
1. Clarify the problem (2-3 minutes)
2. Discuss your approach (3-5 minutes)
3. Write working code (12-15 minutes)
4. Test your solution (3-5 minutes)

**Start your timer NOW!** â°

---

## ğŸ“‹ Problem Statement

Given a string `s`, find the length of the **longest substring** without repeating characters.

### Examples:

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.

Input: s = "bbbbb"
Output: 1

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence.
```

### Constraints:
- `0 <= s.length <= 5 * 10^4`
- `s` consists of English letters, digits, symbols and spaces.

---

## â“ Clarifying Questions (Ask These!)

Before coding, ask:

1. **"Should I return the length or the actual substring?"**
   - Length only

2. **"What should I return for an empty string?"**
   - Return 0

3. **"Can the string contain spaces and special characters?"**
   - Yes, any printable ASCII characters

4. **"Is 'A' different from 'a'?"**
   - Yes, case-sensitive

5. **"Do I need to handle Unicode or just ASCII?"**
   - ASCII is fine

---

## ğŸ’­ Think Out Loud (Required!)

During the interview, you MUST verbalize:

### 1. Initial Observations
```
"I notice this is asking for a substring, not subsequence, so elements 
must be contiguous. I also notice we need to track unique characters..."
```

### 2. Approach Discussion
```
"I'm thinking of using the sliding window pattern because we need to find
a contiguous substring with a specific property. I'll use two pointers and
a hash set to track characters in the current window..."
```

### 3. Complexity Analysis
```
"My approach will be O(n) time because each character is visited at most
twice, and O(min(n,m)) space where m is the character set size..."
```

---

## ğŸ’¡ Optional Hints (Use Sparingly!)

<details>
<summary>ğŸ†˜ Hint 1: What pattern is this? (âˆ’5 points)</summary>

This is a **Sliding Window** problem. Use two pointers (`left` and `right`) to maintain a window of unique characters. When you encounter a duplicate, shrink the window from the left.

</details>

<details>
<summary>ğŸ†˜ Hint 2: What data structure tracks "seen" characters? (âˆ’10 points)</summary>

Use a **Hash Set** to track characters in the current window. This gives O(1) lookup to check if a character is already in the window.

Alternative: Use a **Hash Map** (character â†’ index) to jump directly to the position after a duplicate, avoiding the need to shrink one character at a time.

</details>

<details>
<summary>ğŸ†˜ Hint 3: How to handle duplicates? (âˆ’15 points)</summary>

When you encounter a duplicate character:
```python
while s[right] in seen:
    seen.remove(s[left])
    left += 1
```

This shrinks the window from the left until the duplicate is removed.

</details>

---

## ğŸ§‘â€ğŸ’» Your Solution Space

Write your solution here:

```python
def lengthOfLongestSubstring(s: str) -> int:
    """
    Find the length of the longest substring without repeating characters.
    
    Args:
        s: Input string
        
    Returns:
        Length of longest substring with all unique characters
    """
    # Your code here
    pass


# Test your solution
if __name__ == "__main__":
    # Basic test cases
    assert lengthOfLongestSubstring("abcabcbb") == 3
    assert lengthOfLongestSubstring("bbbbb") == 1
    assert lengthOfLongestSubstring("pwwkew") == 3
    assert lengthOfLongestSubstring("") == 0
    
    # Edge cases
    assert lengthOfLongestSubstring(" ") == 1
    assert lengthOfLongestSubstring("au") == 2
    assert lengthOfLongestSubstring("dvdf") == 3
    
    print("âœ… All tests passed!")
```

---

## â° Time Check!

- â±ï¸ **5 min:** Should have discussed approach
- â±ï¸ **15 min:** Should have working solution
- â±ï¸ **20 min:** Should be testing edge cases
- â±ï¸ **25 min:** TIME'S UP!

---

## âœ… Optimal Solution (Don't Look Until After!)

<details>
<summary><b>ğŸ” Click to Reveal Optimal Solution</b></summary>

### Solution 1: Sliding Window with Hash Set

```python
def lengthOfLongestSubstring(s: str) -> int:
    """
    Sliding window approach with hash set.
    
    Time: O(n) - each character visited at most twice
    Space: O(min(n, m)) - m is charset size
    """
    if not s:
        return 0
    
    seen = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # Shrink window until no duplicates
        while s[right] in seen:
            seen.remove(s[left])
            left += 1
        
        # Add current character
        seen.add(s[right])
        
        # Update max length
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### Solution 2: Optimized with Hash Map (Jump)

```python
def lengthOfLongestSubstring(s: str) -> int:
    """
    Optimized version using hash map to store indices.
    Can jump directly instead of shrinking one by one.
    
    Time: O(n) - each character visited exactly once
    Space: O(min(n, m))
    """
    char_index = {}
    max_length = 0
    left = 0
    
    for right in range(len(s)):
        # If character seen and is in current window
        if s[right] in char_index and char_index[s[right]] >= left:
            # Jump to position after duplicate
            left = char_index[s[right]] + 1
        
        # Update index
        char_index[s[right]] = right
        
        # Update max length
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

### Why This Is Optimal:

1. **Time: O(n)** - Can't do better than reading input once
2. **Space: O(min(n,m))** - Bounded by charset size
3. **Single pass** - No need to try all substrings O(nÂ²)
4. **No sorting** - Would be O(n log n) minimum

</details>

---

## ğŸ¯ Grading Rubric (100 Points Total)

### 1ï¸âƒ£ Correctness (40 points)

| Criteria | Points | Your Score |
|----------|--------|------------|
| Handles all basic test cases | 15 | ___ |
| Handles empty string | 5 | ___ |
| Handles single character | 5 | ___ |
| Handles all same characters | 5 | ___ |
| Handles all unique characters | 5 | ___ |
| Returns correct type (integer) | 5 | ___ |

### 2ï¸âƒ£ Time Complexity (20 points)

| Criteria | Points | Your Score |
|----------|--------|------------|
| Achieves O(n) solution | 15 | ___ |
| Correctly explains why O(n) | 5 | ___ |
| **Penalty:** O(nÂ²) brute force | -10 | ___ |

### 3ï¸âƒ£ Space Complexity (15 points)

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses O(min(n,m)) space | 10 | ___ |
| Correctly identifies space usage | 5 | ___ |
| **Penalty:** Uses unnecessary extra space | -5 | ___ |

### 4ï¸âƒ£ Code Quality (15 points)

| Criteria | Points | Your Score |
|----------|--------|------------|
| Clean, readable variable names | 4 | ___ |
| Proper code structure/organization | 4 | ___ |
| Handles edge cases gracefully | 4 | ___ |
| Comments on complex logic | 3 | ___ |

### 5ï¸âƒ£ Communication & Process (10 points)

| Criteria | Points | Your Score |
|----------|--------|------------|
| Asked clarifying questions | 3 | ___ |
| Explained approach before coding | 3 | ___ |
| Tested solution with examples | 2 | ___ |
| Discussed trade-offs | 2 | ___ |

---

## ğŸ“Š Bonus Points & Penalties

### ğŸŒŸ Bonus (Up to +15)

- **+10:** Provided both hash set and hash map solutions
- **+5:** Discussed why sliding window works (amortized analysis)
- **+5:** Identified this as a classic pattern
- **+3:** Mentioned variations (K distinct characters)

### âš ï¸ Penalties

- **âˆ’5:** Used a hint
- **âˆ’10:** Used two hints
- **âˆ’15:** Used all three hints
- **âˆ’20:** Solution doesn't compile/run
- **âˆ’30:** Solution is incorrect on basic test cases
- **âˆ’10:** Overtime (more than 25 minutes)

---

## ğŸ­ Detailed Feedback

### â­ Excellent Performance (90-100)
You demonstrated expert-level understanding of sliding window patterns! Your solution was optimal, well-communicated, and you caught edge cases. This is **HIRE** territory. You're ready for real interviews!

**Next Steps:**
- Try harder sliding window problems (LeetCode 76, 239)
- Practice explaining amortized O(n) analysis

---

### âœ… Strong Performance (75-89)
Good job! You understood the pattern and implemented a working solution. Minor improvements in code quality or edge case handling could push you to excellent.

**What Went Well:**
- Recognized sliding window pattern
- Implemented O(n) solution
- Tested basic cases

**Areas to Improve:**
- Add more edge case testing
- Improve variable naming
- Discuss trade-offs between approaches

---

### âš¡ Needs Improvement (60-74)
You're on the right track but need more practice. Maybe you got the solution but took too long, or had the right idea but struggled with implementation.

**Focus On:**
- Pattern recognition (review sliding window fundamentals)
- Implementation speed (practice more problems)
- Edge case identification

**Recommended Practice:**
- Review Session 1 two-pointer problems
- Practice LeetCode Easy sliding window problems first
- Redo this problem without hints

---

### âŒ Significant Issues (<60)
Don't be discouraged! This is a medium problem. If this is your first time with sliding window, it's normal to struggle.

**Action Plan:**
1. Study the teaching mode file thoroughly
2. Understand why sliding window works
3. Practice easier problems first:
   - LeetCode 26: Remove Duplicates
   - LeetCode 121: Best Time to Buy Stock (Session 1)
4. Return to this problem in 2-3 days

---

## ğŸ—£ï¸ Example Communication

### Strong Interview Communication:

> "Okay, so I need to find the longest substring without repeating characters. Let me make sure I understand - it's a **substring** not subsequence, so characters must be consecutive, right?"
>
> "I think this is a **sliding window problem** because we're looking for a contiguous section with a specific property. Here's my approach:"
>
> 1. "I'll use two pointers, `left` and `right`, to represent my window boundaries"
> 2. "I'll use a hash set to track characters in the current window for O(1) lookup"
> 3. "I'll expand `right` to grow the window, and when I find a duplicate, I'll shrink from `left`"
> 4. "I'll track the maximum window size throughout"
>
> "The time complexity will be O(n) because even though there's a while loop inside the for loop, each character is added and removed from the set at most once, giving us amortized O(n)."
>
> "The space complexity is O(min(n, m)) where m is the character set size - at most 128 for ASCII."
>
> "Let me code this up..."
>
> [After coding]
>
> "Let me test with the examples. For 'abcabcbb', I expect 3..."
>
> "I should also test edge cases: empty string returns 0, single character returns 1, all same characters returns 1..."

---

## ğŸ¯ Key Takeaways

### âœ… What Makes This Solution Strong:

1. **Optimal Complexity:** O(n) time, O(min(n,m)) space
2. **Pattern Recognition:** Correctly identified as sliding window
3. **Clean Implementation:** Two pointers + hash set/map
4. **Edge Cases:** Handled empty, single char, all same, all unique

### âŒ Common Mistakes:

1. **Using O(nÂ²) brute force:** Checking all substrings
2. **Wrong window size formula:** Using `right - left` instead of `right - left + 1`
3. **Forgetting to remove from set:** When shrinking window
4. **Not handling empty string:** Missing edge case
5. **Confusing substring vs subsequence:** Reading problem too quickly

### ğŸ”‘ Interview Success Factors:

1. **Ask clarifying questions** before jumping to code
2. **Explain your approach** before implementing
3. **Think out loud** while coding
4. **Test with examples** including edge cases
5. **Discuss trade-offs** between different approaches

---

## ğŸ“ˆ Your Performance Summary

**Fill this out after completing the mock interview:**

| Metric | Your Result |
|--------|-------------|
| **Total Score** | ___/100 |
| **Time Taken** | ___ min |
| **Hints Used** | ___ |
| **Test Cases Passed** | ___/7 |
| **Interview Ready?** | Yes / No |

**Key Strengths:**
- ___________________________
- ___________________________

**Areas to Improve:**
- ___________________________
- ___________________________

**Next Steps:**
- ___________________________

---

## ğŸ“ Pattern Mastery Tracker

After this problem, you should understand:

- âœ… Sliding window pattern fundamentals
- âœ… Two-pointer technique for variable windows
- âœ… Hash set vs hash map trade-offs
- âœ… Amortized time complexity analysis
- âœ… When to expand vs shrink a window

**Confidence Level (Rate 1-5):**
- Sliding Window Pattern: ___/5
- Two Pointers: ___/5
- Hash-based tracking: ___/5

---

## ğŸš€ Next Challenge

Ready for the next pattern?

**Continue to:** `7.Binary-Search-Teaching-Mode.md`

**Or strengthen sliding window:**
- [LeetCode 76] Minimum Window Substring (Hard)
- [LeetCode 438] Find All Anagrams (Medium)
- [LeetCode 567] Permutation in String (Medium)

---

**Good luck! Remember: The goal isn't just to solve it, but to communicate your thought process clearly!** ğŸ’ªâœ¨

---

*"In an interview, your solution is only 50% of your performance. The other 50% is how you communicate it."* ğŸ¯
