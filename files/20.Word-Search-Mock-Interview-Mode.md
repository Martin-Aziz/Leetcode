# â±ï¸ MOCK INTERVIEW: Word Search

**Difficulty:** ğŸŸ¡ Medium  
**Pattern:** Backtracking on Grid  
**Time Limit:** â° **25 minutes**  
**Points:** 100

---

## ğŸ“‹ Problem Statement

Given an `m x n` board and a string `word`, return `true` if `word` exists in the grid.

The word must be constructed from sequentially **adjacent cells** (horizontal or vertical). Each cell can be used **at most once**.

```
Board:
A B C E
S F C S
A D E E

Word: "ABCCED" â†’ True
Word: "SEE" â†’ True  
Word: "ABCB" â†’ False (can't reuse B)
```

---

## ğŸ’¡ Clarifying Questions

1. Only uppercase English letters? **Yes**
2. Can word be longer than board size? **No, word length â‰¤ mÃ—n**
3. Can board be empty? **No, at least 1Ã—1**
4. Diagonal movement allowed? **No, only horizontal/vertical**

---

## ğŸ’¡ Optional Hints

<details>
<summary>ğŸ†˜ Hint 1 (âˆ’10 points)</summary>

Use **DFS + backtracking**. Try starting from each cell. Mark cells as visited, then unmark when backtracking.

</details>

<details>
<summary>ğŸ†˜ Hint 2 (âˆ’15 points)</summary>

**Template:**
```python
def backtrack(row, col, index):
    if index == len(word):
        return True
    if out_of_bounds or wrong_char:
        return False
    
    mark_visited()
    result = try_four_directions()
    unmark_visited()
    
    return result
```

</details>

<details>
<summary>ğŸ†˜ Hint 3 (âˆ’20 points)</summary>

```python
def backtrack(row, col, index):
    if index == len(word):
        return True
    if (row < 0 or row >= rows or col < 0 or col >= cols or 
        board[row][col] != word[index]):
        return False
    
    temp = board[row][col]
    board[row][col] = '#'  # Mark visited
    
    found = (backtrack(row+1, col, index+1) or
             backtrack(row-1, col, index+1) or
             backtrack(row, col+1, index+1) or
             backtrack(row, col-1, index+1))
    
    board[row][col] = temp  # Restore
    return found
```

</details>

---

## ğŸ§‘â€ğŸ’» Your Solution

```python
def exist(board: list[list[str]], word: str) -> bool:
    """
    Return True if word exists in board.
    """
    # Your code here
    pass
```

---

## âœ… Test Cases

```python
# Test 1: Word exists
board = [["A","B","C","E"],
         ["S","F","C","S"],
         ["A","D","E","E"]]
assert exist(board, "ABCCED") == True

# Test 2: Word exists (different path)
assert exist(board, "SEE") == True

# Test 3: Can't reuse cell
assert exist(board, "ABCB") == False

# Test 4: Single cell
board = [["A"]]
assert exist(board, "A") == True

# Test 5: Word not in board
board = [["A","B"],["C","D"]]
assert exist(board, "ABCD") == False
```

---

## ğŸ“Š Grading Rubric (100 points)

### Correctness (50 points)
- âœ… Finds existing words (15 pts)
- âœ… Prevents cell reuse (15 pts)
- âœ… Tries all starting positions (10 pts)
- âœ… Handles edge cases (10 pts)

### Time Complexity (20 points)
- âœ… O(mÃ—nÃ—4^L) solution (20 pts)
- âš ï¸ Significantly worse (5 pts)

### Space Complexity (15 points)
- âœ… O(L) recursion stack (15 pts)
- âš ï¸ Excessive space (5 pts)

### Code Quality (10 points)
- âœ… Clean backtracking logic (5 pts)
- âœ… Proper bounds checking (3 pts)
- âœ… Correct restore state (2 pts)

### Communication (5 points)
- âœ… Explained backtracking (3 pts)
- âœ… Discussed 4 directions (2 pts)

---

## âœ… Optimal Solution

<details>
<summary>ğŸ” In-place Marking Solution</summary>

```python
def exist(board, word):
    if not board or not board[0]:
        return False
    
    rows, cols = len(board), len(board[0])
    
    def backtrack(row, col, index):
        if index == len(word):
            return True
        
        if (row < 0 or row >= rows or 
            col < 0 or col >= cols or 
            board[row][col] != word[index]):
            return False
        
        temp = board[row][col]
        board[row][col] = '#'
        
        found = (backtrack(row + 1, col, index + 1) or
                 backtrack(row - 1, col, index + 1) or
                 backtrack(row, col + 1, index + 1) or
                 backtrack(row, col - 1, index + 1))
        
        board[row][col] = temp
        return found
    
    for row in range(rows):
        for col in range(cols):
            if backtrack(row, col, 0):
                return True
    
    return False
```

**Time:** O(mÃ—nÃ—4^L) | **Space:** O(L)

</details>

<details>
<summary>ğŸ” Visited Set Solution</summary>

```python
def exist(board, word):
    rows, cols = len(board), len(board[0])
    visited = set()
    
    def backtrack(row, col, index):
        if index == len(word):
            return True
        
        if (row < 0 or row >= rows or 
            col < 0 or col >= cols or 
            (row, col) in visited or
            board[row][col] != word[index]):
            return False
        
        visited.add((row, col))
        
        found = (backtrack(row + 1, col, index + 1) or
                 backtrack(row - 1, col, index + 1) or
                 backtrack(row, col + 1, index + 1) or
                 backtrack(row, col - 1, index + 1))
        
        visited.remove((row, col))
        return found
    
    for row in range(rows):
        for col in range(cols):
            if backtrack(row, col, 0):
                return True
    
    return False
```

**Time:** O(mÃ—nÃ—4^L) | **Space:** O(L)

</details>

---

## ğŸ¯ Performance Summary

| Metric | Target | Your Score |
|--------|--------|------------|
| Correctness | 50 pts | ___/50 |
| Time Complexity | 20 pts | ___/20 |
| Space Complexity | 15 pts | ___/15 |
| Code Quality | 10 pts | ___/10 |
| Communication | 5 pts | ___/5 |
| **Hints Used** | 0 pts | âˆ’___ |
| **Total** | **100 pts** | **___/100** |

---

## ğŸ’­ Self-Reflection

1. Did you remember to restore cell state after backtracking?
2. Did you try all possible starting positions?
3. How would you optimize for multiple words?
4. In-place marking vs visited set - which did you choose?

---

*"Explore, mark, backtrack!"* ğŸ”âœ¨
