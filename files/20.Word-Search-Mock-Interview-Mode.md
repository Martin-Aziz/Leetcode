# ⏱️ MOCK INTERVIEW: Word Search

**Difficulty:** 🟡 Medium  
**Pattern:** Backtracking on Grid  
**Time Limit:** ⏰ **25 minutes**  
**Points:** 100

---

## 📋 Problem Statement

Given an `m x n` board and a string `word`, return `true` if `word` exists in the grid.

The word must be constructed from sequentially **adjacent cells** (horizontal or vertical). Each cell can be used **at most once**.

```
Board:
A B C E
S F C S
A D E E

Word: "ABCCED" → True
Word: "SEE" → True  
Word: "ABCB" → False (can't reuse B)
```

---

## 💡 Clarifying Questions

1. Only uppercase English letters? **Yes**
2. Can word be longer than board size? **No, word length ≤ m×n**
3. Can board be empty? **No, at least 1×1**
4. Diagonal movement allowed? **No, only horizontal/vertical**

---

## 💡 Optional Hints

<details>
<summary>🆘 Hint 1 (−10 points)</summary>

Use **DFS + backtracking**. Try starting from each cell. Mark cells as visited, then unmark when backtracking.

</details>

<details>
<summary>🆘 Hint 2 (−15 points)</summary>

**Template:**
```python
def backtrack(row, col, index):
    if index == len(word):
        return True
    if out_of_bounds or wrong_char:
        return False
    
    mark_visited()
    result = try_four_directions()
    unmark_visited()
    
    return result
```

</details>

<details>
<summary>🆘 Hint 3 (−20 points)</summary>

```python
def backtrack(row, col, index):
    if index == len(word):
        return True
    if (row < 0 or row >= rows or col < 0 or col >= cols or 
        board[row][col] != word[index]):
        return False
    
    temp = board[row][col]
    board[row][col] = '#'  # Mark visited
    
    found = (backtrack(row+1, col, index+1) or
             backtrack(row-1, col, index+1) or
             backtrack(row, col+1, index+1) or
             backtrack(row, col-1, index+1))
    
    board[row][col] = temp  # Restore
    return found
```

</details>

---

## 🧑‍💻 Your Solution

```python
def exist(board: list[list[str]], word: str) -> bool:
    """
    Return True if word exists in board.
    """
    # Your code here
    pass
```

---

## ✅ Test Cases

```python
# Test 1: Word exists
board = [["A","B","C","E"],
         ["S","F","C","S"],
         ["A","D","E","E"]]
assert exist(board, "ABCCED") == True

# Test 2: Word exists (different path)
assert exist(board, "SEE") == True

# Test 3: Can't reuse cell
assert exist(board, "ABCB") == False

# Test 4: Single cell
board = [["A"]]
assert exist(board, "A") == True

# Test 5: Word not in board
board = [["A","B"],["C","D"]]
assert exist(board, "ABCD") == False
```

---

## 📊 Grading Rubric (100 points)

### Correctness (50 points)
- ✅ Finds existing words (15 pts)
- ✅ Prevents cell reuse (15 pts)
- ✅ Tries all starting positions (10 pts)
- ✅ Handles edge cases (10 pts)

### Time Complexity (20 points)
- ✅ O(m×n×4^L) solution (20 pts)
- ⚠️ Significantly worse (5 pts)

### Space Complexity (15 points)
- ✅ O(L) recursion stack (15 pts)
- ⚠️ Excessive space (5 pts)

### Code Quality (10 points)
- ✅ Clean backtracking logic (5 pts)
- ✅ Proper bounds checking (3 pts)
- ✅ Correct restore state (2 pts)

### Communication (5 points)
- ✅ Explained backtracking (3 pts)
- ✅ Discussed 4 directions (2 pts)

---

## ✅ Optimal Solution

<details>
<summary>🔍 In-place Marking Solution</summary>

```python
def exist(board, word):
    if not board or not board[0]:
        return False
    
    rows, cols = len(board), len(board[0])
    
    def backtrack(row, col, index):
        if index == len(word):
            return True
        
        if (row < 0 or row >= rows or 
            col < 0 or col >= cols or 
            board[row][col] != word[index]):
            return False
        
        temp = board[row][col]
        board[row][col] = '#'
        
        found = (backtrack(row + 1, col, index + 1) or
                 backtrack(row - 1, col, index + 1) or
                 backtrack(row, col + 1, index + 1) or
                 backtrack(row, col - 1, index + 1))
        
        board[row][col] = temp
        return found
    
    for row in range(rows):
        for col in range(cols):
            if backtrack(row, col, 0):
                return True
    
    return False
```

**Time:** O(m×n×4^L) | **Space:** O(L)

</details>

<details>
<summary>🔍 Visited Set Solution</summary>

```python
def exist(board, word):
    rows, cols = len(board), len(board[0])
    visited = set()
    
    def backtrack(row, col, index):
        if index == len(word):
            return True
        
        if (row < 0 or row >= rows or 
            col < 0 or col >= cols or 
            (row, col) in visited or
            board[row][col] != word[index]):
            return False
        
        visited.add((row, col))
        
        found = (backtrack(row + 1, col, index + 1) or
                 backtrack(row - 1, col, index + 1) or
                 backtrack(row, col + 1, index + 1) or
                 backtrack(row, col - 1, index + 1))
        
        visited.remove((row, col))
        return found
    
    for row in range(rows):
        for col in range(cols):
            if backtrack(row, col, 0):
                return True
    
    return False
```

**Time:** O(m×n×4^L) | **Space:** O(L)

</details>

---

## 🎯 Performance Summary

| Metric | Target | Your Score |
|--------|--------|------------|
| Correctness | 50 pts | ___/50 |
| Time Complexity | 20 pts | ___/20 |
| Space Complexity | 15 pts | ___/15 |
| Code Quality | 10 pts | ___/10 |
| Communication | 5 pts | ___/5 |
| **Hints Used** | 0 pts | −___ |
| **Total** | **100 pts** | **___/100** |

---

## 💭 Self-Reflection

1. Did you remember to restore cell state after backtracking?
2. Did you try all possible starting positions?
3. How would you optimize for multiple words?
4. In-place marking vs visited set - which did you choose?

---

*"Explore, mark, backtrack!"* 🔍✨
