# 🎤 Add Two Numbers - Mock Interview Mode

> **Difficulty:** 🟡 Medium  
> **Time Limit:** ⏱️ 25 minutes  
> **Problem Link:** [LeetCode #2](https://leetcode.com/problems/add-two-numbers/)  
> **Mock Interview:** Problem 2 of 5

---

## ⚡ Interview Rules

- ⏱️ You have **25 minutes** to solve this problem
- 💡 You may request **up to 2 hints** (score penalty applies)
- 🎯 Focus on: Correctness, Efficiency, Code Quality, Edge Cases
- 🗣️ Explain your approach clearly before coding
- ✍️ Handle edge cases (different lengths, carries)

**Start your timer now!** ⏰

---

## 🧩 Problem Statement

You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

---

## 📝 Examples

**Example 1:**
```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807
```

**Example 2:**
```
Input: l1 = [0], l2 = [0]
Output: [0]
```

**Example 3:**
```
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
```

---

## 🔍 Constraints

- The number of nodes in each linked list is in the range `[1, 100]`
- `0 <= Node.val <= 9`
- It is guaranteed that the list represents a number that does not have leading zeros

---

## 📐 ListNode Definition

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

---

## 💭 Your Solution Space

### 🎯 Clarifying Questions to Consider:
- What happens if the lists are different lengths?
- What if adding two digits produces a carry?
- What if there's a carry at the very end?

<details>
<summary><b>🆘 Hint 1</b> (Click only if needed - Minor score penalty)</summary>

Think about how you add numbers by hand:
- Start from the rightmost digit (but here, they're already in reverse!)
- Add corresponding digits plus any carry from previous position
- Write down the ones digit, carry the tens digit to next position
- Continue until all digits processed AND no carry remains

Use a **dummy head node** to simplify building the result list.

Key: Your loop condition should be `while l1 or l2 or carry` to handle all cases.

</details>

<details>
<summary><b>🆘 Hint 2</b> (Click only if needed - Moderate score penalty)</summary>

**Core algorithm:**

```python
dummy = ListNode(0)
current = dummy
carry = 0

while l1 or l2 or carry:
    val1 = l1.val if l1 else 0
    val2 = l2.val if l2 else 0
    
    total = val1 + val2 + carry
    carry = total // 10      # Integer division
    digit = total % 10       # Modulo for ones place
    
    current.next = ListNode(digit)
    current = current.next
    
    l1 = l1.next if l1 else None
    l2 = l2.next if l2 else None

return dummy.next
```

The trick: Use `//` and `%` to extract carry and digit from the total.

</details>

---

## ✍️ Write Your Solution Below

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def addTwoNumbers(l1, l2):
    """
    Add two numbers represented as reversed linked lists.
    
    Args:
        l1: ListNode - Head of first linked list
        l2: ListNode - Head of second linked list
    
    Returns:
        ListNode - Head of result linked list
    """
    # TODO: Implement your solution
    pass


# ─────────────────────────────────────────────────
# Helper functions for testing (provided)
# ─────────────────────────────────────────────────

def create_linked_list(arr):
    """Helper: Create linked list from array."""
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for val in arr[1:]:
        current.next = ListNode(val)
        current = current.next
    return head


def linked_list_to_array(head):
    """Helper: Convert linked list to array for testing."""
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result


# ─────────────────────────────────────────────────
# Test your solution here
# ─────────────────────────────────────────────────

if __name__ == "__main__":
    # Test Case 1: Basic addition
    l1 = create_linked_list([2, 4, 3])
    l2 = create_linked_list([5, 6, 4])
    result = addTwoNumbers(l1, l2)
    print(f"Test 1: {linked_list_to_array(result)}")  # Expected: [7, 0, 8]
    
    # Test Case 2: Zero addition
    l1 = create_linked_list([0])
    l2 = create_linked_list([0])
    result = addTwoNumbers(l1, l2)
    print(f"Test 2: {linked_list_to_array(result)}")  # Expected: [0]
    
    # Test Case 3: Different lengths with carry
    l1 = create_linked_list([9, 9, 9, 9, 9, 9, 9])
    l2 = create_linked_list([9, 9, 9, 9])
    result = addTwoNumbers(l1, l2)
    print(f"Test 3: {linked_list_to_array(result)}")  # Expected: [8,9,9,9,0,0,0,1]
    
    # Test Case 4: Carry at the end
    l1 = create_linked_list([9, 9])
    l2 = create_linked_list([1])
    result = addTwoNumbers(l1, l2)
    print(f"Test 4: {linked_list_to_array(result)}")  # Expected: [0, 0, 1]
```

---

## ⏸️ Time's Up! Submit Your Solution

Once you've completed your solution (or time has expired), scroll down to see the evaluation.

<br><br><br><br><br>

---

# 📊 Interview Evaluation & Feedback

---

## ✅ Optimal Solution

```python
# Time Complexity: O(max(m, n)) where m, n are list lengths
# Space Complexity: O(max(m, n)) for the result list

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def addTwoNumbers(l1, l2):
    """
    Add two numbers represented as reversed linked lists.
    
    Key insight: Digits are already in reverse order (ones place first),
    so we can add left-to-right while tracking carry.
    
    Args:
        l1: Head of first linked list
        l2: Head of second linked list
    
    Returns:
        Head of result linked list
    """
    # Create dummy head to simplify result construction
    dummy = ListNode(0)
    current = dummy
    carry = 0
    
    # Continue while either list has nodes OR carry exists
    while l1 or l2 or carry:
        # Get values (0 if node is None)
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        
        # Calculate sum with carry
        total = val1 + val2 + carry
        
        # Extract digit and new carry
        carry = total // 10  # Integer division
        digit = total % 10   # Modulo for ones place
        
        # Create new node
        current.next = ListNode(digit)
        current = current.next
        
        # Move to next nodes
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None
    
    # Return result (skip dummy head)
    return dummy.next


# ✅ Comprehensive Test Suite
def test_solution():
    test_cases = [
        ([2, 4, 3], [5, 6, 4], [7, 0, 8], "342 + 465 = 807"),
        ([0], [0], [0], "0 + 0 = 0"),
        ([9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9], [8, 9, 9, 9, 0, 0, 0, 1], "9999999 + 9999 = 10009998"),
        ([9, 9], [1], [0, 0, 1], "99 + 1 = 100"),
        ([1, 8], [0], [1, 8], "81 + 0 = 81"),
        ([5], [5], [0, 1], "5 + 5 = 10"),
    ]
    
    for l1_arr, l2_arr, expected, description in test_cases:
        l1 = create_linked_list(l1_arr)
        l2 = create_linked_list(l2_arr)
        result = addTwoNumbers(l1, l2)
        result_arr = linked_list_to_array(result)
        
        status = "✅" if result_arr == expected else "❌"
        print(f"{status} {description}")
        if result_arr != expected:
            print(f"   Expected: {expected}, Got: {result_arr}")

test_solution()
```

---

## 🎯 Grading Rubric (Score: __/100)

### ✅ **Correctness (40 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Correct output for basic cases | 10 | __ |
| Handles different length lists | 10 | __ |
| Handles carry propagation correctly | 10 | __ |
| Handles final carry (e.g., 99+1=100) | 5 | __ |
| Returns proper linked list (not array) | 5 | __ |

**Subtotal:** __/40

**Common Mistakes:**
- ❌ Forgetting final carry → **-10 points**
- ❌ Not handling different lengths → **-10 points**
- ❌ Wrong carry calculation → **-10 points**

---

### ⚙️ **Time Complexity (20 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Achieves O(max(m,n)) single-pass solution | 15 | __ |
| Correctly analyzes time complexity | 3 | __ |
| Explains approach before coding | 2 | __ |

**Subtotal:** __/20

**Issues to avoid:**
- ❌ Converting to integers first (overflow issues) → **-10 points**
- ❌ Multiple passes through lists → **-5 points**

---

### 💾 **Space Complexity (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses O(max(m,n)) space for result | 10 | __ |
| Only O(1) extra space (carry, pointers) | 3 | __ |
| Correctly analyzes space complexity | 2 | __ |

**Subtotal:** __/15

---

### ✍️ **Code Clarity & Style (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses dummy head technique correctly | 4 | __ |
| Clear variable names (carry, current, val1, val2) | 3 | __ |
| Proper comments explaining key steps | 3 | __ |
| Clean code structure | 3 | __ |
| No redundant code | 2 | __ |

**Subtotal:** __/15

**Best Practices:**
- ✅ Use `dummy = ListNode(0)` to simplify list building
- ✅ Clear names: `carry`, `current`, not `c`, `curr`
- ✅ Comment the tricky parts (carry extraction, loop condition)

---

### 🧪 **Tests & Edge Cases (10 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Tests basic addition (Example 1) | 2 | __ |
| Tests different length lists | 3 | __ |
| Tests final carry case (99+1=100) | 3 | __ |
| Discusses zero case or single nodes | 2 | __ |

**Subtotal:** __/10

**Critical Edge Cases:**
- ✅ `[9,9] + [1]` → `[0,0,1]` (final carry!)
- ✅ `[0] + [0]` → `[0]`
- ✅ Different lengths: `[1,2,3] + [4,5]`

---

## 📈 **Bonus/Penalties**

| Item | Points | Your Score |
|------|--------|------------|
| ✅ Solved within time limit (25 min) | +5 | __ |
| ✅ No hints used | +5 | __ |
| ✅ Drew diagram explaining approach | +3 | __ |
| ✅ Explained dummy head technique | +2 | __ |
| ✅ Mentioned elementary addition analogy | +2 | __ |
| ❌ Used Hint 1 | -3 | __ |
| ❌ Used Hint 2 | -5 | __ |
| ❌ Exceeded time limit | -5 | __ |
| ❌ Forgot to handle final carry | -5 | __ |

**Bonus/Penalties:** __

---

## 🏆 **Final Score: __/100**

### Score Interpretation

| Range | Performance | Feedback |
|-------|-------------|----------|
| **90-100** | 🌟 Excellent | Strong hire! You handled linked lists confidently. |
| **75-89** | 👍 Good | Solid solution. Minor edge case or clarity issues. |
| **60-74** | 🤔 Fair | Got the idea but missed key details (carry, etc.). |
| **Below 60** | 📚 Needs Work | Review linked list basics and carry logic. |

---

## 💬 Detailed Feedback

### ✅ What You Did Well
- [ ] Identified the dummy head pattern immediately
- [ ] Handled carry propagation correctly
- [ ] Wrote clean, readable code
- [ ] Tested edge cases thoroughly
- [ ] Explained approach clearly before coding

### 🔧 Areas for Improvement
- [ ] **Final Carry:** Remember to check carry even after both lists end
- [ ] **Loop Condition:** Must be `while l1 or l2 or carry`, not just `while l1 or l2`
- [ ] **Dummy Head:** Using a dummy simplifies code—practice this technique
- [ ] **Edge Cases:** Always test: different lengths, carries, zeros
- [ ] **Communication:** Draw the addition process to show understanding

---

## 🎯 Actionable Next Steps

Based on your performance, here are **3 targeted exercises**:

### 1️⃣ **If you struggled with Linked Lists:**
   - **Practice:** Merge Two Sorted Lists (LC #21)
   - **Practice:** Reverse Linked List (LC #206)
   - **Focus:** Pointer manipulation, dummy head technique

### 2️⃣ **If you missed the carry logic:**
   - **Study:** Review elementary addition algorithm
   - **Practice:** Add Binary (LC #67) - Same pattern with strings
   - **Focus:** Integer division (`//`) and modulo (`%`) operators

### 3️⃣ **If edge cases were an issue:**
   - **Practice:** Write test cases BEFORE coding
   - **Exercise:** List all possible edge cases for linked list problems:
     - Different lengths
     - One list is much longer
     - Result longer than both inputs (final carry)
     - Zero values
   - **Focus:** Systematic edge case analysis

---

## 🔄 Alternative Approaches Discussion

### Approach 1: Convert to Integer, Add, Convert Back
```python
def addTwoNumbers_naive(l1, l2):
    # Convert lists to integers
    num1 = list_to_int(l1)
    num2 = list_to_int(l2)
    # Add
    total = num1 + num2
    # Convert back to list
    return int_to_list(total)
```
**Pros:** Intuitive  
**Cons:** 
- Overflow for very large numbers (> 10^15 in Python int, but arbitrary precision helps)
- Inefficient: requires conversion overhead
- **Not what interviewer wants to see!**

### Approach 2: Digit-by-Digit with Carry (Optimal ✅)
```python
def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0
    
    while l1 or l2 or carry:
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        total = val1 + val2 + carry
        carry = total // 10
        current.next = ListNode(total % 10)
        current = current.next
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None
    
    return dummy.next
```
**Pros:** 
- Efficient: O(max(m,n)) time, single pass
- Handles arbitrary precision
- Direct simulation of addition algorithm

### Approach 3: Recursive Solution
```python
def addTwoNumbers_recursive(l1, l2, carry=0):
    if not l1 and not l2 and carry == 0:
        return None
    
    val1 = l1.val if l1 else 0
    val2 = l2.val if l2 else 0
    total = val1 + val2 + carry
    
    result = ListNode(total % 10)
    result.next = addTwoNumbers_recursive(
        l1.next if l1 else None,
        l2.next if l2 else None,
        total // 10
    )
    return result
```
**Pros:** Elegant, concise  
**Cons:** Uses call stack (O(n) space for recursion)

---

## 🗣️ Interview Communication Examples

### ❌ Poor Communication
> "I'll iterate through both lists and add them... *starts coding immediately*"

**Issues:**
- No mention of carry handling
- No discussion of edge cases
- Didn't explain dummy head

### ✅ Strong Communication
> "This is like elementary addition—we add digit by digit from right to left. Fortunately, the digits are already reversed, so we can process left-to-right.
> 
> I'll use a dummy head node to simplify building the result list. For each position, I'll:
> 1. Get the values from both lists (or 0 if a list has ended)
> 2. Add them plus any carry from the previous position
> 3. Use modulo 10 to get the digit, and integer division to get the new carry
> 4. Continue until both lists are exhausted AND no carry remains
>
> The key insight is the loop condition: `while l1 or l2 or carry`. This handles different-length lists and the final carry case, like when 99 + 1 = 100.
>
> Let me draw a quick example..."
> 
> *[Draws: 9→9 + 1 showing carry propagation]*

**Strengths:**
- Clear analogy (elementary addition)
- Explained algorithm step-by-step
- Mentioned critical edge case (final carry)
- Visual aid (drawing)

---

## 📚 Key Takeaways for Future Interviews

### 🔑 Linked List Patterns
1. **Dummy Head** - Almost always useful when building a new list
2. **Two Pointers** - Track multiple lists simultaneously
3. **Null Checks** - Use ternary: `val = node.val if node else 0`

### 🔑 Math Simulation Patterns
1. **Carry Management** - Track overflow between iterations
2. **Modulo & Integer Division** - Extract digits: `%10` and `//10`
3. **Continue Until All Consumed** - Don't forget final carry!

### 🔑 Interview Best Practices
1. **Draw It First** - Visual explanation builds trust
2. **State Edge Cases** - Show systematic thinking
3. **Explain Trade-offs** - "I could convert to int, but carry-based is better for large numbers"

---

## 🎯 What's Next?

You've completed **Mock Interview Problem 2 of 5**! 

**Your Progress:**
- ✅ Problem 1: Two Sum (Hash Map)
- ✅ Problem 2: Add Two Numbers (Linked List)
- ⬜ Problem 3: Coming next...

**Your Options:**
1. 📘 **Review Teaching Mode** - Deep dive into linked list patterns
2. 🔄 **Continue to Problem 3** - Build momentum
3. 📊 **Compare Problem 1 & 2** - See pattern connections
4. 🎤 **Request Detailed Feedback** - I'll analyze your specific solution

---

<div align="center">

## 🏅 Self-Assessment

**Rate yourself honestly (1-5):**

| Skill | Rating | Notes |
|-------|--------|-------|
| Understanding the Problem | __ | Did I grasp the reversed order advantage? |
| Carry Logic | __ | Did I handle carries correctly? |
| Edge Cases | __ | Did I test final carry and different lengths? |
| Code Quality | __ | Did I use dummy head and clear names? |
| Communication | __ | Did I explain before coding? |

**Total Self-Score:** __/25

</div>

---

*Remember: Linked list problems test your pointer management skills. Practice until the dummy head pattern becomes second nature!* 💪

**Ready for Problem 3?** 🚀
