# 🎤 Two Sum - Mock Interview Mode

> **Difficulty:** 🟢 Easy  
> **Time Limit:** ⏱️ 15 minutes  
> **Problem Link:** [LeetCode #1](https://leetcode.com/problems/two-sum/)  
> **Mock Interview:** Problem 1 of 5

---

## ⚡ Interview Rules

- ⏱️ You have **15 minutes** to solve this problem
- 💡 You may request **up to 2 hints** (but it will affect your score)
- 🎯 Focus on: Correctness, Efficiency, Code Quality, Edge Cases
- 🗣️ Think aloud and explain your approach
- ✍️ Write clean, production-ready code

**Start your timer now!** ⏰

---

## 🧩 Problem Statement

Given an array of integers `nums` and an integer `target`, return **indices** of the two numbers such that they add up to `target`.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

---

## 📝 Examples

**Example 1:**
```
Input: nums = [2, 7, 11, 15], target = 9
Output: [0, 1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:**
```
Input: nums = [3, 2, 4], target = 6
Output: [1, 2]
```

**Example 3:**
```
Input: nums = [3, 3], target = 6
Output: [0, 1]
```

---

## 🔍 Constraints

- `2 <= nums.length <= 10⁴`
- `-10⁹ <= nums[i] <= 10⁹`
- `-10⁹ <= target <= 10⁹`
- **Only one valid answer exists.**

---

## 💭 Your Solution Space

<details>
<summary><b>🆘 Hint 1</b> (Click only if needed - Minor score penalty)</summary>

Think about what you need to find for each number. For a number `x`, what other number do you need to make the target sum? How can you efficiently check if you've already seen that number?

Consider using a data structure that allows fast lookups.

</details>

<details>
<summary><b>🆘 Hint 2</b> (Click only if needed - Moderate score penalty)</summary>

Use a **hash map (dictionary)** to store numbers you've seen along with their indices.

For each number `num`:
1. Calculate `complement = target - num`
2. Check if `complement` exists in your hash map
3. If yes → return both indices
4. If no → store `num` and its index

Time Complexity: O(n)  
Space Complexity: O(n)

</details>

---

## ✍️ Write Your Solution Below

```python
def twoSum(nums, target):
    """
    Your solution here.
    
    Args:
        nums: List[int] - Array of integers
        target: int - Target sum
    
    Returns:
        List[int] - Indices of two numbers that sum to target
    """
    # TODO: Implement your solution
    pass


# Test your solution
if __name__ == "__main__":
    # Test Case 1
    print(twoSum([2, 7, 11, 15], 9))  # Expected: [0, 1]
    
    # Test Case 2
    print(twoSum([3, 2, 4], 6))       # Expected: [1, 2]
    
    # Test Case 3
    print(twoSum([3, 3], 6))          # Expected: [0, 1]
```

---

## ⏸️ Time's Up! Submit Your Solution

Once you've completed your solution (or time has expired), scroll down to see the evaluation.

<br><br><br><br><br>

---

# 📊 Interview Evaluation & Feedback

---

## ✅ Optimal Solution

```python
# Time Complexity: O(n)
# Space Complexity: O(n)

def twoSum(nums, target):
    """
    Find two indices where nums[i] + nums[j] = target using hash map.
    
    Args:
        nums: List of integers
        target: Target sum
    
    Returns:
        List of two indices [i, j]
    """
    seen = {}  # {value: index}
    
    for i, num in enumerate(nums):
        complement = target - num
        
        if complement in seen:
            return [seen[complement], i]
        
        seen[num] = i
    
    return []  # Should never reach here per problem constraints


# ✅ Test Cases
assert twoSum([2, 7, 11, 15], 9) == [0, 1]
assert twoSum([3, 2, 4], 6) == [1, 2]
assert twoSum([3, 3], 6) == [0, 1]
assert twoSum([-1, -2, -3, -4, -5], -8) == [2, 4]

print("All test cases passed! ✅")
```

---

## 🎯 Grading Rubric (Score: __/100)

### ✅ **Correctness (40 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Returns correct indices for all test cases | 15 | __ |
| Handles duplicate numbers correctly | 10 | __ |
| Handles negative numbers | 5 | __ |
| Returns indices in valid format | 5 | __ |
| No off-by-one errors | 5 | __ |

**Subtotal:** __/40

---

### ⚙️ **Time Complexity (20 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Achieves O(n) time complexity | 15 | __ |
| Explains approach before coding | 3 | __ |
| Correctly analyzes complexity | 2 | __ |

**Subtotal:** __/20

**Common Issues:**
- ❌ Using nested loops: O(n²) → **-10 points**
- ❌ Sorting array first: O(n log n) → **-5 points**

---

### 💾 **Space Complexity (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Uses O(n) space efficiently (hash map) | 10 | __ |
| No unnecessary data structures | 3 | __ |
| Correctly analyzes space complexity | 2 | __ |

**Subtotal:** __/15

---

### ✍️ **Code Clarity & Style (15 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Clean, readable variable names | 4 | __ |
| Proper comments/documentation | 3 | __ |
| Follows Python conventions (PEP 8) | 3 | __ |
| Code is well-structured | 3 | __ |
| No redundant code | 2 | __ |

**Subtotal:** __/15

**Best Practices:**
- ✅ Use descriptive names: `complement`, `seen` (not `x`, `d`)
- ✅ Add docstring explaining function
- ✅ Use `enumerate()` for cleaner iteration

---

### 🧪 **Tests & Edge Cases (10 points)**

| Criteria | Points | Your Score |
|----------|--------|------------|
| Tests basic examples | 3 | __ |
| Tests edge case: duplicates `[3,3]` | 3 | __ |
| Tests negative numbers | 2 | __ |
| Discusses additional edge cases | 2 | __ |

**Subtotal:** __/10

---

## 📈 **Bonus/Penalties**

| Item | Points | Your Score |
|------|--------|------------|
| ✅ Solved within time limit | +5 | __ |
| ✅ No hints used | +5 | __ |
| ✅ Discussed trade-offs (time vs space) | +3 | __ |
| ✅ Mentioned alternative approaches | +2 | __ |
| ❌ Used Hint 1 | -3 | __ |
| ❌ Used Hint 2 | -5 | __ |
| ❌ Exceeded time limit | -5 | __ |

**Bonus/Penalties:** __

---

## 🏆 **Final Score: __/100**

### Score Interpretation

| Range | Performance | Feedback |
|-------|-------------|----------|
| **90-100** | 🌟 Excellent | Interview-ready! You'd get a strong hire recommendation. |
| **75-89** | 👍 Good | Solid performance. Minor improvements needed. |
| **60-74** | 🤔 Fair | You got the solution but missed optimization or clarity. |
| **Below 60** | 📚 Needs Work | Review the pattern and practice similar problems. |

---

## 💬 Detailed Feedback

### ✅ What You Did Well
- [ ] Identified the hash map pattern quickly
- [ ] Wrote clean, readable code
- [ ] Handled all test cases correctly
- [ ] Explained your approach clearly
- [ ] Analyzed time/space complexity accurately

### 🔧 Areas for Improvement
- [ ] **Time Complexity:** Should aim for O(n), not O(n²)
- [ ] **Code Style:** Use more descriptive variable names
- [ ] **Edge Cases:** Remember to test with duplicates and negatives
- [ ] **Communication:** Explain your approach before coding
- [ ] **Testing:** Always test your code with examples

---

## 🎯 Actionable Next Steps

Based on your performance, here are **3 targeted exercises** to improve:

### 1️⃣ **If you struggled with Hash Maps:**
   - **Practice:** Contains Duplicate (LC #217)
   - **Practice:** Two Sum II - Sorted Array (LC #167)
   - **Focus:** Understanding when and why to use hash maps

### 2️⃣ **If you missed the O(n) solution:**
   - **Study:** Review hash map lookup time: O(1) vs array search: O(n)
   - **Practice:** Valid Anagram (LC #242)
   - **Focus:** Recognizing when hash maps can replace nested loops

### 3️⃣ **If code clarity was an issue:**
   - **Review:** PEP 8 Style Guide
   - **Practice:** Rewrite your solution with better names and comments
   - **Focus:** Making code interview-ready, not just working

---

## 🔄 Alternative Approaches Discussion

### Approach 1: Brute Force (What You Might Have Tried First)
```python
# Time: O(n²), Space: O(1)
def twoSumBruteForce(nums, target):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
```
**Pros:** Simple, no extra space  
**Cons:** Too slow for large inputs (10⁴ elements)

### Approach 2: Hash Map (Optimal ✅)
```python
# Time: O(n), Space: O(n)
def twoSum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []
```
**Pros:** Fast, scales well  
**Cons:** Uses extra space

### Approach 3: Two Pointers (If Array Were Sorted)
**Note:** This would require sorting, which:
- Takes O(n log n) time
- Loses original indices
- Not applicable here, but good to mention in interview

---

## 🗣️ Interview Communication Examples

### ❌ Poor Communication
> "I'll just use a dictionary... *starts coding immediately*"

**Issues:**
- No explanation of approach
- Didn't discuss alternatives
- No mention of complexity

### ✅ Strong Communication
> "I see we need to find two indices that sum to target. My first thought is nested loops—checking every pair—but that's O(n²). 
> 
> A better approach: for each number, I need to find if its complement exists. A hash map lets me check in O(1) time. I'll store each number and its index as I iterate. When I find a complement that's already in the map, I return both indices.
> 
> This gives us O(n) time and O(n) space. The space trade-off is worth it for the speed improvement. Let me code this up..."

**Strengths:**
- Shows thought process
- Mentions brute force first
- Explains optimization
- States complexities
- Gets interviewer buy-in before coding

---

## 📚 Key Takeaways for Future Interviews

1. **Always state the brute force first** (shows you can solve it)
2. **Then optimize** (shows you can think critically)
3. **Explain trade-offs** (time vs space)
4. **Test with edge cases** before submitting
5. **Write clean code** as if it's going to production

---

## 🎯 What's Next?

You've completed **Mock Interview Problem 1 of 5**! 

**Your Options:**
1. 📘 **Review Teaching Mode** - Deep dive into the pattern
2. 🔄 **Try Another Mock Interview** - Build confidence
3. ⬆️ **Move to Medium Difficulty** - Challenge yourself
4. 📊 **Request Detailed Feedback** - I'll analyze your specific solution

---

<div align="center">

## 🏅 Self-Assessment

**Before moving on, rate yourself honestly:**

| Skill | 1-5 Rating | Notes |
|-------|------------|-------|
| Problem Understanding | __ | Did I understand all requirements? |
| Approach Selection | __ | Did I choose the optimal approach? |
| Code Implementation | __ | Was my code clean and correct? |
| Time Management | __ | Did I use time efficiently? |
| Communication | __ | Did I explain my thinking clearly? |

**Total Self-Score:** __/25

</div>

---

*Remember: Even if you didn't get a perfect score, the goal is **progress, not perfection**. Each problem makes you stronger!* 💪

**Ready for the next challenge?** 🚀
