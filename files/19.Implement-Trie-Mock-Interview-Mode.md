# ⏱️ MOCK INTERVIEW: Implement Trie (Prefix Tree)

**Difficulty:** 🟡 Medium  
**Pattern:** Design / Tree  
**Time Limit:** ⏰ **30 minutes**  
**Points:** 100

---

## 📋 Problem Statement

Implement a **Trie** (prefix tree) with these methods:

- `Trie()` - Initialize
- `insert(word)` - Insert word
- `search(word)` - Return True if word exists
- `startsWith(prefix)` - Return True if any word starts with prefix

```python
trie = Trie()
trie.insert("apple")
trie.search("apple")   # True
trie.search("app")     # False
trie.startsWith("app") # True
```

---

## 💡 Clarifying Questions

1. Only lowercase English letters? **Yes, a-z**
2. Can words be empty? **No, at least 1 character**
3. Can same word be inserted twice? **Yes, handle gracefully**
4. Max word length? **Assume reasonable, < 1000 chars**

---

## 💡 Optional Hints

<details>
<summary>🆘 Hint 1 (−10 points)</summary>

Each **TrieNode** needs:
1. A `children` dictionary (char → TrieNode)
2. An `is_end_of_word` boolean flag

</details>

<details>
<summary>🆘 Hint 2 (−15 points)</summary>

**Insert pattern:**
```python
node = self.root
for char in word:
    if char not in node.children:
        node.children[char] = TrieNode()
    node = node.children[char]
node.is_end_of_word = True
```

</details>

<details>
<summary>🆘 Hint 3 (−20 points)</summary>

**search vs startsWith:**
- `search`: Check `is_end_of_word` at end
- `startsWith`: Just traverse, don't check `is_end_of_word`

</details>

---

## 🧑‍💻 Your Solution

```python
class Trie:
    def __init__(self):
        # Your initialization here
        pass
    
    def insert(self, word: str) -> None:
        # Your code here
        pass
    
    def search(self, word: str) -> bool:
        # Your code here
        pass
    
    def startsWith(self, prefix: str) -> bool:
        # Your code here
        pass
```

---

## ✅ Test Cases

```python
# Test 1: Basic operations
trie = Trie()
trie.insert("apple")
assert trie.search("apple") == True
assert trie.search("app") == False
assert trie.startsWith("app") == True

# Test 2: Insert then search
trie.insert("app")
assert trie.search("app") == True

# Test 3: Multiple words with shared prefix
trie = Trie()
trie.insert("cat")
trie.insert("car")
trie.insert("card")
assert trie.search("cat") == True
assert trie.search("car") == True
assert trie.search("card") == True
assert trie.search("ca") == False
assert trie.startsWith("ca") == True

# Test 4: Single character
trie = Trie()
trie.insert("a")
assert trie.search("a") == True
assert trie.startsWith("a") == True

# Test 5: Not found
assert trie.search("xyz") == False
assert trie.startsWith("xyz") == False
```

---

## 📊 Grading Rubric (100 points)

### Correctness (50 points)
- ✅ insert works correctly (15 pts)
- ✅ search distinguishes words vs prefixes (15 pts)
- ✅ startsWith handles all prefixes (10 pts)
- ✅ Handles shared prefixes (5 pts)
- ✅ Edge cases (single char, not found) (5 pts)

### Time Complexity (20 points)
- ✅ All operations O(m) where m = word length (20 pts)
- ⚠️ Worse than O(m) (5 pts)

### Space Complexity (15 points)
- ✅ Efficient node structure (15 pts)
- ⚠️ Excessive memory usage (5 pts)

### Code Quality (10 points)
- ✅ Clean TrieNode design (4 pts)
- ✅ Proper traversal logic (4 pts)
- ✅ Readable code (2 pts)

### Communication (5 points)
- ✅ Explained Trie structure (3 pts)
- ✅ Discussed use cases (2 pts)

---

## ✅ Optimal Solution

<details>
<summary>🔍 HashMap-based Solution</summary>

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True
    
    def search(self, word: str) -> bool:
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word
    
    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
```

**Time:** O(m) per operation  
**Space:** O(n × m) total where n = number of words

</details>

<details>
<summary>🔍 Array-based Solution</summary>

```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def _index(self, char):
        return ord(char) - ord('a')
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            idx = self._index(char)
            if not node.children[idx]:
                node.children[idx] = TrieNode()
            node = node.children[idx]
        node.is_end_of_word = True
    
    def search(self, word: str) -> bool:
        node = self.root
        for char in word:
            idx = self._index(char)
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return node.is_end_of_word
    
    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            idx = self._index(char)
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return True
```

**Time:** O(m) per operation  
**Space:** O(n × m × 26) worst case

</details>

---

## 🎯 Performance Summary

| Metric | Target | Your Score |
|--------|--------|------------|
| Correctness | 50 pts | ___/50 |
| Time Complexity | 20 pts | ___/20 |
| Space Complexity | 15 pts | ___/15 |
| Code Quality | 10 pts | ___/10 |
| Communication | 5 pts | ___/5 |
| **Hints Used** | 0 pts | −___ |
| **Total** | **100 pts** | **___/100** |

---

## 💭 Self-Reflection

1. Did you remember the `is_end_of_word` flag?
2. Dict or array for children? Why?
3. How would you implement autocomplete?
4. Can you add a delete operation?

---

*"Every path tells a story!"* 🌲✨
