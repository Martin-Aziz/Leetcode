# â±ï¸ MOCK INTERVIEW: Implement Trie (Prefix Tree)

**Difficulty:** ğŸŸ¡ Medium  
**Pattern:** Design / Tree  
**Time Limit:** â° **30 minutes**  
**Points:** 100

---

## ğŸ“‹ Problem Statement

Implement a **Trie** (prefix tree) with these methods:

- `Trie()` - Initialize
- `insert(word)` - Insert word
- `search(word)` - Return True if word exists
- `startsWith(prefix)` - Return True if any word starts with prefix

```python
trie = Trie()
trie.insert("apple")
trie.search("apple")   # True
trie.search("app")     # False
trie.startsWith("app") # True
```

---

## ğŸ’¡ Clarifying Questions

1. Only lowercase English letters? **Yes, a-z**
2. Can words be empty? **No, at least 1 character**
3. Can same word be inserted twice? **Yes, handle gracefully**
4. Max word length? **Assume reasonable, < 1000 chars**

---

## ğŸ’¡ Optional Hints

<details>
<summary>ğŸ†˜ Hint 1 (âˆ’10 points)</summary>

Each **TrieNode** needs:
1. A `children` dictionary (char â†’ TrieNode)
2. An `is_end_of_word` boolean flag

</details>

<details>
<summary>ğŸ†˜ Hint 2 (âˆ’15 points)</summary>

**Insert pattern:**
```python
node = self.root
for char in word:
    if char not in node.children:
        node.children[char] = TrieNode()
    node = node.children[char]
node.is_end_of_word = True
```

</details>

<details>
<summary>ğŸ†˜ Hint 3 (âˆ’20 points)</summary>

**search vs startsWith:**
- `search`: Check `is_end_of_word` at end
- `startsWith`: Just traverse, don't check `is_end_of_word`

</details>

---

## ğŸ§‘â€ğŸ’» Your Solution

```python
class Trie:
    def __init__(self):
        # Your initialization here
        pass
    
    def insert(self, word: str) -> None:
        # Your code here
        pass
    
    def search(self, word: str) -> bool:
        # Your code here
        pass
    
    def startsWith(self, prefix: str) -> bool:
        # Your code here
        pass
```

---

## âœ… Test Cases

```python
# Test 1: Basic operations
trie = Trie()
trie.insert("apple")
assert trie.search("apple") == True
assert trie.search("app") == False
assert trie.startsWith("app") == True

# Test 2: Insert then search
trie.insert("app")
assert trie.search("app") == True

# Test 3: Multiple words with shared prefix
trie = Trie()
trie.insert("cat")
trie.insert("car")
trie.insert("card")
assert trie.search("cat") == True
assert trie.search("car") == True
assert trie.search("card") == True
assert trie.search("ca") == False
assert trie.startsWith("ca") == True

# Test 4: Single character
trie = Trie()
trie.insert("a")
assert trie.search("a") == True
assert trie.startsWith("a") == True

# Test 5: Not found
assert trie.search("xyz") == False
assert trie.startsWith("xyz") == False
```

---

## ğŸ“Š Grading Rubric (100 points)

### Correctness (50 points)
- âœ… insert works correctly (15 pts)
- âœ… search distinguishes words vs prefixes (15 pts)
- âœ… startsWith handles all prefixes (10 pts)
- âœ… Handles shared prefixes (5 pts)
- âœ… Edge cases (single char, not found) (5 pts)

### Time Complexity (20 points)
- âœ… All operations O(m) where m = word length (20 pts)
- âš ï¸ Worse than O(m) (5 pts)

### Space Complexity (15 points)
- âœ… Efficient node structure (15 pts)
- âš ï¸ Excessive memory usage (5 pts)

### Code Quality (10 points)
- âœ… Clean TrieNode design (4 pts)
- âœ… Proper traversal logic (4 pts)
- âœ… Readable code (2 pts)

### Communication (5 points)
- âœ… Explained Trie structure (3 pts)
- âœ… Discussed use cases (2 pts)

---

## âœ… Optimal Solution

<details>
<summary>ğŸ” HashMap-based Solution</summary>

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True
    
    def search(self, word: str) -> bool:
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word
    
    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
```

**Time:** O(m) per operation  
**Space:** O(n Ã— m) total where n = number of words

</details>

<details>
<summary>ğŸ” Array-based Solution</summary>

```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def _index(self, char):
        return ord(char) - ord('a')
    
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            idx = self._index(char)
            if not node.children[idx]:
                node.children[idx] = TrieNode()
            node = node.children[idx]
        node.is_end_of_word = True
    
    def search(self, word: str) -> bool:
        node = self.root
        for char in word:
            idx = self._index(char)
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return node.is_end_of_word
    
    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            idx = self._index(char)
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return True
```

**Time:** O(m) per operation  
**Space:** O(n Ã— m Ã— 26) worst case

</details>

---

## ğŸ¯ Performance Summary

| Metric | Target | Your Score |
|--------|--------|------------|
| Correctness | 50 pts | ___/50 |
| Time Complexity | 20 pts | ___/20 |
| Space Complexity | 15 pts | ___/15 |
| Code Quality | 10 pts | ___/10 |
| Communication | 5 pts | ___/5 |
| **Hints Used** | 0 pts | âˆ’___ |
| **Total** | **100 pts** | **___/100** |

---

## ğŸ’­ Self-Reflection

1. Did you remember the `is_end_of_word` flag?
2. Dict or array for children? Why?
3. How would you implement autocomplete?
4. Can you add a delete operation?

---

*"Every path tells a story!"* ğŸŒ²âœ¨
