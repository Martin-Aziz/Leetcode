# â±ï¸ MOCK INTERVIEW: Coin Change

**Difficulty:** ğŸŸ¡ Medium  
**Pattern:** Dynamic Programming  
**Time Limit:** â° **30 minutes**  
**Points:** 100

---

## ğŸ¯ Interview Simulation

**Start your timer NOW!** â°

---

## ğŸ“‹ Problem Statement

You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.

Return *the fewest number of coins that you need to make up that amount*. If that amount cannot be made up, return `-1`.

You may assume you have an **infinite number of each kind of coin**.

### Examples:

```
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1

Input: coins = [2], amount = 3
Output: -1

Input: coins = [1], amount = 0
Output: 0
```

### Constraints:
- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

---

## â“ Clarifying Questions

1. **"Can I use same coin multiple times?"** â†’ Yes, unlimited
2. **"What if amount is 0?"** â†’ Return 0
3. **"What if impossible to make exact change?"** â†’ Return -1
4. **"Should I optimize for time or space?"** â†’ Both if possible

---

## ğŸ’­ Think Out Loud

"This is an optimization problem asking for minimum coins. Greedy won't work because taking the largest coin first doesn't always give optimal solution. I should use DP..."

---

## ğŸ’¡ Optional Hints

<details>
<summary>ğŸ†˜ Hint 1: What pattern is this? (âˆ’5 points)</summary>

This is **Dynamic Programming** - specifically **Unbounded Knapsack**.

Build solution for amount 0, then 1, 2, ... up to target.

</details>

<details>
<summary>ğŸ†˜ Hint 2: DP formula? (âˆ’10 points)</summary>

```python
dp[i] = minimum coins to make amount i
dp[i] = min(dp[i - coin] + 1) for all coins where coin <= i
dp[0] = 0  # base case
```

</details>

<details>
<summary>ğŸ†˜ Hint 3: Implementation structure? (âˆ’15 points)</summary>

```python
dp = [float('inf')] * (amount + 1)
dp[0] = 0

for i in range(1, amount + 1):
    for coin in coins:
        if coin <= i:
            dp[i] = min(dp[i], dp[i - coin] + 1)

return dp[amount] if dp[amount] != inf else -1
```

</details>

---

## ğŸ§‘â€ğŸ’» Your Solution Space

```python
def coinChange(coins: list[int], amount: int) -> int:
    """
    Find minimum coins needed to make target amount.
    
    Args:
        coins: List of coin denominations
        amount: Target amount
        
    Returns:
        Minimum coins needed, or -1 if impossible
    """
    # Your code here
    pass


# Test your solution
if __name__ == "__main__":
    assert coinChange([1,2,5], 11) == 3
    assert coinChange([2], 3) == -1
    assert coinChange([1], 0) == 0
    print("âœ… All tests passed!")
```

---

## â° Time Check!

- â±ï¸ **10 min:** Should have DP approach identified
- â±ï¸ **20 min:** Should have working solution
- â±ï¸ **25 min:** Should be testing edge cases
- â±ï¸ **30 min:** TIME'S UP!

---

## âœ… Optimal Solution

<details>
<summary><b>ğŸ” Click to Reveal</b></summary>

```python
def coinChange(coins: list[int], amount: int) -> int:
    """
    Bottom-up DP solution.
    
    Time: O(amount * n) where n = len(coins)
    Space: O(amount)
    """
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1
```

</details>

---

## ğŸ¯ Grading Rubric (100 Points)

### 1ï¸âƒ£ Correctness (40 points)
- All test cases pass: 20 pts
- Handles amount = 0: 5 pts
- Handles impossible case: 10 pts
- Returns -1 correctly: 5 pts

### 2ï¸âƒ£ Time Complexity (25 points)
- Achieves O(amount Ã— n): 20 pts
- Explains DP approach: 5 pts
- **Penalty:** Greedy approach: -20 pts

### 3ï¸âƒ£ Space Complexity (15 points)
- O(amount) space: 12 pts
- Explains DP array: 3 pts

### 4ï¸âƒ£ Code Quality (10 points)
- Clean DP logic: 5 pts
- Proper initialization: 3 pts
- Good variable names: 2 pts

### 5ï¸âƒ£ Communication (10 points)
- Explained why not greedy: 4 pts
- Walked through example: 3 pts
- Tested edge cases: 3 pts

### Penalties:
- Used hints: -5, -10, -15
- Wrong answer: -30
- Overtime: -10

---

## ğŸ“ˆ Your Performance Summary

| Metric | Your Result |
|--------|-------------|
| **Total Score** | ___/100 |
| **Time Taken** | ___ min |
| **Approach** | DP / Greedy / BFS |

---

## ğŸš€ Next Challenge

**Continue to:** `12.Combination-Sum-Teaching-Mode.md`

---

*"DP is just careful brute force!"* ğŸ¯âœ¨
