# ⏱️ MOCK INTERVIEW: Coin Change

**Difficulty:** 🟡 Medium  
**Pattern:** Dynamic Programming  
**Time Limit:** ⏰ **30 minutes**  
**Points:** 100

---

## 🎯 Interview Simulation

**Start your timer NOW!** ⏰

---

## 📋 Problem Statement

You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.

Return *the fewest number of coins that you need to make up that amount*. If that amount cannot be made up, return `-1`.

You may assume you have an **infinite number of each kind of coin**.

### Examples:

```
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1

Input: coins = [2], amount = 3
Output: -1

Input: coins = [1], amount = 0
Output: 0
```

### Constraints:
- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

---

## ❓ Clarifying Questions

1. **"Can I use same coin multiple times?"** → Yes, unlimited
2. **"What if amount is 0?"** → Return 0
3. **"What if impossible to make exact change?"** → Return -1
4. **"Should I optimize for time or space?"** → Both if possible

---

## 💭 Think Out Loud

"This is an optimization problem asking for minimum coins. Greedy won't work because taking the largest coin first doesn't always give optimal solution. I should use DP..."

---

## 💡 Optional Hints

<details>
<summary>🆘 Hint 1: What pattern is this? (−5 points)</summary>

This is **Dynamic Programming** - specifically **Unbounded Knapsack**.

Build solution for amount 0, then 1, 2, ... up to target.

</details>

<details>
<summary>🆘 Hint 2: DP formula? (−10 points)</summary>

```python
dp[i] = minimum coins to make amount i
dp[i] = min(dp[i - coin] + 1) for all coins where coin <= i
dp[0] = 0  # base case
```

</details>

<details>
<summary>🆘 Hint 3: Implementation structure? (−15 points)</summary>

```python
dp = [float('inf')] * (amount + 1)
dp[0] = 0

for i in range(1, amount + 1):
    for coin in coins:
        if coin <= i:
            dp[i] = min(dp[i], dp[i - coin] + 1)

return dp[amount] if dp[amount] != inf else -1
```

</details>

---

## 🧑‍💻 Your Solution Space

```python
def coinChange(coins: list[int], amount: int) -> int:
    """
    Find minimum coins needed to make target amount.
    
    Args:
        coins: List of coin denominations
        amount: Target amount
        
    Returns:
        Minimum coins needed, or -1 if impossible
    """
    # Your code here
    pass


# Test your solution
if __name__ == "__main__":
    assert coinChange([1,2,5], 11) == 3
    assert coinChange([2], 3) == -1
    assert coinChange([1], 0) == 0
    print("✅ All tests passed!")
```

---

## ⏰ Time Check!

- ⏱️ **10 min:** Should have DP approach identified
- ⏱️ **20 min:** Should have working solution
- ⏱️ **25 min:** Should be testing edge cases
- ⏱️ **30 min:** TIME'S UP!

---

## ✅ Optimal Solution

<details>
<summary><b>🔍 Click to Reveal</b></summary>

```python
def coinChange(coins: list[int], amount: int) -> int:
    """
    Bottom-up DP solution.
    
    Time: O(amount * n) where n = len(coins)
    Space: O(amount)
    """
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1
```

</details>

---

## 🎯 Grading Rubric (100 Points)

### 1️⃣ Correctness (40 points)
- All test cases pass: 20 pts
- Handles amount = 0: 5 pts
- Handles impossible case: 10 pts
- Returns -1 correctly: 5 pts

### 2️⃣ Time Complexity (25 points)
- Achieves O(amount × n): 20 pts
- Explains DP approach: 5 pts
- **Penalty:** Greedy approach: -20 pts

### 3️⃣ Space Complexity (15 points)
- O(amount) space: 12 pts
- Explains DP array: 3 pts

### 4️⃣ Code Quality (10 points)
- Clean DP logic: 5 pts
- Proper initialization: 3 pts
- Good variable names: 2 pts

### 5️⃣ Communication (10 points)
- Explained why not greedy: 4 pts
- Walked through example: 3 pts
- Tested edge cases: 3 pts

### Penalties:
- Used hints: -5, -10, -15
- Wrong answer: -30
- Overtime: -10

---

## 📈 Your Performance Summary

| Metric | Your Result |
|--------|-------------|
| **Total Score** | ___/100 |
| **Time Taken** | ___ min |
| **Approach** | DP / Greedy / BFS |

---

## 🚀 Next Challenge

**Continue to:** `12.Combination-Sum-Teaching-Mode.md`

---

*"DP is just careful brute force!"* 🎯✨
