# ğŸ“˜ Add Two Numbers - Teaching Mode

> **Difficulty:** ğŸŸ¡ Medium  
> **Problem Link:** [LeetCode #2](https://leetcode.com/problems/add-two-numbers/)  
> **Pattern:** Linked List / Math Simulation  
> **Session:** Problem 2 of 5

---

## ğŸ§© Problem Statement

You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

### ğŸ“ Examples

**Example 1:**
```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807
```
Visual representation:
```
    2 â†’ 4 â†’ 3       (represents 342)
  + 5 â†’ 6 â†’ 4       (represents 465)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    7 â†’ 0 â†’ 8       (represents 807)
```

**Example 2:**
```
Input: l1 = [0], l2 = [0]
Output: [0]
```

**Example 3:**
```
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
Explanation: 9999999 + 9999 = 10009998
```

### ğŸ” Input/Output Types
- **Input:** 
  - `l1`: Head of first linked list (`Optional[ListNode]`)
  - `l2`: Head of second linked list (`Optional[ListNode]`)
- **Output:** Head of result linked list (`Optional[ListNode]`)

**ListNode Definition:**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

---

## ğŸ§  Understanding the Problem

**What is this problem really asking?**

Imagine adding two numbers **digit by digit**, just like you learned in elementary school, but:
- The digits come in **reverse order** (ones place first, tens place second, etc.)
- Each digit is stored in a **linked list node**
- You need to handle **carries** (when sum â‰¥ 10)

**Key Points:**
- âœ… Digits are in **reverse order** (makes addition easier!)
- âœ… Must handle **different lengths** (e.g., 999 + 1)
- âœ… Must handle **carry-over** (e.g., 9 + 9 = 18, write 8, carry 1)
- âœ… Final carry might create an **extra node** (e.g., 99 + 1 = 100)
- âš ï¸ Can't modify input lists (create new result list)

**Edge Cases:**
- Different length lists: `[1,2,3]` + `[4,5]`
- Carry at the end: `[9,9]` + `[1]` â†’ `[0,0,1]`
- Single nodes: `[5]` + `[5]` â†’ `[0,1]`
- One list is just `[0]`

---

## ğŸ§­ Recognizing the Pattern(s)

### ğŸ¯ Primary Pattern: **Linked List Traversal + Elementary Math**

**Analogy:** Remember adding numbers in school by stacking them vertically? You start from the rightmost digit (ones place), add them, write the result, and carry over if needed. This problem is **exactly the same**, except the digits are already arranged right-to-left in the linked lists!

```
  Traditional:          Linked List:
      342                 2 â†’ 4 â†’ 3
    + 465                 5 â†’ 6 â†’ 4
    â”€â”€â”€â”€â”€                 â”€â”€â”€â”€â”€â”€â”€â”€â”€
      807                 7 â†’ 0 â†’ 8
```

**Why This Pattern?**
- Digits are reversed: perfect for left-to-right addition
- Must track carry state through iterations
- Build result list node by node
- Classic **simulation** problem (mimic real-world process)

**Key Concepts:**
1. **Dummy Head** - Simplifies result list construction
2. **Carry Management** - Track overflow between digits
3. **Uneven Lengths** - Continue until both lists exhausted
4. **Final Carry** - Don't forget trailing carry!

---

## ğŸªœ High-Level Plan

### Strategy: Simultaneous Traversal with Carry

1. **Create a dummy head** for the result list
2. **Initialize carry** to 0
3. **Loop while** (l1 exists OR l2 exists OR carry exists)
   - Get value from l1 (or 0 if null)
   - Get value from l2 (or 0 if null)
   - Calculate: `total = val1 + val2 + carry`
   - Create new node with `total % 10` (ones digit)
   - Update carry: `carry = total // 10`
   - Move pointers forward
4. **Return** `dummy.next` (skip dummy head)

### ğŸ“‹ Pseudocode

```python
# Step 1: Setup
dummy = ListNode(0)  # Placeholder
current = dummy
carry = 0

# Step 2: Traverse both lists
while l1 OR l2 OR carry:
    # Step 3: Get values (0 if node is None)
    val1 = l1.val if l1 else 0
    val2 = l2.val if l2 else 0
    
    # Step 4: Add digits + carry
    total = val1 + val2 + carry
    
    # Step 5: Extract digit and new carry
    digit = total % 10
    carry = total // 10
    
    # Step 6: Create new node
    current.next = ListNode(digit)
    current = current.next
    
    # Step 7: Move to next nodes
    l1 = l1.next if l1 else None
    l2 = l2.next if l2 else None

# Step 8: Return result (skip dummy)
return dummy.next
```

---

## ğŸ’¡ Hints Policy

### ğŸ“ Level 1 Hint (Small Nudge)
<details>
<summary>Click to reveal Level 1 Hint</summary>

Think about how you add numbers with pencil and paper. You go digit by digit from right to left, keeping track of the "carry" when a sum is 10 or more. The good news? The digits are already in the right order (reversed) in the linked lists!

Use a **dummy head node** to make building the result list easier.

</details>

### ğŸ“ Level 2 Hint (Medium Help)
<details>
<summary>Click to reveal Level 2 Hint</summary>

**Key insight:** Use three variables as you traverse:
1. `carry` - starts at 0, tracks overflow
2. `val1` - current digit from l1 (or 0 if l1 is done)
3. `val2` - current digit from l2 (or 0 if l2 is done)

For each position:
- `total = val1 + val2 + carry`
- New digit = `total % 10`
- New carry = `total // 10`

Continue the loop as long as **any** of these exist: l1, l2, or carry.

</details>

### ğŸ“ Level 3 Hint (Almost There)
<details>
<summary>Click to reveal Level 3 Hint</summary>

```python
def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0
    
    while l1 or l2 or carry:
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        
        total = val1 + val2 + carry
        carry = total // 10
        
        current.next = ListNode(total % 10)
        current = current.next
        
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None
    
    return dummy.next
```

**Why dummy node?** It avoids special-casing the first nodeâ€”we can always append to `current.next`.

</details>

---

## ğŸ§‘â€ğŸ’» Code Solution (Python)

### âœ¨ Optimal Solution

```python
# Time Complexity: O(max(m, n)) where m, n are lengths of l1, l2
# Space Complexity: O(max(m, n)) for the result list

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def addTwoNumbers(l1, l2):
    """
    Add two numbers represented by linked lists in reverse order.
    
    Args:
        l1: Head of first linked list
        l2: Head of second linked list
    
    Returns:
        Head of result linked list representing the sum
    """
    # Step 1: Create dummy head for result list
    dummy = ListNode(0)
    current = dummy
    
    # Step 2: Initialize carry
    carry = 0
    
    # Step 3: Process both lists until done
    while l1 or l2 or carry:
        # Get values from current nodes (0 if None)
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        
        # Calculate sum of digits plus carry
        total = val1 + val2 + carry
        
        # Extract the ones digit and new carry
        digit = total % 10
        carry = total // 10
        
        # Create new node with the digit
        current.next = ListNode(digit)
        current = current.next
        
        # Move to next nodes if they exist
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None
    
    # Step 4: Return result (skip dummy head)
    return dummy.next


# âœ… Helper functions for testing
def create_linked_list(arr):
    """Create a linked list from an array."""
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for val in arr[1:]:
        current.next = ListNode(val)
        current = current.next
    return head


def linked_list_to_array(head):
    """Convert linked list to array for easy testing."""
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result


# âœ… Test Cases
def test_add_two_numbers():
    # Test 1: Basic addition
    l1 = create_linked_list([2, 4, 3])  # 342
    l2 = create_linked_list([5, 6, 4])  # 465
    result = addTwoNumbers(l1, l2)
    assert linked_list_to_array(result) == [7, 0, 8]  # 807
    print("âœ… Test 1 passed: 342 + 465 = 807")
    
    # Test 2: Zero addition
    l1 = create_linked_list([0])
    l2 = create_linked_list([0])
    result = addTwoNumbers(l1, l2)
    assert linked_list_to_array(result) == [0]
    print("âœ… Test 2 passed: 0 + 0 = 0")
    
    # Test 3: Different lengths with carry
    l1 = create_linked_list([9, 9, 9, 9, 9, 9, 9])  # 9999999
    l2 = create_linked_list([9, 9, 9, 9])           # 9999
    result = addTwoNumbers(l1, l2)
    assert linked_list_to_array(result) == [8, 9, 9, 9, 0, 0, 0, 1]  # 10009998
    print("âœ… Test 3 passed: 9999999 + 9999 = 10009998")
    
    # Test 4: Carry at the end
    l1 = create_linked_list([9, 9])  # 99
    l2 = create_linked_list([1])     # 1
    result = addTwoNumbers(l1, l2)
    assert linked_list_to_array(result) == [0, 0, 1]  # 100
    print("âœ… Test 4 passed: 99 + 1 = 100")

test_add_two_numbers()
```

---

## ğŸ§© Step-by-Step Explanation

Let's trace through **Example 1:** `l1 = [2,4,3]`, `l2 = [5,6,4]`

This represents: **342 + 465 = 807**

### Initialization
```python
dummy = ListNode(0)  # dummy â†’ []
current = dummy
carry = 0
```

### Iteration 1: Position 0 (Ones place)
```
l1 â†’ 2    l2 â†’ 5    carry = 0
val1 = 2, val2 = 5
total = 2 + 5 + 0 = 7
digit = 7 % 10 = 7
carry = 7 // 10 = 0

Result: dummy â†’ 7
Move pointers: l1 â†’ 4, l2 â†’ 6
```

### Iteration 2: Position 1 (Tens place)
```
l1 â†’ 4    l2 â†’ 6    carry = 0
val1 = 4, val2 = 6
total = 4 + 6 + 0 = 10
digit = 10 % 10 = 0
carry = 10 // 10 = 1  â¬…ï¸ Carry!

Result: dummy â†’ 7 â†’ 0
Move pointers: l1 â†’ 3, l2 â†’ 4
```

### Iteration 3: Position 2 (Hundreds place)
```
l1 â†’ 3    l2 â†’ 4    carry = 1
val1 = 3, val2 = 4
total = 3 + 4 + 1 = 8
digit = 8 % 10 = 8
carry = 8 // 10 = 0

Result: dummy â†’ 7 â†’ 0 â†’ 8
Move pointers: l1 â†’ None, l2 â†’ None
```

### Iteration 4: Check condition
```
l1 = None, l2 = None, carry = 0
Loop exits! âœ…
```

### Return
```python
return dummy.next  # Returns: 7 â†’ 0 â†’ 8
```

---

## ğŸ¬ Visual Walkthrough

### Example: `99 + 1 = 100`

```
Input:
l1: 9 â†’ 9 â†’ None
l2: 1 â†’ None

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 1: First digit (ones)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 9 + 1 + carry(0) = 10               â”‚
â”‚ digit = 0, carry = 1                â”‚
â”‚ Result: 0                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 2: Second digit (tens)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 9 + 0 + carry(1) = 10               â”‚
â”‚ digit = 0, carry = 1                â”‚
â”‚ Result: 0 â†’ 0                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 3: Final carry (hundreds)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0 + 0 + carry(1) = 1                â”‚
â”‚ digit = 1, carry = 0                â”‚
â”‚ Result: 0 â†’ 0 â†’ 1                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Output: 0 â†’ 0 â†’ 1  (represents 100) âœ…
```

---

## â±ï¸ Complexity Analysis

### Time Complexity: **O(max(m, n))**
- `m` = length of l1, `n` = length of l2
- We traverse both lists exactly once
- Each iteration does constant work: O(1)
- Total iterations = length of longer list (plus possibly 1 for final carry)
- **Result: O(max(m, n))**

### Space Complexity: **O(max(m, n))**
- We create a new linked list for the result
- Result length = max(m, n) or max(m, n) + 1 (if final carry exists)
- Not counting input size, we use **O(max(m, n))** space
- Carry variable is O(1)

**Note:** We could argue O(1) extra space if we don't count the output. But typically, output space is included.

### ğŸ“Š Why This Is Optimal

- **Can't do better than O(max(m,n)) time:** We must visit every digit at least once
- **Space matches output size:** We need to create the result list anyway
- **Single pass:** We don't need to traverse multiple times or reverse anything

---

## ğŸ” Variations & Follow-Ups

### ğŸŸ¢ Easier Variations
1. **Add Two Numbers as Strings** - Same logic, but with strings
   - Even simpler: no linked list pointer management

2. **Sum of Two Integers (Without +/- operators)** - Bit manipulation
   - Different pattern but related concept

### ğŸŸ¡ Similar Difficulty
3. **Multiply Strings** (LeetCode #43) - Elementary multiplication simulation
   - Same "simulate math" pattern
   - More complex carry management

4. **Add Binary** (LeetCode #67) - Binary addition (base 2 instead of base 10)
   - Same carry logic
   - Different modulo (% 2 instead of % 10)

### ğŸ”´ Harder Variations
5. **Add Two Numbers II** (LeetCode #445) - **Most significant digit first**
   - Need to reverse lists first, or use stack
   - Can't process left-to-right easily

6. **Plus One Linked List** (LeetCode #369) - Add 1 to number in linked list
   - Special case of this problem
   - Can optimize with recursion

**How the Pattern Changes:**
- **Digits not reversed** â†’ Need stack or reverse first
- **Different bases** â†’ Change modulo/division (binary: %2, //2)
- **Multiplication** â†’ Nested loops, more complex carry tracking

---

## ğŸ§© Reflection & Reinforcement

### ğŸ“š Check Your Understanding

<details>
<summary><b>Question 1:</b> Why do we continue the loop even when both l1 and l2 are None?</summary>

**Answer:** Because there might still be a **carry** to process! For example, `99 + 1 = 100`. After processing both lists, we have carry = 1, which needs to become a new node with value 1.

The condition is: `while l1 or l2 or carry`

</details>

<details>
<summary><b>Question 2:</b> What's the purpose of the dummy head node?</summary>

**Answer:** It simplifies list construction. Without it, we'd need special logic for the first node:
```python
# Without dummy (more complex):
if not head:
    head = ListNode(digit)
    current = head
else:
    current.next = ListNode(digit)
    current = current.next

# With dummy (simpler):
current.next = ListNode(digit)
current = current.next
```

</details>

<details>
<summary><b>Question 3:</b> How would you modify this to handle numbers stored in normal order (most significant first)?</summary>

**Answer:** You could:
1. **Reverse both lists** first, then apply the same logic
2. **Use a stack** to process digits in reverse order
3. **Use recursion** to reach the end first

The reversed storage actually makes this problem easier!

</details>

---

## ğŸ¯ Practice Problems (Similar Pattern)

Here are 3 problems using the **Linked List Traversal + Math Simulation** pattern:

1. **Merge Two Sorted Lists** (LeetCode #21) - Easy ğŸŸ¢
   - *Why:* Simultaneous traversal of two linked lists
   - *Skill:* Managing two pointers, building result list

2. **Add Binary** (LeetCode #67) - Easy ğŸŸ¢
   - *Why:* Exact same pattern, but with strings and base-2
   - *Skill:* Carry management in different number bases

3. **Plus One** (LeetCode #66) - Easy ğŸŸ¢
   - *Why:* Similar carry propagation logic with arrays
   - *Skill:* Understanding when carry stops propagating

**For Linked List Practice:**
4. **Reverse Linked List** (LeetCode #206) - Easy ğŸŸ¢
   - *Why:* Fundamental linked list manipulation
   - *Skill:* Pointer management (needed for "Add Two Numbers II")

---

## ğŸ’¬ Interview Mindset Tips

### ğŸ™ï¸ 1. **Think Aloud - Elementary Math**
- Start with: *"This reminds me of adding numbers digit by digit with pencil and paper..."*
- Verbalize carry logic: *"When the sum is 10 or more, I need to carry the 1 to the next position..."*
- Mention the advantage: *"The reversed order makes this easierâ€”I can process left-to-right!"*

### â° 2. **Manage Time - Draw It Out**
- Spend 2 minutes **drawing an example** on paper/whiteboard
- Show the carry flow visually
- Example:
  ```
    2 â†’ 4 â†’ 3
  + 5 â†’ 6 â†’ 4
    â”€â”€â”€â”€â”€â”€â”€â”€â”€
    7 â†’ 0 â†’ 8
        Â¹  (carry)
  ```
- This helps interviewer see your understanding

### ğŸ§ª 3. **Test Edge Cases**
- Before coding, ask:
  - *"Should I handle None inputs?"* (No per constraints)
  - *"Can lists be different lengths?"* (Yes)
  - *"What's the max digit value?"* (0-9, single digit)
- After coding, test:
  - Different lengths: `[1,2,3]` + `[4,5]`
  - Final carry: `[9,9]` + `[1]`
  - Both zero: `[0]` + `[0]`

### âš–ï¸ 4. **Compare Trade-offs**
- Could mention: *"I could convert to integers, add, then convert back, but that would overflow for very large numbers. This digit-by-digit approach handles arbitrary precision."*
- Shows you think about real-world constraints

---

## âœ… Summary Checklist

Before moving to the next problem, make sure you can:

- [ ] Explain the dummy head technique and why it's useful
- [ ] Trace through an example with carry propagation
- [ ] Handle different length lists correctly
- [ ] Remember to check carry even after both lists end
- [ ] Write the solution from memory
- [ ] Identify this as a "math simulation" pattern

---

## ğŸ¯ Next Steps

You've completed **Problem 2 of 5** in this session! ğŸ‰

**Progress Check:**
- âœ… Problem 1: Two Sum (Hash Map)
- âœ… Problem 2: Add Two Numbers (Linked List + Math)
- â¬œ Problem 3: Coming next...

**Choose your next action:**

1. ğŸ”„ **Continue with Problem 3** - Keep building momentum
2. ğŸ¤ **Try Mock Interview for this problem** - Test your understanding
3. ğŸ“ **Review and compare both problems** - See pattern connections
4. ğŸ¤” **Take a break** - Process what you've learned

*When you're ready, let me know and we'll tackle the next challenge!*

---

<div align="center">

**Happy Coding! ğŸš€**

*Master the pattern, not just the problem!*

</div>
