# ðŸŽ¯ Problem 7: Search in Rotated Sorted Array

**Difficulty:** ðŸŸ¡ Medium  
**Pattern:** Binary Search (Modified)  
**Time Limit:** 25 minutes  
**LeetCode Link:** [#33 Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

---

## ðŸ“‹ Problem Statement

There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **rotated** at an unknown pivot index `k` (where `0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**).

For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` **after** the rotation and an integer `target`, return the **index** of `target` if it is in `nums`, or `-1` if it is not in `nums`.

**You must write an algorithm with O(log n) runtime complexity.**

### Examples:

**Example 1:**
```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**
```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Example 3:**
```
Input: nums = [1], target = 0
Output: -1
```

### Constraints:
- `1 <= nums.length <= 5000`
- `-10^4 <= nums[i] <= 10^4`
- All values of `nums` are **unique**
- `nums` is guaranteed to be rotated at some pivot
- `-10^4 <= target <= 10^4`

---

## ðŸŽ“ Understanding the Problem

### What does "rotated" mean?

Original sorted array: `[0, 1, 2, 4, 5, 6, 7]`

**Rotation at index 0:** `[0, 1, 2, 4, 5, 6, 7]` (no change)  
**Rotation at index 3:** `[4, 5, 6, 7, 0, 1, 2]` (split at index 3, move first part to end)  
**Rotation at index 5:** `[6, 7, 0, 1, 2, 4, 5]` (split at index 5)

### Key Observations:

1. **The array is still "partially sorted"**
   - At least one half of any split is properly sorted
   - Example: `[4,5,6,7,|0,1,2]` 
     - Left half [4,5,6,7] is sorted âœ“
     - Right half [0,1,2] is sorted âœ“

2. **We need O(log n) complexity**
   - This is a HUGE hint: Binary Search!
   - Linear search O(n) is too slow

3. **All values are distinct**
   - No duplicates! This simplifies logic
   - We don't need to handle equal values

### Visual Representation:

```
Original: [0, 1, 2, 4, 5, 6, 7]
                      â†“ (rotate at index 3)
Rotated:  [4, 5, 6, 7, 0, 1, 2]
           â””â”€sortedâ”€â”˜  â””sortedâ”˜
           
The "pivot" is where the array "breaks":
           [4, 5, 6, 7, | 0, 1, 2]
                        â†‘
                      pivot
```

---

## ðŸ” Pattern Recognition: Modified Binary Search

This is a **Binary Search variant**! Here's why:

### ðŸŽ¯ Standard Binary Search Recap

In a sorted array `[0, 1, 2, 4, 5, 6, 7]`:

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1  # Target in right half
        else:
            right = mid - 1  # Target in left half
    
    return -1
```

**Key insight:** We know where to go because the array is fully sorted.

### ðŸ”„ Modified Binary Search for Rotated Array

**Challenge:** Array is only partially sorted!

**Solution:** Determine which half is sorted, then decide where target could be.

### The Algorithm Logic:

At any midpoint, **at least one half MUST be sorted**:

```
Case 1: Left half is sorted
[4, 5, 6, 7, | 0, 1, 2]
 â””â”€sortedâ”€â”˜     â†‘
              mid=7
              
If nums[left] <= nums[mid]: left half is sorted!

Case 2: Right half is sorted  
[6, 7, 0, | 1, 2, 4, 5]
            â””â”€sortedâ”€â”€â”˜
          mid=1
          
If nums[mid] <= nums[right]: right half is sorted!
```

**Decision tree:**

```
1. Find mid
2. Identify which half is sorted:
   
   IF left half is sorted (nums[left] <= nums[mid]):
       IF target is in left half range:
           Search left
       ELSE:
           Search right
   
   ELSE (right half is sorted):
       IF target is in right half range:
           Search right
       ELSE:
           Search left
```

---

## ðŸ“ High-Level Plan

### Approach: Modified Binary Search

**Core Idea:**
1. Use binary search (left, mid, right pointers)
2. At each step, determine which half is sorted
3. Check if target is in the sorted half's range
4. Adjust search space accordingly

**Pseudocode:**
```
Initialize left = 0, right = len(nums) - 1

While left <= right:
    mid = (left + right) // 2
    
    If nums[mid] == target:
        return mid
    
    # Determine which half is sorted
    If left half is sorted (nums[left] <= nums[mid]):
        If target is in left half range:
            right = mid - 1
        Else:
            left = mid + 1
    
    Else (right half is sorted):
        If target is in right half range:
            left = mid + 1
        Else:
            right = mid - 1

return -1 (not found)
```

---

## ðŸ’¡ Progressive Hints

<details>
<summary><b>ðŸ’¡ Hint 1: How do we achieve O(log n)?</b></summary>

**O(log n) = Binary Search!**

But standard binary search assumes the array is fully sorted. Here, we need to **modify** binary search to handle the rotation.

Key insight: At any point, **at least one half of the array is properly sorted**. Use this to guide your search direction!

</details>

<details>
<summary><b>ðŸ’¡ Hint 2: How to determine which half is sorted?</b></summary>

Compare `nums[left]` with `nums[mid]`:

**If `nums[left] <= nums[mid]`:**
- Left half is sorted: `[nums[left] ... nums[mid]]`
- Example: `[4,5,6,7,|0,1,2]` where left=0, mid=3
  - `4 <= 7` âœ“ â†’ left half [4,5,6,7] is sorted

**Otherwise:**
- Right half is sorted: `[nums[mid] ... nums[right]]`
- Example: `[6,7,0,|1,2,4,5]` where left=0, mid=2
  - `6 <= 0` âœ— â†’ right half [0,1,2,4,5] is sorted

</details>

<details>
<summary><b>ðŸ’¡ Hint 3: How to check if target is in a sorted half?</b></summary>

If the left half is sorted (`nums[left]` to `nums[mid]`):
```python
if nums[left] <= target <= nums[mid]:
    # Target is in left half
    right = mid - 1
else:
    # Target must be in right half
    left = mid + 1
```

If the right half is sorted (`nums[mid]` to `nums[right]`):
```python
if nums[mid] <= target <= nums[right]:
    # Target is in right half
    left = mid + 1
else:
    # Target must be in left half
    right = mid - 1
```

</details>

---

## âœ… Complete Solution

```python
def search(nums: list[int], target: int) -> int:
    """
    Search for target in a rotated sorted array.
    
    Approach: Modified binary search
    - At each step, determine which half is sorted
    - Check if target is in the sorted half's range
    - Adjust search boundaries accordingly
    
    Time: O(log n) - Binary search eliminates half each iteration
    Space: O(1) - Only using pointers
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Found target!
        if nums[mid] == target:
            return mid
        
        # Determine which half is sorted
        if nums[left] <= nums[mid]:
            # Left half is sorted: [left...mid]
            
            # Check if target is in left half's range
            if nums[left] <= target < nums[mid]:
                # Target is in left half
                right = mid - 1
            else:
                # Target must be in right half
                left = mid + 1
        
        else:
            # Right half is sorted: [mid...right]
            
            # Check if target is in right half's range
            if nums[mid] < target <= nums[right]:
                # Target is in right half
                left = mid + 1
            else:
                # Target must be in left half
                right = mid - 1
    
    # Target not found
    return -1


# Test cases
def test_solution():
    test_cases = [
        # (nums, target, expected)
        ([4,5,6,7,0,1,2], 0, 4),
        ([4,5,6,7,0,1,2], 3, -1),
        ([1], 0, -1),
        ([1], 1, 0),
        ([1,3], 3, 1),
        ([3,1], 1, 1),
        ([5,1,3], 5, 0),
        ([4,5,6,7,8,1,2,3], 8, 4),
        ([6,7,1,2,3,4,5], 6, 0),
        ([2,3,4,5,6,7,1], 1, 6),
    ]
    
    for i, (nums, target, expected) in enumerate(test_cases, 1):
        result = search(nums, target)
        status = "âœ“" if result == expected else "âœ—"
        print(f"Test {i}: {status} nums={nums}, target={target} â†’ {result} (expected {expected})")

test_solution()
```

---

## ðŸ”¬ Step-by-Step Walkthrough

Let's trace through **`nums = [4,5,6,7,0,1,2]`, `target = 0`**:

```
Initial State:
nums = [4, 5, 6, 7, 0, 1, 2]
        0  1  2  3  4  5  6  (indices)
left = 0, right = 6, target = 0

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Iteration 1:
â”œâ”€ mid = (0 + 6) // 2 = 3
â”œâ”€ nums[mid] = nums[3] = 7
â”œâ”€ nums[mid] != target (7 != 0)
â”‚
â”œâ”€ Check which half is sorted:
â”‚  nums[left] = 4, nums[mid] = 7
â”‚  4 <= 7 âœ“ â†’ Left half [4,5,6,7] is sorted
â”‚
â”œâ”€ Is target in left half range?
â”‚  nums[left] <= target < nums[mid]?
â”‚  4 <= 0 < 7? NO âœ—
â”‚
â””â”€ Target NOT in left half, search right
   left = mid + 1 = 4

State: [4, 5, 6, 7, | 0, 1, 2]
                      â†‘       â†‘
                    left    right

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Iteration 2:
â”œâ”€ mid = (4 + 6) // 2 = 5
â”œâ”€ nums[mid] = nums[5] = 1
â”œâ”€ nums[mid] != target (1 != 0)
â”‚
â”œâ”€ Check which half is sorted:
â”‚  nums[left] = 0, nums[mid] = 1
â”‚  0 <= 1 âœ“ â†’ Left half [0,1] is sorted
â”‚
â”œâ”€ Is target in left half range?
â”‚  nums[left] <= target < nums[mid]?
â”‚  0 <= 0 < 1? YES âœ“
â”‚
â””â”€ Target IS in left half, search left
   right = mid - 1 = 4

State: [4, 5, 6, 7, 0, | 1, 2]
                    â†‘
                left/right

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Iteration 3:
â”œâ”€ mid = (4 + 4) // 2 = 4
â”œâ”€ nums[mid] = nums[4] = 0
â””â”€ nums[mid] == target! âœ“

Return: 4

Final Answer: 4
```

---

## âš¡ Complexity Analysis

### Time Complexity: **O(log n)**

**Why?**
- Each iteration eliminates half of the search space
- Number of iterations = logâ‚‚(n)
- All operations inside the loop are O(1)

**Proof by example:**
- n = 8 â†’ max 3 iterations (2Â³ = 8)
- n = 16 â†’ max 4 iterations (2â´ = 16)
- n = 1000 â†’ max 10 iterations (2Â¹â° = 1024)

### Space Complexity: **O(1)**

- Only using a fixed number of variables: `left`, `right`, `mid`
- No recursion (iterative approach)
- No additional data structures

---

## ðŸŽ¨ Variations to Consider

### Variation 1: **Find Minimum in Rotated Sorted Array**

```python
def findMin(nums: list[int]) -> int:
    """
    Find the minimum element in a rotated sorted array.
    Example: [4,5,6,7,0,1,2] â†’ 0
    
    Key insight: Minimum is at the "break point"
    """
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        if nums[mid] > nums[right]:
            # Minimum is in right half
            left = mid + 1
        else:
            # Minimum is in left half (including mid)
            right = mid
    
    return nums[left]
```

### Variation 2: **Search in Rotated Array with Duplicates**

```python
def search_with_duplicates(nums: list[int], target: int) -> bool:
    """
    Search when duplicates are allowed.
    Problem: Can't determine which half is sorted when nums[left] == nums[mid]
    
    Example: [1,0,1,1,1] target=0
              â†‘     â†‘
            left   mid
    Can't tell if left or right half is sorted!
    
    Solution: Increment left when nums[left] == nums[mid]
    Worst case: O(n) when all elements are the same
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return True
        
        # Can't determine which half is sorted
        if nums[left] == nums[mid] == nums[right]:
            left += 1
            right -= 1
        elif nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return False
```

### Variation 3: **Find Rotation Index (Pivot Point)**

```python
def findRotationIndex(nums: list[int]) -> int:
    """
    Find the index where the array was rotated.
    Example: [4,5,6,7,0,1,2] â†’ 4 (index of 0)
    
    This is the same as finding the minimum element's index!
    """
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    
    return left
```

---

## ðŸ¤” Reflection Questions

1. **Why must at least one half always be sorted?**
   <details>
   <summary>Answer</summary>
   
   Because the array was originally fully sorted, then rotated. A rotation is just moving a contiguous block from one end to the other. This preserves sorting within each block. When we split at any point, at least one of the two sides must be within a single sorted block.
   
   Visual proof:
   ```
   Original: [0,1,2,3,4,5,6,7]
   Rotated:  [4,5,6,7,|0,1,2,3]
              â””sortedâ”˜ â””sortedâ”˜
   
   Any split hits at least one sorted section!
   ```
   
   </details>

2. **What if the array wasn't rotated at all (pivot = 0)?**
   <details>
   <summary>Answer</summary>
   
   The algorithm still works! The entire array is sorted, so every comparison treats the left half as sorted, and it behaves exactly like standard binary search.
   
   ```
   nums = [0,1,2,3,4,5,6]
   At every step, nums[left] <= nums[mid], so left half is always "sorted"
   â†’ Standard binary search behavior
   ```
   
   </details>

3. **Why don't we need to find the pivot point first?**
   <details>
   <summary>Answer</summary>
   
   We could do it in two steps:
   1. Find pivot using binary search: O(log n)
   2. Binary search in appropriate half: O(log n)
   Total: O(log n) + O(log n) = O(log n)
   
   But our single-pass approach is simpler and also O(log n), so why complicate things?
   
   </details>

4. **What makes this problem "Medium" instead of "Easy"?**
   <details>
   <summary>Answer</summary>
   
   - Requires understanding of binary search (not trivial)
   - Need to modify standard algorithm (not just apply template)
   - Multiple conditions to track (sorted half, target range)
   - Edge cases (single element, target at boundaries)
   - Common to get the comparison logic wrong (< vs <=)
   
   </details>

---

## ðŸŽ¯ Practice Problems

Once you've mastered this problem, try these related binary search problems:

1. **[LeetCode 153] Find Minimum in Rotated Sorted Array** (Medium)
   - Pattern: Binary search with rotation
   - Find the minimum element

2. **[LeetCode 81] Search in Rotated Sorted Array II** (Medium)
   - Pattern: Binary search with duplicates
   - Handle ambiguous cases

3. **[LeetCode 162] Find Peak Element** (Medium)
   - Pattern: Binary search with non-uniform ordering
   - Find local maximum

4. **[LeetCode 34] Find First and Last Position** (Medium)
   - Pattern: Binary search variants
   - Find range boundaries

---

## ðŸ’¡ Interview Tips

### What interviewers look for:

âœ… **Binary Search Recognition:**
- "I see O(log n) requirement â†’ Binary Search"
- Explain why linear search won't satisfy constraints

âœ… **Problem Analysis:**
- Identify the "rotation" property
- Recognize that one half is always sorted

âœ… **Edge Case Handling:**
- Single element array
- Target at boundaries
- Array not rotated (pivot = 0)

âœ… **Clear Logic:**
- Explain each comparison (`<` vs `<=`)
- Walk through a concrete example

### Common Mistakes to Avoid:

âŒ Using `<` instead of `<=` in `nums[left] <= nums[mid]`  
âŒ Wrong target range check (missing equals in `<=`)  
âŒ Off-by-one errors in `mid + 1` or `mid - 1`  
âŒ Forgetting to return `-1` when target not found  
âŒ Using `while left < right` instead of `while left <= right`

### Pro Tips:

ðŸ’¡ **Draw it out:** Sketch the rotated array during the interview  
ðŸ’¡ **Test with examples:** Walk through [4,5,6,7,0,1,2] step by step  
ðŸ’¡ **Explain comparisons:** Why `nums[left] <= nums[mid]` not just `<`?  
ðŸ’¡ **Cover edge cases:** What if nums = [1]? What if target = nums[0]?

---

## ðŸ† Key Takeaways

1. **O(log n) â†’ Think Binary Search**
2. **Rotation preserves partial sorting**
3. **At least one half is always sorted**
4. **Compare boundaries to determine sorted half**
5. **Check if target is in sorted half's range**
6. **Standard binary search template with extra logic**

### The Decision Tree (Memorize This!):

```
                 [Find mid]
                     |
            Is nums[mid] == target?
           /                        \
         YES                        NO
          |                          |
      Return mid         Which half is sorted?
                       /              \
              nums[left]<=mid      nums[mid]<=right
                   |                     |
              Left sorted           Right sorted
                   |                     |
          target in range?        target in range?
           /          \             /          \
         YES          NO          YES          NO
          |            |           |            |
      right=mid-1  left=mid+1  left=mid+1  right=mid-1
```

---

**Ready to test yourself?** ðŸš€  
Move on to **`7.Search-in-Rotated-Sorted-Array-Mock-Interview-Mode.md`** for a timed challenge!

**Pattern Mastery Progress:** ðŸ”¥  
Session 1: Hash Map âœ“ | Linked List âœ“ | Stack âœ“ | Greedy âœ“ | Two Pointers âœ“  
**Session 2: Sliding Window âœ“ | Binary Search â† YOU ARE HERE** | BFS/DFS | Array/Prefix | BST

---

*Happy Coding! ðŸ’»âœ¨*
