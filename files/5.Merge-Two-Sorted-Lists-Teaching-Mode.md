# 📘 Merge Two Sorted Lists - Teaching Mode

> **Difficulty:** 🟢 Easy  
> **Problem Link:** [LeetCode #21](https://leetcode.com/problems/merge-two-sorted-lists/)  
> **Pattern:** Linked List / Two Pointers  
> **Session:** Problem 5 of 5

---

## 🧩 Problem Statement

You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists into one **sorted** list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

### 📝 Examples

**Example 1:**
```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```
Visual:
```
list1:  1 → 2 → 4
list2:  1 → 3 → 4
             ↓
result: 1 → 1 → 2 → 3 → 4 → 4
```

**Example 2:**
```
Input: list1 = [], list2 = []
Output: []
```

**Example 3:**
```
Input: list1 = [], list2 = [0]
Output: [0]
```

### 🔍 Input/Output Types
- **Input:** 
  - `list1`: Head of first sorted linked list (`Optional[ListNode]`)
  - `list2`: Head of second sorted linked list (`Optional[ListNode]`)
- **Output:** Head of merged sorted linked list (`Optional[ListNode]`)

**ListNode Definition:**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

---

## 🧠 Understanding the Problem

**What is this problem really asking?**

Combine two already-sorted lists into one sorted list, maintaining the sorted order. You're not creating new nodes—you're **rearranging pointers** to splice the existing nodes together.

**Real-World Analogy:**  
Imagine you have two sorted decks of cards, and you want to merge them into one sorted deck. You compare the top cards from each deck, take the smaller one, and repeat until both decks are empty.

**Key Points:**
- ✅ Both input lists are **already sorted** (ascending order)
- ✅ Must maintain sorted order in result
- ✅ Reuse existing nodes (don't create new ones)
- ✅ Either or both lists can be empty
- ⚠️ Values can be duplicates (e.g., both lists have 1)

**Edge Cases:**
- Both lists empty: `[]` + `[]` → `[]`
- One list empty: `[1,2]` + `[]` → `[1,2]`
- Different lengths: `[1,2,3,4]` + `[5]`
- All values same: `[1,1,1]` + `[1,1]` → `[1,1,1,1,1]`
- Interleaved values: `[1,3,5]` + `[2,4,6]`

---

## 🧭 Recognizing the Pattern(s)

### 🎯 Primary Pattern: **Two Pointers + Dummy Head**

**Analogy:** Think of it like a merge operation in **merge sort**. You have two sorted halves, and you're combining them by repeatedly picking the smaller element from the two "fronts."

**Why This Pattern?**
- Both lists are sorted → Can process them linearly
- Need to compare elements from both → Two pointers
- Building a new list → Dummy head simplifies construction
- Classic merge operation → Fundamental algorithm

**Visual Example:**
```
list1: 1 → 2 → 4
       ↑
list2: 1 → 3 → 4
       ↑

Compare: 1 vs 1 → Take list1's 1
Result: 1

list1:     2 → 4
           ↑
list2: 1 → 3 → 4
       ↑

Compare: 2 vs 1 → Take list2's 1
Result: 1 → 1

Continue until both exhausted...
```

---

## 🪜 High-Level Plan

### Strategy: Merge Like in Merge Sort

1. **Create a dummy head** node (simplifies result construction)
2. **Initialize a current pointer** to track where to append next node
3. **While both lists have nodes:**
   - Compare values at current positions
   - Append the smaller node to result
   - Move that list's pointer forward
   - Move current pointer forward
4. **After loop:** One list might have remaining nodes
   - Append all remaining nodes from non-empty list
5. **Return** `dummy.next` (skip dummy head)

### 📋 Pseudocode

```python
# Step 1: Create dummy head
dummy = ListNode(0)
current = dummy

# Step 2: Merge while both lists have nodes
while list1 AND list2:
    if list1.val <= list2.val:
        current.next = list1
        list1 = list1.next
    else:
        current.next = list2
        list2 = list2.next
    current = current.next

# Step 3: Append remaining nodes
if list1:
    current.next = list1
else:
    current.next = list2

# Step 4: Return merged list (skip dummy)
return dummy.next
```

---

## 💡 Hints Policy

### 🎓 Level 1 Hint (Small Nudge)
<details>
<summary>Click to reveal Level 1 Hint</summary>

Think about how you'd merge two sorted arrays: you'd compare elements from each, take the smaller one, and move forward. The same logic applies here, but with linked list pointers.

Use a **dummy head** node to simplify building the result list—you won't need special logic for the first node.

</details>

### 🎓 Level 2 Hint (Medium Help)
<details>
<summary>Click to reveal Level 2 Hint</summary>

**Algorithm:**
1. Create a dummy node and a current pointer
2. While both lists exist:
   - Compare `list1.val` and `list2.val`
   - Point `current.next` to the smaller one
   - Move that list's pointer forward
   - Move current forward
3. After the loop, one list might have nodes left—append them all

**Key insight:** You're not creating new nodes, just rearranging pointers!

</details>

### 🎓 Level 3 Hint (Almost There)
<details>
<summary>Click to reveal Level 3 Hint</summary>

```python
def mergeTwoLists(list1, list2):
    dummy = ListNode(0)
    current = dummy
    
    while list1 and list2:
        if list1.val <= list2.val:
            current.next = list1
            list1 = list1.next
        else:
            current.next = list2
            list2 = list2.next
        current = current.next
    
    # Append remaining nodes
    current.next = list1 if list1 else list2
    
    return dummy.next
```

**Why `<=` instead of `<`?** To maintain stability (keep original order for equal values).

</details>

---

## 🧑‍💻 Code Solution (Python)

### ✨ Optimal Solution (Iterative)

```python
# Time Complexity: O(m + n) where m, n are lengths of list1, list2
# Space Complexity: O(1) - Only pointer manipulation, no new nodes

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def mergeTwoLists(list1, list2):
    """
    Merge two sorted linked lists into one sorted list.
    
    Strategy: Use two pointers to traverse both lists,
    always appending the smaller value to result.
    
    Args:
        list1: Head of first sorted linked list
        list2: Head of second sorted linked list
    
    Returns:
        Head of merged sorted linked list
    """
    # Step 1: Create dummy head for easy result construction
    dummy = ListNode(0)
    current = dummy
    
    # Step 2: Merge while both lists have nodes
    while list1 and list2:
        # Compare values and choose smaller
        if list1.val <= list2.val:
            current.next = list1
            list1 = list1.next  # Move list1 forward
        else:
            current.next = list2
            list2 = list2.next  # Move list2 forward
        
        # Move current forward
        current = current.next
    
    # Step 3: Append remaining nodes (one list is exhausted)
    # One of these will be None, one might have nodes left
    current.next = list1 if list1 else list2
    
    # Step 4: Return result (skip dummy head)
    return dummy.next


# ✅ Helper functions for testing
def create_linked_list(arr):
    """Create a linked list from an array."""
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for val in arr[1:]:
        current.next = ListNode(val)
        current = current.next
    return head


def linked_list_to_array(head):
    """Convert linked list to array for easy testing."""
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result


# ✅ Test Cases
def test_merge_two_lists():
    # Test 1: Normal merge
    list1 = create_linked_list([1, 2, 4])
    list2 = create_linked_list([1, 3, 4])
    result = mergeTwoLists(list1, list2)
    assert linked_list_to_array(result) == [1, 1, 2, 3, 4, 4]
    print("✅ Test 1 passed: [1,2,4] + [1,3,4] = [1,1,2,3,4,4]")
    
    # Test 2: Both empty
    list1 = create_linked_list([])
    list2 = create_linked_list([])
    result = mergeTwoLists(list1, list2)
    assert linked_list_to_array(result) == []
    print("✅ Test 2 passed: [] + [] = []")
    
    # Test 3: One empty
    list1 = create_linked_list([])
    list2 = create_linked_list([0])
    result = mergeTwoLists(list1, list2)
    assert linked_list_to_array(result) == [0]
    print("✅ Test 3 passed: [] + [0] = [0]")
    
    # Test 4: Different lengths
    list1 = create_linked_list([1, 2, 3, 4])
    list2 = create_linked_list([5])
    result = mergeTwoLists(list1, list2)
    assert linked_list_to_array(result) == [1, 2, 3, 4, 5]
    print("✅ Test 4 passed: [1,2,3,4] + [5] = [1,2,3,4,5]")
    
    # Test 5: Interleaved
    list1 = create_linked_list([1, 3, 5])
    list2 = create_linked_list([2, 4, 6])
    result = mergeTwoLists(list1, list2)
    assert linked_list_to_array(result) == [1, 2, 3, 4, 5, 6]
    print("✅ Test 5 passed: [1,3,5] + [2,4,6] = [1,2,3,4,5,6]")

test_merge_two_lists()
```

### 🔄 Alternative Solution (Recursive)

```python
def mergeTwoLists_recursive(list1, list2):
    """
    Recursive approach - elegant but uses call stack.
    
    Base cases: If one list is empty, return the other.
    Recursive case: Choose smaller head, recurse on rest.
    """
    # Base cases
    if not list1:
        return list2
    if not list2:
        return list1
    
    # Recursive case: choose smaller and recurse
    if list1.val <= list2.val:
        list1.next = mergeTwoLists_recursive(list1.next, list2)
        return list1
    else:
        list2.next = mergeTwoLists_recursive(list1, list2.next)
        return list2


# Test
list1 = create_linked_list([1, 2, 4])
list2 = create_linked_list([1, 3, 4])
result = mergeTwoLists_recursive(list1, list2)
print(linked_list_to_array(result))  # [1, 1, 2, 3, 4, 4]
```

---

## 🧩 Step-by-Step Explanation

Let's trace through **Example 1:** `list1 = [1,2,4]`, `list2 = [1,3,4]`

### Initialization
```python
dummy = ListNode(0)  # dummy → 0
current = dummy
```

### Iteration 1
```
list1: 1 → 2 → 4
       ↑
list2: 1 → 3 → 4
       ↑

Compare: 1 <= 1? YES
Action: current.next = list1
        list1 = list1.next

Result: dummy → 1
        current moves to 1
        list1 now points to 2
```

### Iteration 2
```
list1:     2 → 4
           ↑
list2: 1 → 3 → 4
       ↑

Compare: 2 <= 1? NO
Action: current.next = list2
        list2 = list2.next

Result: dummy → 1 → 1
        current moves to second 1
        list2 now points to 3
```

### Iteration 3
```
list1:     2 → 4
           ↑
list2:         3 → 4
               ↑

Compare: 2 <= 3? YES
Action: current.next = list1
        list1 = list1.next

Result: dummy → 1 → 1 → 2
        current moves to 2
        list1 now points to 4
```

### Iteration 4
```
list1:             4
                   ↑
list2:         3 → 4
               ↑

Compare: 4 <= 3? NO
Action: current.next = list2
        list2 = list2.next

Result: dummy → 1 → 1 → 2 → 3
        current moves to 3
        list2 now points to 4
```

### Iteration 5
```
list1:             4
                   ↑
list2:                 4
                       ↑

Compare: 4 <= 4? YES
Action: current.next = list1
        list1 = list1.next

Result: dummy → 1 → 1 → 2 → 3 → 4
        current moves to 4
        list1 now None
```

### Loop Exit & Cleanup
```
list1 = None
list2:                     4
                           ↑

Action: current.next = list2 (remaining nodes)

Result: dummy → 1 → 1 → 2 → 3 → 4 → 4
```

### Return
```python
return dummy.next  # Returns: 1 → 1 → 2 → 3 → 4 → 4 ✅
```

---

## 🎬 Visual Walkthrough

```
Step-by-step merge of [1,2,4] and [1,3,4]:

Initial:
  L1: 1 → 2 → 4
  L2: 1 → 3 → 4

┌─────────────────────────────┐
│ Compare 1 vs 1 → Take L1    │
│ Result: 1                   │
└─────────────────────────────┘

┌─────────────────────────────┐
│ Compare 2 vs 1 → Take L2    │
│ Result: 1 → 1               │
└─────────────────────────────┘

┌─────────────────────────────┐
│ Compare 2 vs 3 → Take L1    │
│ Result: 1 → 1 → 2           │
└─────────────────────────────┘

┌─────────────────────────────┐
│ Compare 4 vs 3 → Take L2    │
│ Result: 1 → 1 → 2 → 3       │
└─────────────────────────────┘

┌─────────────────────────────┐
│ Compare 4 vs 4 → Take L1    │
│ Result: 1 → 1 → 2 → 3 → 4   │
└─────────────────────────────┘

┌─────────────────────────────┐
│ L1 exhausted, append L2     │
│ Result: 1→1→2→3→4→4 ✅      │
└─────────────────────────────┘
```

---

## ⏱️ Complexity Analysis

### Time Complexity: **O(m + n)**
- `m` = length of list1, `n` = length of list2
- We visit each node in both lists exactly once
- Each comparison and pointer update is O(1)
- Total: **O(m + n)**

### Space Complexity: **O(1)**
- **Iterative version:** Only use a few pointers (dummy, current)
- No new nodes created, just rearranging pointers
- **Constant space: O(1)** ✅

**Recursive version:** O(m + n) space due to call stack

### 📊 Why This Is Optimal

- **Can't do better than O(m+n) time:** Must visit each node at least once
- **O(1) space is optimal:** We reuse existing nodes, no extra allocation
- **Single pass:** No need for multiple traversals

---

## 🔁 Variations & Follow-Ups

### 🟢 Similar Easy Problems
1. **Merge Sorted Array** (LeetCode #88) - Merge two sorted arrays
   - Same two-pointer logic, but with arrays
   - Can do in-place

2. **Intersection of Two Linked Lists** (LeetCode #160)
   - Two pointers on linked lists
   - Different goal but similar traversal

### 🟡 Medium Variations
3. **Merge k Sorted Lists** (LeetCode #23) - Merge multiple sorted lists
   - Use min-heap or divide-and-conquer
   - Time: O(N log k) where N is total nodes

4. **Sort List** (LeetCode #148) - Sort a linked list
   - Use merge sort (this problem is the merge step!)
   - Time: O(n log n)

### 🔴 Advanced Applications
5. **Merge Intervals** (LeetCode #56) - Merge overlapping intervals
   - Similar merging concept with arrays
   - Requires sorting first

6. **Count of Smaller Numbers After Self** (LeetCode #315)
   - Uses merge sort with counting
   - This problem's merge is a building block

**Pattern Evolution:**
- **Two sorted lists** (this problem) → Simple two-pointer merge
- **K sorted lists** → Heap-based merge
- **Unsorted list** → Sort first using merge sort (which uses this!)

---

## 🧩 Reflection & Reinforcement

### 📚 Check Your Understanding

<details>
<summary><b>Question 1:</b> Why do we use a dummy head instead of tracking the real head?</summary>

**Answer:** Dummy head eliminates special-case logic for the first node:

**Without dummy (more complex):**
```python
if not head:
    head = smaller_node
    current = head
else:
    current.next = smaller_node
    current = current.next
```

**With dummy (simpler):**
```python
current.next = smaller_node
current = current.next
```

Always having `dummy` ensures `current` always has a valid node to work with.

</details>

<details>
<summary><b>Question 2:</b> Why use `<=` instead of `<` in the comparison?</summary>

**Answer:** Using `<=` maintains **stability**—when values are equal, we take from list1 first, preserving the relative order. This is a good practice in merge operations. Using `<` would work too, but `<=` is conventional.

</details>

<details>
<summary><b>Question 3:</b> What's the advantage of the iterative solution over the recursive one?</summary>

**Answer:** 
- **Space:** Iterative uses O(1) space; recursive uses O(m+n) call stack
- **Performance:** Iterative avoids function call overhead
- **Safety:** Iterative won't cause stack overflow for very long lists

However, recursive is more elegant and easier to understand conceptually.

</details>

---

## 🎯 Practice Problems (Similar Pattern)

Here are 3 problems using the **Two Pointers on Linked Lists** pattern:

1. **Remove Duplicates from Sorted List** (LeetCode #83) - Easy 🟢
   - *Why:* Single pointer traversal of sorted linked list
   - *Skill:* Pointer manipulation on linked lists

2. **Linked List Cycle** (LeetCode #141) - Easy 🟢
   - *Why:* Two pointers (fast/slow) on linked list
   - *Skill:* Floyd's cycle detection algorithm

3. **Intersection of Two Linked Lists** (LeetCode #160) - Easy 🟢
   - *Why:* Two pointers traversing two lists
   - *Skill:* Synchronized traversal technique

**For Merge Pattern:**
4. **Merge Sorted Array** (LeetCode #88) - Easy 🟢
   - *Why:* Same merge logic but with arrays
   - *Skill:* In-place merging with two pointers

---

## 💬 Interview Mindset Tips

### 🎙️ 1. **Think Aloud - Relate to Merge Sort**
- Start with: *"This is like the merge step in merge sort—I have two sorted sequences and need to combine them..."*
- Verbalize: *"I'll use two pointers to track position in each list, always choosing the smaller value..."*
- Show pattern recognition: *"The dummy head technique will simplify building the result."*

### ⏰ 2. **Manage Time - Draw It**
- Spend 2 minutes drawing a simple example:
  ```
  1→2    +    1→3    =    ?
  ```
- Walk through 2-3 merge steps on paper
- This helps solidify the logic before coding

### 🧪 3. **Test Edge Cases**
Before coding, mention:
- *"I should handle: both empty, one empty, different lengths, all same values."*

After coding:
```python
mergeTwoLists([], [])           # Empty
mergeTwoLists([1,2,3], [])      # One empty
mergeTwoLists([1], [1])         # Equal values
mergeTwoLists([1,2,3], [4,5])   # No overlap
```

### ⚖️ 4. **Compare Iterative vs Recursive**
- *"I could solve this recursively—it's elegant—but iterative uses O(1) space instead of O(n) call stack. For production code, I'd use iterative."*
- Shows you understand trade-offs

---

## ✅ Summary Checklist

Before moving on, make sure you can:

- [ ] Explain the dummy head technique and why it's useful
- [ ] Implement both iterative and recursive solutions
- [ ] Trace through an example showing pointer movements
- [ ] Handle edge cases (empty lists, different lengths)
- [ ] Recognize this as the "merge" step in merge sort
- [ ] Extend logic to merge k sorted lists (with heap)

---

## 🎯 Session 1 Complete! 

**🎉 Congratulations! You've completed all 5 problems! 🎉**

**Progress:**
- ✅ Problem 1: Two Sum (Hash Map)
- ✅ Problem 2: Add Two Numbers (Linked List)
- ✅ Problem 3: Valid Parentheses (Stack)
- ✅ Problem 4: Best Time to Buy/Sell Stock (Greedy)
- ✅ Problem 5: Merge Two Sorted Lists (Two Pointers)

**Patterns Mastered:**
- ✅ Hash Map for O(1) lookup
- ✅ Linked List manipulation (dummy head, carry, merge)
- ✅ Stack for LIFO/nested structures
- ✅ Greedy with state tracking
- ✅ Two pointers for sorted sequences

---

## 🚀 What's Next?

**Choose your path:**

1. 📚 **Study & Practice** - Master these 5 problems first
2. 🎤 **Try All Mock Interviews** - Test yourself under pressure
3. ⬆️ **Session 2: Medium Problems** - Level up your skills
4. 🎯 **Focus on Weak Patterns** - Targeted practice

*You now have a solid foundation. Keep building on it!*

---

<div align="center">

**Happy Coding! 🚀**

*The merge pattern is fundamental—you'll see it everywhere!*

</div>
